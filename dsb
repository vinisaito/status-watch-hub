import { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Trash2, Plus, Webhook } from 'lucide-react';
import { toast } from '@/hooks/use-toast';

interface WebhookConfigProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

interface WebhookEntry {
  url: string;
  tipo_evento?: string;
  ativo?: boolean;
  criado_por?: string;
  criado_em?: string;
}

// Agora armazenamos os webhooks agrupados por time/grupo:
// { [grupo: string]: WebhookEntry[] }
type WebhooksByGroup = Record<string, WebhookEntry[]>;

const API_BASE = "https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/webhook";

// Busca todos os grupos existentes
async function fetchAllGroups(): Promise<string[]> {
  const res = await fetch(API_BASE, { method: 'GET', headers: { 'Content-Type': 'application/json' } });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error(txt || 'Falha ao carregar grupos');
  }
  const json = await res.json();
  return json.grupos || [];
}

// Busca os webhooks de um grupo específico
async function fetchWebhooksFromApi(grupo: string): Promise<{ grupo_id: string; webhooks: WebhookEntry[] }> {
  const res = await fetch(`${API_BASE}?grupo_id=${encodeURIComponent(grupo)}`, {
    method: 'GET',
    headers: { 'Content-Type': 'application/json' },
  });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error(txt || 'Falha ao carregar webhooks do servidor');
  }
  return res.json();
}

async function addOrUpdateWebhookApi(payload: {
  grupo_id: string;
  url: string;
  tipo_evento?: string;
  usuario: string;
}): Promise<{ message: string; webhooks: WebhookEntry[] }> {
  const res = await fetch(`${API_BASE}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error(txt || 'Erro ao adicionar webhook');
  }
  return res.json();
}

async function removeWebhookApi(payload: {
  grupo_id: string;
  url: string;
  tipo_evento?: string;
}): Promise<{ message: string; webhooks: WebhookEntry[] }> {
  const res = await fetch(`${API_BASE}`, {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error(txt || 'Erro ao remover webhook');
  }
  return res.json();
}

export const WebhookConfig = ({ open, onOpenChange }: WebhookConfigProps) => {
  // webhooks agrupados por grupo/time
  const [webhooksByGroup, setWebhooksByGroup] = useState<WebhooksByGroup>({});
  const [crisisWebhook, setCrisisWebhook] = useState('');
  const [newTeam, setNewTeam] = useState(''); // para novo grupo (time)
  const [newWebhook, setNewWebhook] = useState('');
  const [loadingGroups, setLoadingGroups] = useState<string[]>([]);
  const [isSaving, setIsSaving] = useState(false);

  // Ao abrir o modal, carregar grupos + webhooks
  useEffect(() => {
    if (!open) return;

    // Limpa dados antigos ao abrir
    setWebhooksByGroup({});

    // Carrega webhook de crise do localStorage
    const savedCrisisWebhook = localStorage.getItem('crisisWebhook');
    if (savedCrisisWebhook) {
      setCrisisWebhook(savedCrisisWebhook);
    }

    const loadAll = async () => {
      try {
        const grupos = await fetchAllGroups();

        if (grupos.length === 0) {
          toast({ title: "Nenhum grupo encontrado", description: "Não existem grupos com webhooks configurados." });
          return;
        }

        // Para cada grupo, buscar os webhooks
        setLoadingGroups(grupos);
        const allWebhooks: WebhooksByGroup = {};
        await Promise.all(
          grupos.map(async (grupo) => {
            try {
              const data = await fetchWebhooksFromApi(grupo);
              allWebhooks[grupo] = data.webhooks.filter(w => w.ativo);
            } catch (err: any) {
              toast({
                title: "Erro ao carregar grupo",
                description: `Falha ao carregar webhooks do grupo ${grupo}: ${err.message}`,
                variant: "destructive",
              });
              allWebhooks[grupo] = [];
            }
          })
        );
        setWebhooksByGroup(allWebhooks);
      } catch (e: any) {
        toast({
          title: "Erro ao carregar grupos",
          description: e.message || "Falha ao carregar grupos",
          variant: "destructive",
        });
      } finally {
        setLoadingGroups([]);
      }
    };

    loadAll();
  }, [open]);

  // Adiciona ou atualiza um webhook em um grupo específico
  const addWebhook = async () => {
    if (!newTeam.trim() || !newWebhook.trim()) {
      toast({
        title: "Campos obrigatórios",
        description: "Preencha o nome da equipe e a URL do webhook",
        variant: "destructive",
      });
      return;
    }

    if (!newWebhook.startsWith('https://chat.googleapis.com/')) {
      toast({
        title: "URL inválida",
        description: "A URL deve ser um webhook válido do Google Chat",
        variant: "destructive",
      });
      return;
    }

    const teamKey = newTeam.trim();
    const webhookUrl = newWebhook.trim();

    // Otimista
    const optimistic = {
      ...webhooksByGroup,
      [teamKey]: [...(webhooksByGroup[teamKey] || []), { url: webhookUrl, ativo: true }],
    };
    setWebhooksByGroup(optimistic);

    setNewTeam('');
    setNewWebhook('');

    toast({
      title: "Salvando...",
      description: `Tentando adicionar webhook para ${teamKey}`,
    });

    try {
      setIsSaving(true);
      const result = await addOrUpdateWebhookApi({
        grupo_id: teamKey,
        url: webhookUrl,
        tipo_evento: 'default',
        usuario: 'admin',
      });

      // Atualiza webhooks do grupo com retorno da API
      setWebhooksByGroup(prev => ({
        ...prev,
        [teamKey]: result.webhooks.filter(w => w.ativo),
      }));

      toast({
        title: "Webhook adicionado",
        description: `Webhook configurado para a equipe ${teamKey}`,
      });
    } catch (e: any) {
      // Rollback
      setWebhooksByGroup(prev => {
        const filtered = (prev[teamKey] || []).filter(w => w.url !== webhookUrl);
        return { ...prev, [teamKey]: filtered };
      });
      toast({
        title: "Erro",
        description: e.message || "Falha ao adicionar webhook",
        variant: "destructive",
      });
    } finally {
      setIsSaving(false);
    }
  };

  // Remove um webhook do grupo
  const removeWebhook = async (team: string, url: string) => {
    const groupWebhooks = webhooksByGroup[team] || [];
    if (!groupWebhooks.find(w => w.url === url)) return;

    // Otimista
    setWebhooksByGroup(prev => ({
      ...prev,
      [team]: prev[team].filter(w => w.url !== url),
    }));

    try {
      setIsSaving(true);
      await removeWebhookApi({
        grupo_id: team,
        url,
        tipo_evento: 'default',
      });
      toast({
        title: "Webhook removido",
        description: `Webhook da equipe ${team} foi removido`,
      });
    } catch (e: any) {
      // Rollback
      setWebhooksByGroup(prev => ({
        ...prev,
        [team]: [...prev[team], { url, ativo: true }],
      }));
      toast({
        title: "Erro",
        description: e.message || "Falha ao remover webhook",
        variant: "destructive",
      });
    } finally {
      setIsSaving(false);
    }
  };

  // Save Crisis Webhook remains as your original code (no changes)
  const saveCrisisWebhook = async () => {
    const urlTrimmed = crisisWebhook.trim();

    if (!urlTrimmed) {
      toast({ title: "Campo vazio", description: "Informe a URL do webhook de crise", variant: "destructive" });
      return;
    }
    if (!urlTrimmed.startsWith('https://chat.googleapis.com/')) {
      toast({ title: "URL inválida", description: "Use um webhook válido do Google Chat", variant: "destructive" });
      return;
    }

    // Se a URL atual é igual a já salva, não salvar de novo
    if (urlTrimmed === localStorage.getItem('crisisWebhook')) {
      toast({ title: "Sem alterações", description: "A URL do webhook de crise não foi modificada.", variant: "default" });
      return;
    }

    try {
      setIsSaving(true);
      await addOrUpdateWebhookApi({
        grupo_id: 'crise',
        url: urlTrimmed,
        tipo_evento: 'crise',
        usuario: 'admin',
      });
      localStorage.setItem('crisisWebhook', urlTrimmed);
      setCrisisWebhook(urlTrimmed);
      toast({ title: "Webhook de crise salvo", description: "Configuração salva com sucesso" });
    } catch (e: any) {
      toast({ title: "Erro", description: e.message || "Falha ao salvar webhook de crise", variant: "destructive" });
    } finally {
      setIsSaving(false);
    }
  };

  const isCrisisSaveDisabled =
    isSaving ||
    !crisisWebhook.trim() ||
    crisisWebhook.trim() === localStorage.getItem('crisisWebhook');

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent
        className="bg-panel-bg border-border w-[90vw] max-w-[700px] mx-auto min-h-[50vh] max-h-[90vh] overflow-y-auto py-6 sm:py-8 lg:py-12 px-4 sm:px-6 lg:px-10">
        <DialogHeader>
          <DialogTitle className="text-white text-2xl text-center w-full flex justify-center items-center gap-2">
            <Webhook className="h-5 w-5 text-white" />
            Configuração de Webhooks
          </DialogTitle>

        </DialogHeader>


        {/* Adicionar novo webhook */}
        <div className="border border-border rounded-lg p-4 bg-background/50 space-y-4">
          <CardTitle className="text-primary text-lg text-center w-full flex justify-center items-center gap-2">
            Cadastre o Webhook do Grupo
          </CardTitle>
          <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0">
            <div className="flex-1">
              <Label htmlFor="team-name">Nome do Grupo</Label>
              <Input
                id="team-name"
                value={newTeam}
                onChange={(e) => setNewTeam(e.target.value)}
                placeholder="Ex: NOC, SOC, Infraestrutura"
                className="bg-background border-border"
              />
            </div>
            <div className="flex-1">
              <Label htmlFor="webhook-url">URL do Webhook</Label>
              <Input
                id="webhook-url"
                value={newWebhook}
                onChange={(e) => setNewWebhook(e.target.value)}
                placeholder="https://chat.googleapis.com/v1/spaces/..."
                className="bg-background border-border"
              />
            </div>
          </div>
          <Button
            onClick={addWebhook}
            className="w-full"
            disabled={isSaving || !newTeam.trim() || !newWebhook.trim()}
          >
            <Plus className="h-4 w-4 mr-2" />
            Adicionar Webhook
          </Button>
        </div>

        {/* Seção explicativa */}
        <Card className="bg-background/30 border-border">
          <CardHeader>
            <CardTitle className="text-sm text-muted-foreground text-center">
              Como obter um Webhook do Google Chat
            </CardTitle>
          </CardHeader>
          <CardContent>
            <ol className="text-sm text-muted-foreground space-y-1 list-decimal list-inside">
              <li>Acesse o Google Chat e entre no espaço desejado</li>
              <li>Clique no nome do espaço → "Gerenciar webhooks"</li>
              <li>Verifique se ja não há um webhook criado</li>
              <li>Caso ja tenha, Copie a URL gerada e cole aqui</li>
              <li>Caso não tenha, clique em "Adicionar Webhook"</li>
              <li>Definida o nome, Copie a URL gerada e cole aqui</li>
            </ol>
          </CardContent>
        </Card>


        <div className="space-y-4">
          <Card className="bg-background/20 border border-border shadow-sm">
            <CardHeader className="pb-2">
              <CardTitle className="text-primary text-lg text-center w-full flex justify-center items-center gap-2">
                Webhooks Cadastrados
              </CardTitle>
            </CardHeader>

            <CardContent className="space-y-3 px-4 pb-4">
              {loadingGroups.length > 0 && (
                <div className="text-center text-xs text-muted-foreground">
                  Carregando grupos: {loadingGroups.join(", ")}
                </div>
              )}

              {Object.keys(webhooksByGroup).length === 0 && loadingGroups.length === 0 && (
                <div className="text-center text-sm text-muted-foreground">
                  Nenhum webhook configurado
                </div>
              )}

              {Object.entries(webhooksByGroup).map(([group, hooks]) => (
                <div
                  key={group}
                  className="flex items-center justify-between bg-background/40 border border-border rounded-md px-3 py-2"
                >
                  <span className="text-sm text-foreground">{group}</span>
                  <span className="text-xs text-muted-foreground">
                    {hooks.length > 0 ? '✔️ Cadastrado' : '—'}
                  </span>
                </div>
              ))}


            </CardContent>
          </Card>

          {/* Seção Webhook de Crise */}
          <Card className="bg-background/30 border-border">
            <CardHeader>
              <CardTitle className="text-sm text-muted-foreground">Webhook de Crise</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <Label htmlFor="crisis-webhook">URL do Webhook de Crise</Label>
                <Input
                  id="crisis-webhook"
                  value={crisisWebhook}
                  onChange={(e) => setCrisisWebhook(e.target.value)}
                  placeholder="https://chat.googleapis.com/v1/spaces/..."
                  className="bg-background border-border"
                  disabled={isSaving}
                />
                <p className="text-xs text-muted-foreground">
                  Esse webhook será usado para notificações específicas de processos de crise.
                </p>
                <Button onClick={saveCrisisWebhook} disabled={isCrisisSaveDisabled} className="mt-2">
                  Salvar Webhook de Crise
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>

        <div className="flex justify-end pt-4">
          <Button
            variant="outline"
            onClick={() => onOpenChange(false)}
            className="border-border hover:bg-hover-bg"
            disabled={isSaving}
          >
            Fechar
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
};

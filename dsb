import { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Trash2, Plus, Webhook, Users, AlertTriangle, CheckCircle2, Clock, ExternalLink, Search, Edit2, Save, X } from 'lucide-react';
import { toast } from '@/hooks/use-toast';

interface WebhookConfigProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

interface WebhookEntry {
  url: string;
  tipo_evento?: string;
  ativo?: boolean;
  criado_por?: string;
  criado_em?: string;
}

// Agora armazenamos os webhooks agrupados por time/grupo:
// { [grupo: string]: WebhookEntry[] }
type WebhooksByGroup = Record<string, WebhookEntry[]>;

const API_BASE = "https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/webhook";

// Busca todos os grupos existentes
async function fetchAllGroups(): Promise<string[]> {
  const res = await fetch(API_BASE, { method: 'GET', headers: { 'Content-Type': 'application/json' } });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error(txt || 'Falha ao carregar grupos');
  }
  const json = await res.json();
  return json.grupos || [];
}

// Busca os webhooks de um grupo específico
async function fetchWebhooksFromApi(grupo: string): Promise<{ grupo_id: string; webhooks: WebhookEntry[] }> {
  const res = await fetch(`${API_BASE}?grupo_id=${encodeURIComponent(grupo)}`, {
    method: 'GET',
    headers: { 'Content-Type': 'application/json' },
  });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error(txt || 'Falha ao carregar webhooks do servidor');
  }
  return res.json();
}

async function addOrUpdateWebhookApi(payload: {
  grupo_id: string;
  url: string;
  tipo_evento?: string;
  usuario: string;
}): Promise<{ message: string; webhooks: WebhookEntry[] }> {
  const res = await fetch(`${API_BASE}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error(txt || 'Erro ao adicionar webhook');
  }
  return res.json();
}

async function removeWebhookApi(payload: {
  grupo_id: string;
  url: string;
  tipo_evento?: string;
}): Promise<{ message: string; webhooks: WebhookEntry[] }> {
  const res = await fetch(`${API_BASE}`, {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error(txt || 'Erro ao remover webhook');
  }
  return res.json();
}

export const WebhookConfig = ({ open, onOpenChange }: WebhookConfigProps) => {
  // webhooks agrupados por grupo/time
  const [webhooksByGroup, setWebhooksByGroup] = useState<WebhooksByGroup>({});
  const [crisisWebhook, setCrisisWebhook] = useState('');
  const [newTeam, setNewTeam] = useState(''); // para novo grupo (time)
  const [newWebhook, setNewWebhook] = useState('');
  const [loadingGroups, setLoadingGroups] = useState<string[]>([]);
  const [isSaving, setIsSaving] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [editingGroup, setEditingGroup] = useState<string | null>(null);
  const [editGroupName, setEditGroupName] = useState('');
  const [editWebhookUrl, setEditWebhookUrl] = useState('');

  // Ao abrir o modal, carregar grupos + webhooks
  useEffect(() => {
    if (!open) return;

    // Limpa dados antigos ao abrir
    setWebhooksByGroup({});

    // Carrega webhook de crise do localStorage
    const savedCrisisWebhook = localStorage.getItem('crisisWebhook');
    if (savedCrisisWebhook) {
      setCrisisWebhook(savedCrisisWebhook);
    }

    const loadAll = async () => {
      try {
        const grupos = await fetchAllGroups();

        if (grupos.length === 0) {
          toast({ title: "Nenhum grupo encontrado", description: "Não existem grupos com webhooks configurados." });
          return;
        }

        // Para cada grupo, buscar os webhooks
        setLoadingGroups(grupos);
        const allWebhooks: WebhooksByGroup = {};
        await Promise.all(
          grupos.map(async (grupo) => {
            try {
              const data = await fetchWebhooksFromApi(grupo);
              allWebhooks[grupo] = data.webhooks.filter(w => w.ativo);
            } catch (err: any) {
              toast({
                title: "Erro ao carregar grupo",
                description: `Falha ao carregar webhooks do grupo ${grupo}: ${err.message}`,
                variant: "destructive",
              });
              allWebhooks[grupo] = [];
            }
          })
        );
        setWebhooksByGroup(allWebhooks);
      } catch (e: any) {
        toast({
          title: "Erro ao carregar grupos",
          description: e.message || "Falha ao carregar grupos",
          variant: "destructive",
        });
      } finally {
        setLoadingGroups([]);
      }
    };

    loadAll();
  }, [open]);

  // Adiciona ou atualiza um webhook em um grupo específico
  const addWebhook = async () => {
    if (!newTeam.trim() || !newWebhook.trim()) {
      toast({
        title: "Campos obrigatórios",
        description: "Preencha o nome da equipe e a URL do webhook",
        variant: "destructive",
      });
      return;
    }

    if (!newWebhook.startsWith('https://chat.googleapis.com/')) {
      toast({
        title: "URL inválida",
        description: "A URL deve ser um webhook válido do Google Chat",
        variant: "destructive",
      });
      return;
    }

    const teamKey = newTeam.trim();
    const webhookUrl = newWebhook.trim();

    // Otimista
    const optimistic = {
      ...webhooksByGroup,
      [teamKey]: [...(webhooksByGroup[teamKey] || []), { url: webhookUrl, ativo: true }],
    };
    setWebhooksByGroup(optimistic);

    setNewTeam('');
    setNewWebhook('');

    toast({
      title: "Salvando...",
      description: `Tentando adicionar webhook para ${teamKey}`,
    });

    try {
      setIsSaving(true);
      const result = await addOrUpdateWebhookApi({
        grupo_id: teamKey,
        url: webhookUrl,
        tipo_evento: 'default',
        usuario: 'admin',
      });

      // Atualiza webhooks do grupo com retorno da API
      setWebhooksByGroup(prev => ({
        ...prev,
        [teamKey]: result.webhooks.filter(w => w.ativo),
      }));

      toast({
        title: "Webhook adicionado",
        description: `Webhook configurado para a equipe ${teamKey}`,
      });
    } catch (e: any) {
      // Rollback
      setWebhooksByGroup(prev => {
        const filtered = (prev[teamKey] || []).filter(w => w.url !== webhookUrl);
        return { ...prev, [teamKey]: filtered };
      });
      toast({
        title: "Erro",
        description: e.message || "Falha ao adicionar webhook",
        variant: "destructive",
      });
    } finally {
      setIsSaving(false);
    }
  };

  // Remove um webhook do grupo
  const removeWebhook = async (team: string, url: string) => {
    const groupWebhooks = webhooksByGroup[team] || [];
    if (!groupWebhooks.find(w => w.url === url)) return;

    // Otimista
    setWebhooksByGroup(prev => ({
      ...prev,
      [team]: prev[team].filter(w => w.url !== url),
    }));

    try {
      setIsSaving(true);
      await removeWebhookApi({
        grupo_id: team,
        url,
        tipo_evento: 'default',
      });
      toast({
        title: "Webhook removido",
        description: `Webhook da equipe ${team} foi removido`,
      });
    } catch (e: any) {
      // Rollback
      setWebhooksByGroup(prev => ({
        ...prev,
        [team]: [...prev[team], { url, ativo: true }],
      }));
      toast({
        title: "Erro",
        description: e.message || "Falha ao remover webhook",
        variant: "destructive",
      });
    } finally {
      setIsSaving(false);
    }
  };

  // Editar webhook
  const startEditingGroup = (group: string, currentUrl: string) => {
    setEditingGroup(group);
    setEditGroupName(group);
    setEditWebhookUrl(currentUrl);
  };

  const cancelEditing = () => {
    setEditingGroup(null);
    setEditGroupName('');
    setEditWebhookUrl('');
  };

  const saveEditedWebhook = async () => {
    if (!editGroupName.trim() || !editWebhookUrl.trim()) {
      toast({
        title: "Campos obrigatórios",
        description: "Preencha o nome da equipe e a URL do webhook",
        variant: "destructive",
      });
      return;
    }

    if (!editWebhookUrl.startsWith('https://chat.googleapis.com/')) {
      toast({
        title: "URL inválida",
        description: "A URL deve ser um webhook válido do Google Chat",
        variant: "destructive",
      });
      return;
    }

    const oldGroup = editingGroup!;
    const newGroup = editGroupName.trim();
    const newUrl = editWebhookUrl.trim();
    const oldUrl = webhooksByGroup[oldGroup]?.[0]?.url;

    try {
      setIsSaving(true);

      // Se mudou o nome do grupo, precisamos remover o antigo e adicionar o novo
      if (oldGroup !== newGroup && oldUrl) {
        await removeWebhookApi({
          grupo_id: oldGroup,
          url: oldUrl,
          tipo_evento: 'default',
        });
      }

      // Adiciona/atualiza o webhook
      const result = await addOrUpdateWebhookApi({
        grupo_id: newGroup,
        url: newUrl,
        tipo_evento: 'default',
        usuario: 'admin',
      });

      // Atualiza o estado local
      setWebhooksByGroup(prev => {
        const newState = { ...prev };
        
        // Remove o grupo antigo se necessário
        if (oldGroup !== newGroup) {
          delete newState[oldGroup];
        }
        
        // Adiciona/atualiza o novo grupo
        newState[newGroup] = result.webhooks.filter(w => w.ativo);
        
        return newState;
      });

      toast({
        title: "Webhook atualizado",
        description: `Webhook da equipe ${newGroup} foi atualizado com sucesso`,
      });

      cancelEditing();
    } catch (e: any) {
      toast({
        title: "Erro",
        description: e.message || "Falha ao atualizar webhook",
        variant: "destructive",
      });
    } finally {
      setIsSaving(false);
    }
  };

  // Filtrar webhooks baseado na pesquisa
  const filteredWebhooks = Object.entries(webhooksByGroup).filter(([group]) =>
    group.toLowerCase().includes(searchTerm.toLowerCase())
  );

  // Save Crisis Webhook remains as your original code (no changes)
  const saveCrisisWebhook = async () => {
    const urlTrimmed = crisisWebhook.trim();

    if (!urlTrimmed) {
      toast({ title: "Campo vazio", description: "Informe a URL do webhook de crise", variant: "destructive" });
      return;
    }
    if (!urlTrimmed.startsWith('https://chat.googleapis.com/')) {
      toast({ title: "URL inválida", description: "Use um webhook válido do Google Chat", variant: "destructive" });
      return;
    }

    // Se a URL atual é igual a já salva, não salvar de novo
    if (urlTrimmed === localStorage.getItem('crisisWebhook')) {
      toast({ title: "Sem alterações", description: "A URL do webhook de crise não foi modificada.", variant: "default" });
      return;
    }

    try {
      setIsSaving(true);
      await addOrUpdateWebhookApi({
        grupo_id: 'crise',
        url: urlTrimmed,
        tipo_evento: 'crise',
        usuario: 'admin',
      });
      localStorage.setItem('crisisWebhook', urlTrimmed);
      setCrisisWebhook(urlTrimmed);
      toast({ title: "Webhook de crise salvo", description: "Configuração salva com sucesso" });
    } catch (e: any) {
      toast({ title: "Erro", description: e.message || "Falha ao salvar webhook de crise", variant: "destructive" });
    } finally {
      setIsSaving(false);
    }
  };

  const isCrisisSaveDisabled =
    isSaving ||
    !crisisWebhook.trim() ||
    crisisWebhook.trim() === localStorage.getItem('crisisWebhook');

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="webhook-glass w-[95vw] max-w-[800px] mx-auto min-h-[60vh] max-h-[90vh] overflow-y-auto py-8 px-6 animate-scale-in">
        <DialogHeader className="space-y-4 mb-6">
          <DialogTitle className="text-foreground text-3xl font-bold text-center flex justify-center items-center gap-3">
            <div className="p-3 rounded-2xl webhook-button-primary">
              <Webhook className="h-6 w-6" />
            </div>
            Configuração de Webhooks
          </DialogTitle>
          <p className="text-muted-foreground text-center max-w-md mx-auto">
            Configure e gerencie os webhooks do Google Chat para suas equipes
          </p>
        </DialogHeader>

        <div className="space-y-8">
          {/* Adicionar novo webhook */}
          <Card className="webhook-card animate-slide-up" style={{ animationDelay: '0.1s' }}>
            <CardHeader className="pb-4">
              <CardTitle className="text-xl font-semibold text-foreground flex items-center gap-2">
                <Users className="h-5 w-5 text-primary" />
                Cadastrar Novo Webhook
              </CardTitle>
              <p className="text-sm text-muted-foreground">
                Adicione um novo webhook para uma equipe específica
              </p>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="grid md:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="team-name" className="text-sm font-medium text-foreground">Nome da Equipe</Label>
                  <Input
                    id="team-name"
                    value={newTeam}
                    onChange={(e) => setNewTeam(e.target.value)}
                    placeholder="Ex: NOC, SOC, Infraestrutura"
                    className="webhook-input"
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="webhook-url" className="text-sm font-medium text-foreground">URL do Webhook</Label>
                  <Input
                    id="webhook-url"
                    value={newWebhook}
                    onChange={(e) => setNewWebhook(e.target.value)}
                    placeholder="https://chat.googleapis.com/v1/spaces/..."
                    className="webhook-input"
                  />
                </div>
              </div>
              <Button
                onClick={addWebhook}
                className="w-full webhook-button-primary"
                disabled={isSaving || !newTeam.trim() || !newWebhook.trim()}
                size="lg"
              >
                <Plus className="h-5 w-5 mr-2" />
                {isSaving ? 'Salvando...' : 'Adicionar Webhook'}
              </Button>
            </CardContent>
          </Card>

          {/* Seção explicativa */}
          <Card className="webhook-card animate-slide-up" style={{ animationDelay: '0.2s' }}>
            <CardHeader className="pb-4">
              <CardTitle className="text-lg font-semibold text-foreground flex items-center gap-2">
                <ExternalLink className="h-5 w-5 text-primary" />
                Como obter um Webhook do Google Chat
              </CardTitle>
            </CardHeader>
            <CardContent>
              <ol className="space-y-3 text-sm text-muted-foreground">
                <li className="flex items-start gap-3">
                  <span className="flex-shrink-0 w-6 h-6 bg-primary/20 text-primary rounded-full flex items-center justify-center text-xs font-semibold">1</span>
                  Acesse o Google Chat e entre no espaço desejado
                </li>
                <li className="flex items-start gap-3">
                  <span className="flex-shrink-0 w-6 h-6 bg-primary/20 text-primary rounded-full flex items-center justify-center text-xs font-semibold">2</span>
                  Clique no nome do espaço → "Gerenciar webhooks"
                </li>
                <li className="flex items-start gap-3">
                  <span className="flex-shrink-0 w-6 h-6 bg-primary/20 text-primary rounded-full flex items-center justify-center text-xs font-semibold">3</span>
                  Verifique se já existe um webhook criado
                </li>
                <li className="flex items-start gap-3">
                  <span className="flex-shrink-0 w-6 h-6 bg-primary/20 text-primary rounded-full flex items-center justify-center text-xs font-semibold">4</span>
                  Se já existir, copie a URL. Caso contrário, clique em "Adicionar Webhook"
                </li>
                <li className="flex items-start gap-3">
                  <span className="flex-shrink-0 w-6 h-6 bg-primary/20 text-primary rounded-full flex items-center justify-center text-xs font-semibold">5</span>
                  Defina o nome, copie a URL gerada e cole aqui
                </li>
              </ol>
            </CardContent>
          </Card>

          {/* Webhooks Cadastrados */}
          <Card className="webhook-card animate-slide-up" style={{ animationDelay: '0.3s' }}>
            <CardHeader className="pb-2">
              <CardTitle className="text-lg font-semibold text-foreground flex items-center gap-2">
                <CheckCircle2 className="h-4 w-4 text-primary" />
                Webhooks ({Object.keys(webhooksByGroup).length})
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              {/* Barra de pesquisa */}
              {Object.keys(webhooksByGroup).length > 0 && (
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="Pesquisar equipes..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="pl-10 webhook-input"
                  />
                </div>
              )}

              {loadingGroups.length > 0 && (
                <div className="flex items-center justify-center py-4 text-muted-foreground text-sm">
                  <Clock className="h-4 w-4 mr-2 animate-spin" />
                  Carregando...
                </div>
              )}

              {Object.keys(webhooksByGroup).length === 0 && loadingGroups.length === 0 && (
                <div className="text-center py-6">
                  <div className="w-12 h-12 mx-auto mb-2 rounded-full bg-muted/20 flex items-center justify-center">
                    <Webhook className="h-6 w-6 text-muted-foreground" />
                  </div>
                  <p className="text-muted-foreground text-sm">Nenhum webhook configurado</p>
                </div>
              )}

              {filteredWebhooks.length === 0 && searchTerm && Object.keys(webhooksByGroup).length > 0 && (
                <div className="text-center py-6">
                  <Search className="h-8 w-8 mx-auto mb-2 text-muted-foreground" />
                  <p className="text-muted-foreground text-sm">Nenhum resultado encontrado para "{searchTerm}"</p>
                </div>
              )}

              <div className="max-h-48 overflow-y-auto space-y-1">
                {filteredWebhooks.map(([group, hooks], index) => (
                  <div
                    key={group}
                    className="flex items-center justify-between p-2 rounded-lg border border-border/30 bg-background/30 hover:bg-background/50 transition-all duration-200 group"
                  >
                    {editingGroup === group ? (
                      // Modo de edição
                      <div className="flex-1 space-y-2">
                        <Input
                          value={editGroupName}
                          onChange={(e) => setEditGroupName(e.target.value)}
                          placeholder="Nome da equipe"
                          className="text-sm webhook-input"
                        />
                        <Input
                          value={editWebhookUrl}
                          onChange={(e) => setEditWebhookUrl(e.target.value)}
                          placeholder="URL do webhook"
                          className="text-sm webhook-input"
                        />
                        <div className="flex gap-1">
                          <Button
                            onClick={saveEditedWebhook}
                            size="sm"
                            className="h-6 px-2 text-xs"
                            disabled={isSaving}
                          >
                            <Save className="h-3 w-3 mr-1" />
                            Salvar
                          </Button>
                          <Button
                            onClick={cancelEditing}
                            variant="outline"
                            size="sm"
                            className="h-6 px-2 text-xs"
                            disabled={isSaving}
                          >
                            <X className="h-3 w-3 mr-1" />
                            Cancelar
                          </Button>
                        </div>
                      </div>
                    ) : (
                      // Modo de visualização
                      <>
                        <div className="flex items-center gap-2 min-w-0">
                          <div className="p-1 rounded bg-primary/10">
                            <Users className="h-3 w-3 text-primary" />
                          </div>
                          <div className="min-w-0">
                            <span className="text-sm font-medium text-foreground truncate block">{group}</span>
                          </div>
                        </div>
                        <div className="flex items-center gap-1 flex-shrink-0">
                          {hooks.length > 0 ? (
                            <span className="text-xs px-2 py-1 rounded-full bg-green-500/10 text-green-600 border border-green-500/20">
                              ✓
                            </span>
                          ) : (
                            <span className="text-xs px-2 py-1 rounded-full bg-muted/20 text-muted-foreground">
                              —
                            </span>
                          )}
                          {hooks.length > 0 && (
                            <>
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => startEditingGroup(group, hooks[0].url)}
                                className="opacity-0 group-hover:opacity-100 transition-opacity h-6 w-6 p-0 hover:bg-primary/10 hover:text-primary"
                                disabled={isSaving}
                              >
                                <Edit2 className="h-3 w-3" />
                              </Button>
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => removeWebhook(group, hooks[0].url)}
                                className="opacity-0 group-hover:opacity-100 transition-opacity h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                                disabled={isSaving}
                              >
                                <Trash2 className="h-3 w-3" />
                              </Button>
                            </>
                          )}
                        </div>
                      </>
                    )}
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>

          {/* Webhook de Crise */}
          <Card className="webhook-card border-destructive/20 animate-slide-up" style={{ animationDelay: '0.4s' }}>
            <CardHeader className="pb-4">
              <CardTitle className="text-lg font-semibold text-foreground flex items-center gap-2">
                <AlertTriangle className="h-5 w-5 text-destructive" />
                Webhook de Crise
              </CardTitle>
              <p className="text-sm text-muted-foreground">
                Webhook especial para notificações críticas e situações de emergência
              </p>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="crisis-webhook" className="text-sm font-medium text-foreground">URL do Webhook de Crise</Label>
                <Input
                  id="crisis-webhook"
                  value={crisisWebhook}
                  onChange={(e) => setCrisisWebhook(e.target.value)}
                  placeholder="https://chat.googleapis.com/v1/spaces/..."
                  className="webhook-input"
                  disabled={isSaving}
                />
              </div>
              <div className="flex items-start gap-2 p-3 rounded-lg bg-destructive/5 border border-destructive/20">
                <AlertTriangle className="h-4 w-4 text-destructive mt-0.5 flex-shrink-0" />
                <p className="text-xs text-muted-foreground">
                  <strong>Importante:</strong> Este webhook será usado exclusivamente para notificações de processos críticos e situações de emergência.
                </p>
              </div>
              <Button 
                onClick={saveCrisisWebhook} 
                disabled={isCrisisSaveDisabled} 
                className="w-full"
                variant="destructive"
                size="lg"
              >
                {isSaving ? 'Salvando...' : 'Salvar Webhook de Crise'}
              </Button>
            </CardContent>
          </Card>
        </div>

        <div className="flex justify-end pt-6 mt-8 border-t border-border/30">
          <Button
            variant="outline"
            onClick={() => onOpenChange(false)}
            className="webhook-button-secondary px-8"
            disabled={isSaving}
            size="lg"
          >
            Fechar
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
};

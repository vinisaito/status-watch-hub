import os
import json
from datetime import datetime
import boto3
import pyodbc  # Conex√£o com SQL Server
from decimal import Decimal

# ---------- Configura√ß√µes ----------
SQL_SERVER = os.environ.get("DB_HOST")
SQL_PORT = os.environ.get("DB_PORT", "1433")
SQL_USERNAME = os.environ.get("DB_USER")
SQL_PASSWORD = os.environ.get("DB_PASSWORD")
DYNAMO_TABLE = os.environ.get("DYNAMO_CHAMADOS_TABLE")

# ---------- Conex√µes AWS ----------
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table(DYNAMO_TABLE)

# ---------- Headers CORS ----------
cors_headers = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type",
    "Content-Type": "application/json; charset=utf-8",
}

# ---------- Utilidades ----------
def _sql_conn_str() -> str:
    """Monta a connection string ODBC para SQL Server."""
    return (
        f"DRIVER={{ODBC Driver 18 for SQL Server}};"
        f"SERVER={SQL_SERVER},{SQL_PORT};"
        f"UID={SQL_USERNAME};"
        f"PWD={SQL_PASSWORD};"
        f"Encrypt=yes;"
        f"TrustServerCertificate=yes;"
        f"CHARSET=UTF8;"
    )

def _rows_to_dicts(cursor, rows):
    """Converte resultado do SQL em lista de dicion√°rios."""
    columns = [col[0] for col in cursor.description]
    results = []
    for row in rows:
        item = dict(zip(columns, row))

        # Convers√£o de tipos compat√≠veis com DynamoDB
        for k, v in list(item.items()):
            if isinstance(v, datetime):
                item[k] = v.isoformat()
            elif isinstance(v, float):
                item[k] = Decimal(str(v))
            elif isinstance(v, int):
                item[k] = Decimal(v)

        results.append(item)
    return results

def _convert_decimals(obj):
    """Converte Decimal em int ou float recursivamente para JSON."""
    if isinstance(obj, list):
        return [_convert_decimals(i) for i in obj]
    elif isinstance(obj, dict):
        return {k: _convert_decimals(v) for k, v in obj.items()}
    elif isinstance(obj, Decimal):
        return int(obj) if obj % 1 == 0 else float(obj)
    else:
        return obj

# ---------- DynamoDB ----------
def _save_to_dynamo(items):
    """Registra ou atualiza chamados no DynamoDB com num_chamado como PartitionKey (Number)."""
    if not items:
        print("‚ö†Ô∏è Nenhum item para registrar no DynamoDB.")
        return

    # Se o mesmo num_chamado aparecer mais de uma vez, mant√©m o √∫ltimo
    unicos = {}
    for item in items:
        num = item.get("num_chamado")
        if num is None:
            print(f"‚ö†Ô∏è Item ignorado (sem num_chamado): {item}")
            continue
        unicos[num] = item  # substitui se repetido

    print(f"üß© {len(unicos)} chamados √∫nicos (prontos para upsert no DynamoDB)")

    # batch_writer faz upsert autom√°tico
    with table.batch_writer() as batch:
        for item in unicos.values():
            try:
                # Converte num_chamado explicitamente para Number (Decimal)
                item["num_chamado"] = Decimal(str(int(item["num_chamado"])))

                # Adiciona timestamp de atualiza√ß√£o
                item["updated_at"] = datetime.utcnow().isoformat()

                batch.put_item(Item=item)
            except Exception as e:
                print(f"‚ùå Erro ao gravar item no DynamoDB: {e}")

# ---------- SQL ----------
def fetch_chamados_from_sql_window():
    """Lista chamados direto do SQL (somente leitura) com fallback de janelas."""
    base_select = """
    SELECT [num_chamado]
          ,[equipe]
          ,[gerente_equipe]
          ,[dpto_equipe]
          ,[coord_dpto_equipe]
          ,[ger_dpto_equipe]
          ,[dpto_ger_equipe]
          ,[severidade]
          ,[dat_abertura]
          ,[dat_status_concluido]
          ,[dat_fechamento]
          ,[data_normalizacao]
          ,[status]
          ,[classificacao]
          ,[dat_estouro_sla]
          ,[num_duracao]
          ,[duracao_sla]
          ,[titulo]
          ,[sla_violado]
      FROM [mdb_rep].[dbo].[sdm_cr_geral_mcs]
    """

    filtro_cls_sev = """
      AND (
             (classificacao = 'Incidente' AND severidade IN ('3 - M√©dia', '4 - Alta', '5 - Cr√≠tica'))
          OR (classificacao = 'Solicita√ß√£o' AND severidade = '4 - Alta')
      )
    """

    janelas = [
        ("HOUR", -2, True),
        ("HOUR", -24, True),
        ("DAY", -7, True),
        ("MONTH", -6, True),
        ("MONTH", -6, False),
    ]

    with pyodbc.connect(_sql_conn_str(), timeout=10) as conn:
        cursor = conn.cursor()
        for unidade, delta, aplicar_filtros in janelas:
            where = f"WHERE dat_abertura >= DATEADD({unidade}, {delta}, GETDATE())"
            query = base_select + "\n" + where
            if aplicar_filtros:
                query += "\n" + filtro_cls_sev
            query += "\nORDER BY num_chamado DESC;"

            cursor.execute(query)
            rows = cursor.fetchall()
            if rows:
                return _rows_to_dicts(cursor, rows)

        return []

def fetch_chamado_by_number(numero_chamado: str):
    """Busca um chamado espec√≠fico pelo n√∫mero, direto no SQL."""
    query = """
    SELECT [num_chamado]
          ,[equipe]
          ,[gerente_equipe]
          ,[dpto_equipe]
          ,[coord_dpto_equipe]
          ,[ger_dpto_equipe]
          ,[dpto_ger_equipe]
          ,[severidade]
          ,[dat_abertura]
          ,[dat_status_concluido]
          ,[dat_fechamento]
          ,[data_normalizacao]
          ,[status]
          ,[classificacao]
          ,[dat_estouro_sla]
          ,[num_duracao]
          ,[duracao_sla]
          ,[titulo]
          ,[sla_violado]
      FROM [mdb_rep].[dbo].[sdm_cr_geral_mcs]
      WHERE num_chamado = ?
      ORDER BY num_chamado DESC;
    """

    with pyodbc.connect(_sql_conn_str(), timeout=10) as conn:
        cursor = conn.cursor()
        cursor.execute(query, (numero_chamado,))
        row = cursor.fetchone()
        if not row:
            return None
        return _rows_to_dicts(cursor, [row])[0]

# ---------- Resposta HTTP ----------
def _response(status: int, body_obj):
    body_json = json.dumps(_convert_decimals(body_obj), ensure_ascii=False)
    return {
        "statusCode": status,
        "headers": cors_headers,
        "body": body_json,
    }

# ---------- Lambda Handler ----------
def lambda_handler(event, context):
    """
    API somente leitura:
      - GET /?numero_chamado=123   -> retorna um chamado espec√≠fico
      - GET /                      -> retorna chamados recentes e grava no DynamoDB
      - OPTIONS                    -> CORS preflight
    """
    method = (event or {}).get("httpMethod", "GET").upper()

    if method == "OPTIONS":
        return _response(204, {})

    if method != "GET":
        return _response(405, {"error": "M√©todo n√£o permitido. Use GET."})

    try:
        params = (event or {}).get("queryStringParameters") or {}
        numero_chamado = params.get("numero_chamado") if isinstance(params, dict) else None

        if numero_chamado:
            item = fetch_chamado_by_number(str(numero_chamado))
            if not item:
                return _response(404, {"error": "Chamado n√£o encontrado"})
            _save_to_dynamo([item])
            return _response(200, item)
        else:
            items = fetch_chamados_from_sql_window()
            _save_to_dynamo(items)
            return _response(200, items)

    except Exception as e:
        print(f"‚ùå Erro geral: {e}")
        return _response(500, {"error": str(e)})

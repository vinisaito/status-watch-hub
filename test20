import os
import json
import boto3
from datetime import datetime
import pyodbc  # para conectar ao SQL Server

# DynamoDB
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table("painelciops_acompanhamentordms")

# Configurações do SQL Server (vêm de variáveis de ambiente)
SQL_SERVER = os.environ.get("DB_HOST")
SQL_PORT = os.environ.get("DB_PORT", "1433")
SQL_USERNAME = os.environ.get("DB_USER")
SQL_PASSWORD = os.environ.get("DB_PASSWORD")

def fetch_rdms_from_sql():
    conn_str = (
        f"DRIVER={{ODBC Driver 18 for SQL Server}};"
        f"SERVER={SQL_SERVER},{SQL_PORT};"
        f"UID={SQL_USERNAME};"
        f"PWD={SQL_PASSWORD};"
        f"Encrypt=yes;"
        f"TrustServerCertificate=yes;"
        f"CHARSET=UTF8;"
    )

    with pyodbc.connect(conn_str, timeout=10) as conn:
        cursor = conn.cursor()
        query = """
        SET NOCOUNT ON;

        SELECT 
            filtro.numero_rdm,
            filtro.tipo_rdm,
            filtro.status_rdm,
            filtro.descricao_rdm_user,
            filtro.ambiente,
            filtro.data_inicio_programacao,
            filtro.data_fim_programacao,
            filtro.[duração da Programação],
            filtro.grupo_executor,
            filtro.executor,
            filtro.area_principal_afetada,
            filtro.impacto,
            filtro.risco,
            filtro.requisitante,
            filtro.[gerente requisitante],
            filtro.depto_gerencia_requisitante,
            filtro.origem,
            filtro.warroom_preventivo,
            filtro.ic_rdm
        FROM (
            SELECT 
                mcs.*,
                ROW_NUMBER() OVER (PARTITION BY mcs.numero_rdm ORDER BY mcs.data_inicio_programacao ASC) AS rn
            FROM [mdb_rep].[dbo].[aDS_view_mudancas_mcs] AS mcs
            JOIN [mdb_rep].[dbo].[aDS_hierarquia_grupos] AS hierarquia
                ON mcs.grupo_executor = hierarquia.grupo
            WHERE 
                mcs.tipo_rdm = 'Urgente'
                AND mcs.status_rdm NOT IN ('Cancelada', 'Fechada')
                AND mcs.data_inicio_programacao >= CONVERT(DATE, GETDATE())
                AND mcs.data_inicio_programacao < DATEADD(DAY, 4, CONVERT(DATE, GETDATE()))
                AND hierarquia.grupo_status = 'Ativo'
                AND hierarquia.gerente IN ('Carlos Eduardo Sanches', 'Rodrigo Veronezze')
        ) AS filtro
        WHERE filtro.rn = 1
        ORDER BY filtro.data_inicio_programacao ASC;
        """
        cursor.execute(query)
        columns = [col[0] for col in cursor.description]
        rows = cursor.fetchall()
        rdms = [dict(zip(columns, row)) for row in rows]

        # Converte datetimes para string
        for rdm in rdms:
            for key, value in rdm.items():
                if isinstance(value, datetime):
                    rdm[key] = value.isoformat()

        return rdms

def lambda_handler(event, context):
    http_method = event.get("httpMethod", "GET")

    if http_method == "POST":
        # Atualiza apenas o status de acompanhamento de uma RDM
        try:
            body = json.loads(event.get("body", "{}"))
            numero_rdm = body["numero_rdm"]
            status = body.get("status_acompanhamento", "Não iniciado")

            table.update_item(
                Key={"numero_rdm": numero_rdm},
                UpdateExpression="SET status_acompanhamento = :s, updated_at = :u",
                ExpressionAttributeValues={
                    ":s": status,
                    ":u": datetime.utcnow().isoformat()
                }
            )

            return {
                "statusCode": 200,
                "headers": {
                    "Access-Control-Allow-Origin": "*",
                    "Content-Type": "application/json; charset=utf-8"
                },
                "body": json.dumps({"message": "Status de acompanhamento atualizado"}, ensure_ascii=False)
            }

        except Exception as e:
            return {
                "statusCode": 500,
                "headers": {
                    "Access-Control-Allow-Origin": "*",
                    "Content-Type": "application/json; charset=utf-8"
                },
                "body": json.dumps({"error": str(e)}, ensure_ascii=False)
            }

    elif http_method == "GET":
        params = event.get("queryStringParameters", {}) or {}
        numero_rdm = params.get("numero_rdm")
        if numero_rdm:
            # Busca uma RDM específica
            try:
                conn_str = (
                    f"DRIVER={{ODBC Driver 18 for SQL Server}};"
                    f"SERVER={SQL_SERVER},{SQL_PORT};"
                    f"UID={SQL_USERNAME};"
                    f"PWD={SQL_PASSWORD};"
                    f"Encrypt=yes;"
                    f"TrustServerCertificate=yes;"
                    f"CHARSET=UTF8;"
                )
                with pyodbc.connect(conn_str, timeout=10) as conn:
                    cursor = conn.cursor()
                    query = """
                    SELECT [num_chamado]
      ,[equipe]
      ,[gerente_equipe]
      ,[dpto_equipe]
      ,[coord_dpto_equipe]
      ,[ger_dpto_equipe]
      ,[dpto_ger_equipe]
      ,[severidade]
      ,[dat_abertura]
      ,[dat_status_concluido]
      ,[dat_fechamento]
      ,[data_normalizacao]
      ,[status]
      ,[classificacao]
      ,[dat_estouro_sla]
      ,[num_duracao]
      ,[duracao_sla]
      ,[titulo]
      ,[sla_violado]
  FROM [mdb_rep].[dbo].[sdm_cr_geral_mcs]
  WHERE dat_abertura >= DATEADD(MONTH, -6, GETDATE())
  	AND (
		 (classificacao = 'Incidente' AND severidade IN ('3 - Média', '4 - Alta', '5 - Crítica'))
		OR (classificacao = 'Solicitação' AND severidade = '4 - Alta')
		)
  ORDER BY num_chamado DESC;
                    """
                    cursor.execute(query, numero_rdm)
                    columns = [col[0] for col in cursor.description]
                    row = cursor.fetchone()
                    if row:
                        rdm = dict(zip(columns, row))
                        for key, value in rdm.items():
                            if isinstance(value, datetime):
                                rdm[key] = value.isoformat()
                        # Adiciona status do DynamoDB se existir
                        existing_item = table.get_item(Key={"numero_rdm": numero_rdm}).get("Item", {})
                        rdm["status_acompanhamento"] = existing_item.get("status_acompanhamento", "Não iniciado")
                        return {
                            "statusCode": 200,
                            "headers": {
                                "Access-Control-Allow-Origin": "*",
                                "Content-Type": "application/json; charset=utf-8"
                            },
                            "body": json.dumps(rdm, ensure_ascii=False)
                        }
                    else:
                        return {
                            "statusCode": 404,
                            "headers": {
                                "Access-Control-Allow-Origin": "*",
                                "Content-Type": "application/json; charset=utf-8"
                            },
                            "body": json.dumps({"error": "RDM não encontrada"}, ensure_ascii=False)
                        }
            except Exception as e:
                return {
                    "statusCode": 500,
                    "headers": {
                        "Access-Control-Allow-Origin": "*",
                        "Content-Type": "application/json; charset=utf-8"
                    },
                    "body": json.dumps({"error": str(e)}, ensure_ascii=False)
                }
        else:
            # Busca RDMs do SQL Server e atualiza DynamoDB
            try:
                rdms = fetch_rdms_from_sql()

                for rdm in rdms:
                    numero_rdm = rdm["numero_rdm"]
                    # Tenta manter status_acompanhamento existente
                    existing_item = table.get_item(Key={"numero_rdm": numero_rdm}).get("Item", {})
                    status_acomp = existing_item.get("status_acompanhamento", "Não iniciado")

                    rdm["status_acompanhamento"] = status_acomp
                    rdm["updated_at"] = datetime.utcnow().isoformat()

                    table.put_item(Item=rdm)

                return {
                    "statusCode": 200,
                    "headers": {
                        "Access-Control-Allow-Origin": "*",
                        "Content-Type": "application/json; charset=utf-8"
                    },
                    "body": json.dumps(rdms, ensure_ascii=False)
                }

            except Exception as e:
                return {
                    "statusCode": 500,
                    "headers": {
                        "Access-Control-Allow-Origin": "*",
                        "Content-Type": "application/json; charset=utf-8"
                    },
                    "body": json.dumps({"error": str(e)}, ensure_ascii=False)
                }

    else:
        return {
            "statusCode": 405,
            "headers": {
                "Access-Control-Allow-Origin": "*",
                "Content-Type": "application/json; charset=utf-8"
            },
            "body": json.dumps({"error": "Método não permitido"}, ensure_ascii=False)
        }

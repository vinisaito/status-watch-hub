import json
import boto3
import os
import uuid
from datetime import datetime, timezone
from decimal import Decimal

# ---------- Config ----------
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table(os.environ["CHAMADOS_TABLE"])  # Tabela principal (chamados)
conn_table = dynamodb.Table(os.environ["CONNECTIONS_TABLE"])  # Tabela de conexões
apigw = boto3.client(
    "apigatewaymanagementapi",
    endpoint_url=f"https://{os.environ['WS_API_ID']}.execute-api.{os.environ['AWS_REGION']}.amazonaws.com/{os.environ['WS_STAGE']}"
)


# ---------- Helpers ----------
class DecimalEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, Decimal):
            return int(o) if o % 1 == 0 else float(o)
        return super().default(o)

def log(trace, msg, **kwargs):
    print(json.dumps({"trace": trace, "msg": msg, **kwargs}, cls=DecimalEncoder, default=str))

def send_to_connection(conn_id, data):
    try:
        apigw.post_to_connection(
            ConnectionId=conn_id,
            Data=json.dumps(data, cls=DecimalEncoder).encode("utf-8")
        )
    except apigw.exceptions.GoneException:
        conn_table.delete_item(Key={"connectionId": conn_id})
        log("broadcast", "Conexão removida (GoneException)", connectionId=conn_id)

def broadcast(data):
    conns = conn_table.scan().get("Items", [])
    for c in conns:
        send_to_connection(c["connectionId"], data)

def update_chamado(trace, chamado, update):
    log(trace, "Atualizando chamado", chamado=chamado, update=update)
    table.update_item(
        Key={"chamado": chamado},
        UpdateExpression="SET " + ", ".join(f"#{k} = :{k}" for k in update.keys()),
        ExpressionAttributeNames={f"#{k}": k for k in update.keys()},
        ExpressionAttributeValues={f":{k}": v for k, v in update.items()},
    )
    resp = table.get_item(Key={"chamado": chamado})
    state = resp.get("Item", {})
    log(trace, "Chamado atualizado (state completo)", state=state)
    return state

def _to_int_if_possible(x):
    try:
        if isinstance(x, bool):
            return x
        return int(str(x).strip())
    except Exception:
        return x

def _apply_relationships(body, update):
    if "pai" in body and body["pai"] is not None:
        update["pai"] = _to_int_if_possible(body["pai"])
    if "filhos" in body and body["filhos"] is not None:
        filhos_val = body["filhos"]
        if isinstance(filhos_val, list):
            normalized = [_to_int_if_possible(v) for v in filhos_val]
            seen, dedup = set(), []
            for v in normalized:
                key = (type(v), v)
                if key not in seen:
                    seen.add(key)
                    dedup.append(v)
            update["filhos"] = dedup
        else:
            update["filhos"] = filhos_val


# ---------- NOVA ROTA: updateOutage ----------
def handle_update_outage(event, trace, body):
    """
    Atualiza informações de outage de um chamado.
    Espera os campos:
      - chamado (int)
      - outage_title (str)
      - outage_timestamp (str ou auto)
      - outage_start (str)
      - outage_end (str)
    """
    chamado = int(body["chamado"])
    outage_title = body.get("outage_title")
    outage_timestamp = body.get("outage_timestamp") or datetime.now(timezone.utc).isoformat()
    outage_start = body.get("outage_start")
    outage_end = body.get("outage_end")

    update = {
        "outage_title": outage_title,
        "outage_timestamp": outage_timestamp,
        "outage_start": outage_start,
        "outage_end": outage_end,
    }

    _apply_relationships(body, update)
    state = update_chamado(trace, chamado, update)

    payload = {
        "event": "updateOutage",
        "chamado": chamado,
        "outage_title": outage_title,
        "outage_timestamp": outage_timestamp,
        "outage_start": outage_start,
        "outage_end": outage_end,
        "state": state
    }

    broadcast(payload)
    return {"statusCode": 200, "body": json.dumps(payload, cls=DecimalEncoder)}


# ---------- Handlers já existentes ----------
def handle_connect(event, trace):
    conn_id = event["requestContext"]["connectionId"]
    conn_table.put_item(Item={"connectionId": conn_id, "connectedAt": datetime.now(timezone.utc).isoformat()})
    log(trace, "Novo cliente conectado", connectionId=conn_id)
    return {"statusCode": 200}

def handle_disconnect(event, trace):
    conn_id = event["requestContext"]["connectionId"]
    conn_table.delete_item(Key={"connectionId": conn_id})
    log(trace, "Cliente desconectado", connectionId=conn_id)
    return {"statusCode": 200}


# ---------- Main ----------
def lambda_handler(event, context):
    trace = str(uuid.uuid4())[:8]
    req_ctx = event.get("requestContext", {})
    route = req_ctx.get("routeKey", "UNKNOWN")
    conn_id = req_ctx.get("connectionId", "N/A")

    log(trace, "invoke", routeKey=route, connectionId=conn_id, body=event.get("body"))

    try:
        if route == "$connect":
            return handle_connect(event, trace)
        elif route == "$disconnect":
            return handle_disconnect(event, trace)
        else:
            body = json.loads(event.get("body") or "{}")

            if route == "updateOutage":
                return handle_update_outage(event, trace, body)
            elif route == "startTimer":
                return handle_start_timer(event, trace, body)
            elif route == "updateObservacao":
                return handle_update_observacao(event, trace, body)
            elif route == "updateOperador":
                return handle_update_operador(event, trace, body)
            elif route == "updateStatusFinal":
                return handle_update_status_final(event, trace, body)
            elif route == "updateAcionamento":
                return handle_update_acionamento(event, trace, body)
            elif route == "getState":
                return handle_get_state(event, trace, body)
            else:
                log(trace, "Rota inválida", route=route)
                return {"statusCode": 400, "body": json.dumps({"error": "Invalid route"}, cls=DecimalEncoder)}

    except Exception as e:
        log(trace, "Erro na execução", error=str(e))
        return {"statusCode": 500, "body": json.dumps({"error": str(e)}, cls=DecimalEncoder)}
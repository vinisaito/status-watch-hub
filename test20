import os
import json
from datetime import datetime
import boto3
import pyodbc  # Conexão com SQL Server
from decimal import Decimal

# ---------- Configurações ----------
SQL_SERVER = os.environ.get("DB_HOST")
SQL_PORT = os.environ.get("DB_PORT", "1433")
SQL_USERNAME = os.environ.get("DB_USER")
SQL_PASSWORD = os.environ.get("DB_PASSWORD")
DYNAMO_TABLE = os.environ.get("DYNAMO_CHAMADOS_TABLE")

# ---------- Conexões AWS ----------
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table(DYNAMO_TABLE)


# ---------- Utilidades ----------
def _sql_conn_str() -> str:
    """Monta a connection string ODBC para SQL Server."""
    return (
        f"DRIVER={{ODBC Driver 18 for SQL Server}};"
        f"SERVER={SQL_SERVER},{SQL_PORT};"
        f"UID={SQL_USERNAME};"
        f"PWD={SQL_PASSWORD};"
        f"Encrypt=yes;"
        f"TrustServerCertificate=yes;"
        f"CHARSET=UTF8;"
    )


def _rows_to_dicts(cursor, rows):
    """Converte resultado do SQL em lista de dicionários."""
    columns = [col[0] for col in cursor.description]
    results = []
    for row in rows:
        item = dict(zip(columns, row))
        for k, v in list(item.items()):
            if isinstance(v, datetime):
                item[k] = v.isoformat()
            elif isinstance(v, (float, int)):
                item[k] = Decimal(str(v))  # Compatível com DynamoDB
        results.append(item)
    return results


def _save_to_dynamo(items):
    """Registra os chamados no DynamoDB."""
    if not items:
        print("⚠️ Nenhum item para registrar no DynamoDB.")
        return

    with table.batch_writer() as batch:
        for item in items:
            try:
                # Adiciona timestamp de atualização
                item["updated_at"] = datetime.utcnow().isoformat()
                batch.put_item(Item=item)
            except Exception as e:
                print(f"❌ Erro ao gravar item no DynamoDB: {e}")


# ---------- SQL ----------
def fetch_chamados_from_sql_window():
    """Lista chamados direto do SQL (somente leitura) com fallback de janelas."""

    base_select = """
    SELECT [num_chamado]
          ,[equipe]
          ,[gerente_equipe]
          ,[dpto_equipe]
          ,[coord_dpto_equipe]
          ,[ger_dpto_equipe]
          ,[dpto_ger_equipe]
          ,[severidade]
          ,[dat_abertura]
          ,[dat_status_concluido]
          ,[dat_fechamento]
          ,[data_normalizacao]
          ,[status]
          ,[classificacao]
          ,[dat_estouro_sla]
          ,[num_duracao]
          ,[duracao_sla]
          ,[titulo]
          ,[sla_violado]
      FROM [mdb_rep].[dbo].[sdm_cr_geral_mcs]
    """

    filtro_cls_sev = """
      AND (
             (classificacao = 'Incidente' AND severidade IN ('3 - Média', '4 - Alta', '5 - Crítica'))
          OR (classificacao = 'Solicitação' AND severidade = '4 - Alta')
      )
    """

    janelas = [
        ("HOUR", -2, True),
        ("HOUR", -24, True),
        ("DAY", -7, True),
        ("MONTH", -6, True),
        ("MONTH", -6, False),
    ]

    with pyodbc.connect(_sql_conn_str(), timeout=10) as conn:
        cursor = conn.cursor()
        for unidade, delta, aplicar_filtros in janelas:
            where = f"WHERE dat_abertura >= DATEADD({unidade}, {delta}, GETDATE())"
            query = base_select + "\n" + where
            if aplicar_filtros:
                query += "\n" + filtro_cls_sev
            query += "\nORDER BY num_chamado DESC;"

            cursor.execute(query)
            rows = cursor.fetchall()
            if rows:
                return _rows_to_dicts(cursor, rows)

        return []


def fetch_chamado_by_number(numero_chamado: str):
    """Busca um chamado específico pelo número, direto no SQL."""
    query = """
    SELECT [num_chamado]
          ,[equipe]
          ,[gerente_equipe]
          ,[dpto_equipe]
          ,[coord_dpto_equipe]
          ,[ger_dpto_equipe]
          ,[dpto_ger_equipe]
          ,[severidade]
          ,[dat_abertura]
          ,[dat_status_concluido]
          ,[dat_fechamento]
          ,[data_normalizacao]
          ,[status]
          ,[classificacao]
          ,[dat_estouro_sla]
          ,[num_duracao]
          ,[duracao_sla]
          ,[titulo]
          ,[sla_violado]
      FROM [mdb_rep].[dbo].[sdm_cr_geral_mcs]
      WHERE num_chamado = ?
      ORDER BY num_chamado DESC;
    """

    with pyodbc.connect(_sql_conn_str(), timeout=10) as conn:
        cursor = conn.cursor()
        cursor.execute(query, (numero_chamado,))
        row = cursor.fetchone()
        if not row:
            return None
        return _rows_to_dicts(cursor, [row])[0]


# ---------- Resposta HTTP ----------
def _response(status: int, body_obj):
    return {
        "statusCode": status,
        "headers": {
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET,OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type",
            "Content-Type": "application/json; charset=utf-8",
        },
        "body": json.dumps(body_obj, ensure_ascii=False),
    }


# ---------- Lambda Handler ----------
def lambda_handler(event, context):
    """
    API somente leitura:
      - GET /?numero_chamado=123   -> retorna um chamado específico
      - GET /                      -> retorna chamados recentes e grava no DynamoDB
      - OPTIONS                    -> CORS preflight
    """

    method = (event or {}).get("httpMethod", "GET").upper()

    if method == "OPTIONS":
        return _response(204, {})

    if method != "GET":
        return _response(405, {"error": "Método não permitido. Use GET."})

    try:
        params = (event or {}).get("queryStringParameters") or {}
        numero_chamado = params.get("numero_chamado") if isinstance(params, dict) else None

        if numero_chamado:
            item = fetch_chamado_by_number(str(numero_chamado))
            if not item:
                return _response(404, {"error": "Chamado não encontrado"})
            _save_to_dynamo([item])
            return _response(200, item)
        else:
            items = fetch_chamados_from_sql_window()
            _save_to_dynamo(items)
            return _response(200, items)

    except Exception as e:
        print(f"❌ Erro geral: {e}")
        return _response(500, {"error": str(e)})

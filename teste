import json
import boto3
import os
import uuid
from datetime import datetime, timezone
from decimal import Decimal

# ---------- Config ----------
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table(os.environ["CHAMADOS_TABLE"])  # Tabela principal (chamados)
conn_table = dynamodb.Table(os.environ["CONNECTIONS_TABLE"])  # Tabela de conex√µes
apigw = boto3.client(
    "apigatewaymanagementapi",
    endpoint_url=f"https://{os.environ['WS_API_ID']}.execute-api.{os.environ['AWS_REGION']}.amazonaws.com/{os.environ['WS_STAGE']}"
)


# ---------- Helpers ----------
class DecimalEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, Decimal):
            if o % 1 == 0:
                return int(o)
            return float(o)
        return super(DecimalEncoder, self).default(o)

def log(trace, msg, **kwargs):
    print(json.dumps({"trace": trace, "msg": msg, **kwargs}, cls=DecimalEncoder, default=str))

def send_to_connection(conn_id, data):
    """Envia mensagem para uma conex√£o espec√≠fica"""
    try:
        apigw.post_to_connection(
            ConnectionId=conn_id,
            Data=json.dumps(data, cls=DecimalEncoder).encode("utf-8")
        )
    except apigw.exceptions.GoneException:
        # Conex√£o morta -> remover
        conn_table.delete_item(Key={"connectionId": conn_id})
        log("broadcast", "Conex√£o removida (GoneException)", connectionId=conn_id)

def broadcast(data):
    """Envia mensagem para todos conectados"""
    conns = conn_table.scan().get("Items", [])
    for c in conns:
        send_to_connection(c["connectionId"], data)

def update_chamado(trace, chamado, update):
    log(trace, "Atualizando chamado", chamado=chamado, update=update)
    table.update_item(
        Key={"chamado": chamado},
        UpdateExpression="SET " + ", ".join(f"#{k} = :{k}" for k in update.keys()),
        ExpressionAttributeNames={f"#{k}": k for k in update.keys()},
        ExpressionAttributeValues={f":{k}": v for k, v in update.items()},
    )

    # üîë Buscar o estado completo do DynamoDB
    resp = table.get_item(Key={"chamado": chamado})
    state = resp.get("Item", {})
    log(trace, "Chamado atualizado (state completo)", state=state)
    return state

def _to_int_if_possible(x):
    try:
        # Evita converter boolean por engano (True -> 1)
        if isinstance(x, bool):
            return x
        return int(str(x).strip())
    except Exception:
        return x

def _apply_relationships(body, update):
    """
    Injeta 'pai' e 'filhos' no update quando presentes no body.
    - pai: tenta converter para int se poss√≠vel (sen√£o mant√©m como string/valor original)
    - filhos: espera lista; normaliza cada item para int quando poss√≠vel; remove duplicados preservando ordem
    """
    if "pai" in body and body["pai"] is not None:
        update["pai"] = _to_int_if_possible(body["pai"])

    if "filhos" in body and body["filhos"] is not None:
        filhos_val = body["filhos"]
        if isinstance(filhos_val, list):
            normalized = [_to_int_if_possible(v) for v in filhos_val]
            # remove duplicados mantendo ordem
            seen = set()
            dedup = []
            for v in normalized:
                key = (type(v), v)
                if key not in seen:
                    seen.add(key)
                    dedup.append(v)
            update["filhos"] = dedup
        else:
            # Se n√£o vier lista, persiste como veio (ex.: string), mas recomenda-se enviar lista
            update["filhos"] = filhos_val

# ---------- Handlers ----------
def handle_connect(event, trace):
    conn_id = event["requestContext"]["connectionId"]
    conn_table.put_item(Item={"connectionId": conn_id, "connectedAt": datetime.now(timezone.utc).isoformat()})
    log(trace, "Novo cliente conectado", connectionId=conn_id)
    return {"statusCode": 200}

def handle_disconnect(event, trace):
    conn_id = event["requestContext"]["connectionId"]
    conn_table.delete_item(Key={"connectionId": conn_id})
    log(trace, "Cliente desconectado", connectionId=conn_id)
    return {"statusCode": 200}

def handle_start_timer(event, trace, body):
    chamado = int(body["chamado"])
    level = int(body["level"])

    # Se veio duration no body, usa ele. Sen√£o aplica regra por n√≠vel.
    if "duration" in body:
        duration = int(body["duration"])
    else:
        duration = 1200 if level == 1 else 600  # 20 min no n√≠vel 1, sen√£o 10 min

    now = datetime.now(timezone.utc).isoformat()

    update = {
        f"level{level}_timerStart": now,
        f"level{level}_duration": duration,
        f"level{level}_status": "running"
    }
    _apply_relationships(body, update)

    state = update_chamado(trace, chamado, update)

    broadcast({
        "event": "startTimer",
        "chamado": chamado,
        "level": level,
        "state": state
    })

    return {
        "statusCode": 200,
        "body": json.dumps({"msg": f"Timer iniciado ({duration//60} min)"}, cls=DecimalEncoder)
    }

def handle_update_observacao(event, trace, body):
    """Atualiza a observa√ß√£o de um level de um chamado"""
    chamado = int(body["chamado"])
    level = int(body.get("level", 1))
    observacao = body["observacao"]

    update = {f"level{level}_observacao": observacao}
    _apply_relationships(body, update)

    state = update_chamado(trace, chamado, update)

    broadcast({"event": "updateObservacao", "chamado": chamado, "state": state})
    return {"statusCode": 200, "body": json.dumps({"msg": f"Observa√ß√£o do level {level} atualizada"}, cls=DecimalEncoder)}

def handle_update_operador(event, trace, body):
    chamado = int(body["chamado"])
    responsavel = body["ResponsavelAcompanhamento"]
    timestamp_responsavel = datetime.now(timezone.utc).isoformat()

    update = {
        "ResponsavelAcompanhamento": responsavel,
        "timestamp_responsavel": timestamp_responsavel
    }
    _apply_relationships(body, update)

    state = update_chamado(trace, chamado, update)

    payload = {
        "event": "updateOperador",
        "chamado": chamado,
        "ResponsavelAcompanhamento": responsavel,
        "timestamp_responsavel": timestamp_responsavel,
        "state": state
    }
    broadcast(payload)

    return {
        "statusCode": 200,
        "body": json.dumps(payload, cls=DecimalEncoder)
    }

def handle_update_status_final(event, trace, body):
    chamado = int(body["chamado"])
    status = body["status"]
    level_raw = body.get("level")  # opcional
    level = int(level_raw) if level_raw is not None else None
    now = datetime.now(timezone.utc).isoformat()

    # Pega o estado atual do chamado
    resp = table.get_item(Key={"chamado": chamado})
    state_atual = resp.get("Item", {})

    update = {"statusFinal": status, "statusFinal_updatedAt": now}

    if level is not None:
        update[f"level{level}_status"] = status
        update[f"level{level}_updatedAt"] = now
    else:
        for i in range(1, 6):
            if state_atual.get(f"level{i}_status") == "running":
                update[f"level{i}_status"] = status
                update[f"level{i}_updatedAt"] = now
                break

    _apply_relationships(body, update)

    state = update_chamado(trace, chamado, update)
    broadcast({"event": "updateStatusFinal", "chamado": chamado, "state": state})
    return {"statusCode": 200, "body": json.dumps({"msg": "Status final atualizado"}, cls=DecimalEncoder)}

def handle_update_acionamento(event, trace, body):
    chamado = int(body["chamado"])
    level = int(body.get("level", 1))
    now = datetime.now(timezone.utc).isoformat()

    observacao = body.get("observacao")
    pessoa_acionada = body.get("pessoaAcionada")
    status_acionamento = body.get("statusAcionamento")
    operador = body.get("operador")

    update = {f"level{level}_updatedAt": now}  # sempre marca o hor√°rio da altera√ß√£o

    if observacao is not None:
        update[f"level{level}_observacao"] = observacao
    if pessoa_acionada is not None:
        update[f"level{level}_pessoaAcionada"] = pessoa_acionada
    if status_acionamento is not None:
        update[f"level{level}_statusAcionamento"] = status_acionamento
    if operador is not None:
        update[f"level{level}_operador"] = operador

    _apply_relationships(body, update)

    state = update_chamado(trace, chamado, update)

    broadcast({
        "event": "updateAcionamento",
        "chamado": chamado,
        "level": level,
        "state": state
    })
    return {"statusCode": 200, "body": json.dumps({"msg": f"Dados do acionamento do level {level} atualizados"}, cls=DecimalEncoder)}

def handle_get_state(event, trace, body):
    chamado = int(body["chamado"])
    resp = table.get_item(Key={"chamado": chamado})
    state = resp.get("Item", {})
    log(trace, "Estado retornado", chamado=chamado, state=state)

    # Enviar resposta padronizada s√≥ para o cliente que pediu
    conn_id = event["requestContext"]["connectionId"]
    payload = {"event": "getState", "chamado": chamado, "state": state}
    send_to_connection(conn_id, payload)
    return {"statusCode": 200, "body": json.dumps({"msg": "Estado enviado"}, cls=DecimalEncoder)}

# ---------- Main ----------
def lambda_handler(event, context):
    trace = str(uuid.uuid4())[:8]
    req_ctx = event.get("requestContext", {})
    route = req_ctx.get("routeKey", "UNKNOWN")
    conn_id = req_ctx.get("connectionId", "N/A")

    log(trace, "invoke", routeKey=route, connectionId=conn_id, body=event.get("body"))

    try:
        if route == "$connect":
            return handle_connect(event, trace)
        elif route == "$disconnect":
            return handle_disconnect(event, trace)
        else:
            body = json.loads(event.get("body") or "{}")
            if route == "startTimer":
                return handle_start_timer(event, trace, body)
            elif route == "updateObservacao":
                return handle_update_observacao(event, trace, body)
            elif route == "updateOperador":
                return handle_update_operador(event, trace, body)
            elif route == "updateStatusFinal":
                return handle_update_status_final(event, trace, body)
            elif route == "updateAcionamento":
                return handle_update_acionamento(event, trace, body)
            elif route == "getState":
                return handle_get_state(event, trace, body)
            else:
                log(trace, "Rota inv√°lida", route=route)
                return {"statusCode": 400, "body": json.dumps({"error": "Invalid route"}, cls=DecimalEncoder)}
    except Exception as e:
        log(trace, "Erro na execu√ß√£o", error=str(e))
        return {"statusCode": 500, "body": json.dumps({"error": str(e)}, cls=DecimalEncoder)}

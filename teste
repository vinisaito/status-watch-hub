import React, { useEffect, useState, useRef } from "react";

// Props do Timer
interface TimerProps {
  chamado: number; // ID do chamado
  apiBaseUrl: string; // URL da sua API REST (ex: https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod)
  wsUrl: string; // URL do WebSocket (ex: wss://tgwtw1v4rg.execute-api.us-east-1.amazonaws.com/dev)
}

interface AlertData {
  chamado: number;
  startedAt: string | null;
  durationMinutes: number;
  timerActive: boolean;
}

const Timer: React.FC<TimerProps> = ({ chamado, apiBaseUrl, wsUrl }) => {
  const [alertData, setAlertData] = useState<AlertData | null>(null);
  const [timeRemaining, setTimeRemaining] = useState<number>(0);
  const wsRef = useRef<WebSocket | null>(null);
  const intervalRef = useRef<NodeJS.Timer | null>(null);

  // Conecta WebSocket
  useEffect(() => {
    const ws = new WebSocket(wsUrl);
    wsRef.current = ws;

    ws.onopen = () => console.log("✅ WebSocket conectado");
    ws.onclose = () => console.log("❌ WebSocket desconectado");
    ws.onerror = (err) => console.error("WebSocket erro:", err);

    ws.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.type === "updateTimer" || msg.type === "TIMER_UPDATED") {
        if (msg.chamado === chamado) {
          setAlertData({
            chamado: msg.chamado,
            startedAt: msg.startedAt,
            durationMinutes: msg.durationMinutes || 15,
            timerActive: msg.timerActive,
          });
        }
      }
    };

    return () => {
      ws.close();
    };
  }, [chamado, wsUrl]);

  // Atualiza o cronômetro a cada segundo
  useEffect(() => {
    if (!alertData) return;

    if (intervalRef.current) clearInterval(intervalRef.current);

    intervalRef.current = setInterval(() => {
      if (alertData.timerActive && alertData.startedAt) {
        const startedAtDate = new Date(alertData.startedAt).getTime();
        const now = new Date().getTime();
        const remaining = Math.max(
          0,
          alertData.durationMinutes * 60 - Math.floor((now - startedAtDate) / 1000)
        );
        setTimeRemaining(remaining);
      }
    }, 1000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [alertData]);

  // Função para iniciar ou pausar o cronômetro
  const toggleTimer = async () => {
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;

    const action = alertData?.timerActive ? "pauseTimer" : "startTimer";
    wsRef.current.send(JSON.stringify({ action, chamado }));
  };

  // Formata o tempo restante para MM:SS
  const formatTime = (seconds: number) => {
    const m = Math.floor(seconds / 60)
      .toString()
      .padStart(2, "0");
    const s = (seconds % 60).toString().padStart(2, "0");
    return `${m}:${s}`;
  };

  // Busca dados iniciais do chamado via API
  useEffect(() => {
    const fetchAlert = async () => {
      try {
        const res = await fetch(`${apiBaseUrl}/dados/${chamado}`);
        if (!res.ok) throw new Error("Falha ao buscar alerta");
        const data = await res.json();
        setAlertData({
          chamado: data.chamado,
          startedAt: data.startedAt,
          durationMinutes: data.durationMinutes || 15,
          timerActive: data.timerActive,
        });
      } catch (err) {
        console.error("Erro ao buscar alerta:", err);
      }
    };

    fetchAlert();
  }, [chamado, apiBaseUrl]);

  if (!alertData) return <div>Carregando alerta...</div>;

  return (
    <div style={{ border: "1px solid #ccc", padding: "10px", margin: "10px" }}>
      <h3>Chamado: {alertData.chamado}</h3>
      <p>Status do cronômetro: {alertData.timerActive ? "Rodando" : "Pausado"}</p>
      <p>Tempo restante: {formatTime(timeRemaining)}</p>
      <button onClick={toggleTimer}>
        {alertData.timerActive ? "Pausar" : "Iniciar"}
      </button>
    </div>
  );
};

export default Timer;

import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Check, Clock, Play, CheckCircle, FastForward, RotateCcw, X } from 'lucide-react';
import { AlertData, PendingStatusChange } from '@/types/ActionTable';
import { useTimer } from '@/hooks/UseTimer';
import useChamadoStore from '@/store/useChamadoStore';
import { useEffect } from 'react';

interface ConfirmColumnProps {
  alert: AlertData;
  currentObservation: string;
  showConfirmation: boolean;
  pendingChange?: PendingStatusChange;
  onStartConfirmation: (alertId: string) => void;
  onConfirmReceived: (alertId: string) => void;
  onStartEscalation: (alertId: string, level: 1 | 2 | 3 | 4) => void;
  onObservationChange: (alertId: string, value: string) => void;
  onPendingObservationChange: (alertId: string, value: string) => void;
  onPrepareStatusChange: (alertId: string, status: string) => void;
  onConfirmStatusChange: (alertId: string) => void;
  onCancelStatusChange: (alertId: string) => void;
  onGoBack: (alertId: string) => void;
}

export const ConfirmColumn = ({
  alert,
  currentObservation,
  showConfirmation,
  pendingChange,
  onStartConfirmation,
  onConfirmReceived,
  onStartEscalation,
  onObservationChange,
  onPendingObservationChange,
  onPrepareStatusChange,
  onConfirmStatusChange,
  onCancelStatusChange,
  onGoBack,
}: ConfirmColumnProps) => {
  const { formatTime, calculateTimeRemaining } = useTimer();
  const store = useChamadoStore();
  const state = store.chamados[alert.chamado];

  const levelNames = { 1: '1¬™', 2: '2¬™', 3: '3¬™', 4: '4¬™' } as const;

  // Log para debug - monitora mudan√ßas no estado do chamado
  useEffect(() => {
    if (state) {
      console.log(`üîÑ [ConfirmColumn] Estado atualizado para chamado ${alert.chamado}:`, {
        status: state.status,
        currentLevel: state.currentLevel,
        timeRemaining: state.timeRemaining,
        timerActive: state.timerActive,
        observations: state.observations
      });
    }
  }, [state, alert.chamado]);

  // Sincroniza√ß√£o autom√°tica do timer baseado nos dados do WebSocket
  useEffect(() => {
    if (!state || !state.timerActive) return;

    const currentLevelKey = `level${state.currentLevel}` as const;
    const timerStart = state[`${currentLevelKey}_timerStart`];
    const duration = state[`${currentLevelKey}_duration`];

    if (timerStart && duration) {
      const remaining = calculateTimeRemaining(timerStart, duration);
      
      if (remaining !== state.timeRemaining) {
        console.log(`‚è∞ [ConfirmColumn] Sincronizando timer - Chamado: ${alert.chamado}, Remaining: ${remaining}s`);
        store.updateChamadoState(alert.chamado, { timeRemaining: remaining });
      }

      // Se o tempo acabou
      if (remaining <= 0 && state.timerActive) {
        console.log(`‚è∞ [ConfirmColumn] Timer expirado - Chamado: ${alert.chamado}`);
        store.updateChamadoState(alert.chamado, { 
          timerActive: false,
          timeRemaining: 0 
        });
      }
    }
  }, [state, calculateTimeRemaining, alert.chamado, store]);

  const handleInit = () => {
    try {
      console.log(`üöÄ [ConfirmColumn] Iniciando chamado ${alert.chamado} - N√≠vel 0 (20min)`);
      
      // Inicializar estado local primeiro
      store.updateChamadoState(alert.chamado, {
        chamado: alert.chamado,
        operador: "Sistema", // Campo n√£o dispon√≠vel na nova interface
        currentLevel: 0,
        status: 'pending',
        timeRemaining: 20 * 60,
        timerActive: true,
        isAttended: false
      });

      // Enviar comando para servidor
      store.sendStartTimer(alert.chamado, 0, 20 * 60);
      
      // Se j√° tiver observa√ß√£o digitada, enviar junto
      if (currentObservation?.trim()) {
        store.sendUpdateObservacao(alert.chamado, 0, currentObservation.trim());
      }
      
      onStartConfirmation(alert.id);
      
      // Solicitar estado consolidado do servidor
      setTimeout(() => store.requestState(alert.chamado), 1000);
      
    } catch (error) {
      console.error(`‚ùå [ConfirmColumn] Erro ao iniciar chamado ${alert.chamado}:`, error);
    }
  };

  const handleConfirm = () => {
    try {
      console.log(`‚úÖ [ConfirmColumn] Confirmando recebimento - Chamado: ${alert.chamado}`);
      
      // Salvar observa√ß√£o se houver
      if (currentObservation?.trim()) {
        store.sendUpdateObservacao(alert.chamado, 0, currentObservation.trim());
      }
      
      // Atualizar estado local
      store.updateChamadoState(alert.chamado, {
        status: 'confirmed',
        observations: currentObservation?.trim(),
        timerActive: false
      });
      
      onConfirmReceived(alert.id);
      
    } catch (error) {
      console.error(`‚ùå [ConfirmColumn] Erro ao confirmar chamado ${alert.chamado}:`, error);
    }
  };

  const handleEscalate = (nextLevel: 1 | 2 | 3 | 4) => {
    try {
      console.log(`üìà [ConfirmColumn] Escalando para n√≠vel ${nextLevel} - Chamado: ${alert.chamado}`);
      
      // Atualizar estado local
      store.updateChamadoState(alert.chamado, {
        currentLevel: nextLevel,
        status: 'escalating',
        timeRemaining: 10 * 60,
        timerActive: true
      });

      // Iniciar nova etapa no servidor (10 min por padr√£o)
      store.sendStartTimer(alert.chamado, nextLevel, 10 * 60);
      
      if (currentObservation?.trim()) {
        store.sendUpdateObservacao(alert.chamado, nextLevel, currentObservation.trim());
      }
      
      onStartEscalation(alert.id, nextLevel);
      
      // Solicitar estado atualizado
      setTimeout(() => store.requestState(alert.chamado), 1000);
      
    } catch (error) {
      console.error(`‚ùå [ConfirmColumn] Erro ao escalar chamado ${alert.chamado} para n√≠vel ${nextLevel}:`, error);
    }
  };

  const handleGoBack = () => {
    try {
      const prevLevel = Math.max(0, (state?.currentLevel ?? 0) - 1) as 0 | 1 | 2 | 3;
      const duration = prevLevel === 0 ? 20 * 60 : 10 * 60;
      
      console.log(`‚¨ÖÔ∏è [ConfirmColumn] Voltando para n√≠vel ${prevLevel} - Chamado: ${alert.chamado}`);
      
      // Atualizar estado local
      store.updateChamadoState(alert.chamado, {
        currentLevel: prevLevel,
        timeRemaining: duration,
        timerActive: true
      });

      store.sendStartTimer(alert.chamado, prevLevel, duration);
      onGoBack(alert.id);
      
      setTimeout(() => store.requestState(alert.chamado), 1000);
      
    } catch (error) {
      console.error(`‚ùå [ConfirmColumn] Erro ao voltar n√≠vel - Chamado: ${alert.chamado}:`, error);
    }
  };

  const handleConfirmFinalStatus = () => {
    if (!pendingChange?.status || !pendingChange?.observations?.trim()) return;
    
    try {
      const level = (state?.currentLevel ?? 0) as 0 | 1 | 2 | 3 | 4;
      const finalStatus = pendingChange.status === "attended" ? "attended" : "not-attended";
      
      console.log(`üèÅ [ConfirmColumn] Finalizando chamado ${alert.chamado} com status: ${finalStatus}`);
      
      // Atualizar estado local
      store.updateChamadoState(alert.chamado, {
        status: 'completed',
        statusFinal: finalStatus,
        observations: pendingChange.observations.trim(),
        timerActive: false,
        isAttended: finalStatus === 'attended'
      });

      store.sendUpdateStatusFinal(
        alert.chamado,
        finalStatus,
        pendingChange.observations.trim(),
        level
      );
      
      onConfirmStatusChange(alert.id);
      
    } catch (error) {
      console.error(`‚ùå [ConfirmColumn] Erro ao finalizar chamado ${alert.chamado}:`, error);
    }
  };

  // Se n√£o h√° estado, mostrar bot√£o inicial
  if (!state) {
    return (
      <div className="text-center">
        <Button
          size="sm"
          variant="outline"
          onClick={handleInit}
          className="h-8 px-3 text-xs"
        >
          <Play className="h-3 w-3 mr-1" />
          Iniciar
        </Button>
      </div>
    );
  }

  // Renderiza√ß√£o baseada no status atual
  switch (state.status) {
    case 'pending':
      return (
        <div className="text-center space-y-3">
          <div className="flex items-center justify-center gap-2">
            <Clock className="h-4 w-4 text-warning" />
            <span
              className="text-sm font-mono font-bold"
              style={{ color: state.timeRemaining <= 60 ? '#ef4444' : '#f59e0b' }}
            >
              {formatTime(state.timeRemaining)}
            </span>
            {state.timerActive && (
              <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
            )}
          </div>

          <div className="space-y-2">
            <div className="space-y-1">
              <Label className="text-xs">
                Observa√ß√µes <span className="text-destructive">*</span>
              </Label>
              <Textarea
                placeholder="Observa√ß√µes s√£o obrigat√≥rias para confirma√ß√£o"
                value={currentObservation}
                onChange={(e) => onObservationChange(alert.id, e.target.value)}
                className="text-xs min-h-[60px] resize-none"
                required
              />
              {!currentObservation.trim() && (
                <p className="text-xs text-destructive">Observa√ß√µes s√£o obrigat√≥rias</p>
              )}
            </div>

            <div className="flex gap-1">
              <Button
                size="sm"
                variant="default"
                onClick={handleConfirm}
                disabled={!currentObservation.trim()}
                className="h-8 px-3 text-xs flex-1 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <Check className="h-3 w-3 mr-1" />
                Confirmar
              </Button>
              <Button
                size="sm"
                variant="secondary"
                onClick={() => handleEscalate(1)}
                disabled={!currentObservation.trim()}
                className="h-8 px-3 text-xs flex-1 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <FastForward className="h-3 w-3 mr-1" />
                Pr√≥xima Etapa
              </Button>
            </div>
          </div>
        </div>
      );

    case 'confirmed':
      return (
        <div className="text-center space-y-2">
          <div className="flex gap-1 justify-center">
            <Badge variant="default" className="bg-green-600 text-white">
              <CheckCircle className="h-3 w-3 mr-1" />
              Confirmado
            </Badge>
            <Button
              size="sm"
              variant="outline"
              onClick={() => handleEscalate(1)}
              className="h-6 px-2 text-xs"
            >
              <FastForward className="h-3 w-3 mr-1" />
              Pr√≥xima
            </Button>
          </div>
          {state.observations && (
            <div className="text-xs text-muted-foreground p-2 bg-muted rounded text-left">
              <strong>Observa√ß√µes:</strong>
              <br />
              {state.observations}
            </div>
          )}
        </div>
      );

    case 'escalating':
      return (
        <div className="space-y-2">
          {state.currentLevel > 0 && (
            <div className="text-center">
              <Badge variant="destructive" className="text-xs">
                {levelNames[state.currentLevel as keyof typeof levelNames]} Escala√ß√£o
              </Badge>
              {state.timerActive && (
                <div className="flex items-center justify-center gap-1 mt-1">
                  <Clock className="h-3 w-3 text-warning" />
                  <span
                    className="text-xs font-mono font-bold"
                    style={{ color: state.timeRemaining <= 60 ? '#ef4444' : '#f59e0b' }}
                  >
                    {formatTime(state.timeRemaining)}
                  </span>
                  <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
                </div>
              )}
            </div>
          )}

          {!state.isAttended && (
            <>
              {showConfirmation ? (
                <div className="space-y-2 p-2 border rounded bg-background">
                  <div className="text-xs font-medium">
                    Confirmar: {pendingChange?.status === 'attended' ? 'Atendida' : 'N√£o Atendida'}
                  </div>

                  <div className="space-y-1">
                    <Label className="text-xs">
                      Observa√ß√µes <span className="text-destructive">*</span>
                    </Label>
                    <Textarea
                      placeholder="Observa√ß√µes obrigat√≥rias..."
                      value={pendingChange?.observations || ''}
                      onChange={(e) => onPendingObservationChange(alert.id, e.target.value)}
                      className="text-xs min-h-[60px] resize-none"
                      required
                    />
                    {!pendingChange?.observations?.trim() && (
                      <p className="text-xs text-destructive">Observa√ß√µes s√£o obrigat√≥rias</p>
                    )}
                  </div>

                  <div className="flex gap-1">
                    <Button
                      size="sm"
                      variant="default"
                      onClick={handleConfirmFinalStatus}
                      disabled={!pendingChange?.observations?.trim()}
                      className="h-6 px-2 text-xs flex-1"
                    >
                      <Check className="h-3 w-3 mr-1" />
                      Confirmar
                    </Button>
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => onCancelStatusChange(alert.id)}
                      className="h-6 px-2 text-xs flex-1"
                    >
                      <X className="h-3 w-3 mr-1" />
                      Cancelar
                    </Button>
                  </div>
                </div>
              ) : (
                <>
                  <div className="flex gap-1">
                    {state.currentLevel > 0 && (
                      <Button
                        size="sm"
                        variant="outline"
                        onClick={handleGoBack}
                        className="h-6 px-2 text-xs flex-1"
                      >
                        <RotateCcw className="h-3 w-3 mr-1" />
                        Voltar
                      </Button>
                    )}

                    {state.currentLevel < 4 && (
                      <Button
                        size="sm"
                        variant="outline"
                        onClick={() =>
                          handleEscalate((state.currentLevel + 1) as 1 | 2 | 3 | 4)
                        }
                        className="h-6 px-2 text-xs flex-1"
                      >
                        Iniciar{' '}
                        {levelNames[(state.currentLevel + 1) as keyof typeof levelNames]} Escala√ß√£o
                      </Button>
                    )}
                  </div>

                  <Select
                    value=""
                    onValueChange={(value) => onPrepareStatusChange(alert.id, value)}
                  >
                    <SelectTrigger className="h-6 text-xs">
                      <SelectValue placeholder="Selecionar Status" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="attended">Atendida</SelectItem>
                      <SelectItem value="not-attended">N√£o Atendida</SelectItem>
                    </SelectContent>
                  </Select>
                </>
              )}
            </>
          )}
        </div>
      );

    case 'completed':
      return (
        <div className="text-center space-y-2">
          <div className="flex gap-1 justify-center">
            <Badge variant="default" className="bg-green-600 text-white">
              <CheckCircle className="h-3 w-3 mr-1" />
              Finalizado
            </Badge>
          </div>
          {state.observations && (
            <div className="text-xs text-muted-foreground p-2 bg-muted rounded text-left">
              <strong>Observa√ß√µes:</strong>
              <br />
              {state.observations}
            </div>
          )}
        </div>
      );

    default:
      console.warn(`‚ö†Ô∏è [ConfirmColumn] Status desconhecido para chamado ${alert.chamado}: ${state.status}`);
      return null;
  }
};

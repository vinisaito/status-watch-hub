import React, { useEffect, useRef, useState } from "react";

interface Alerta {
  chamado: number;
  timerActive: boolean;
  startedAt?: string;
  durationMinutes: number;
  elapsedSeconds: number;
  timeRemaining: number;
}

const WEBSOCKET_URL = "wss://SEU_ENDPOINT.execute-api.us-east-1.amazonaws.com/prod";
const GET_STATE_URL = "https://SEU_ENDPOINT.execute-api.us-east-1.amazonaws.com/prod/dados";

export const Timer: React.FC<{ chamado: number }> = ({ chamado }) => {
  const [alerta, setAlerta] = useState<Alerta | null>(null);
  const wsRef = useRef<WebSocket | null>(null);
  const intervalRef = useRef<NodeJS.Timer | null>(null);

  // Conectar WebSocket
  useEffect(() => {
    console.log("ðŸ”Œ Conectando ao WebSocket...");
    const ws = new WebSocket(WEBSOCKET_URL);

    ws.onopen = () => {
      console.log("âœ… WebSocket conectado");
      // Opcional: buscar estado inicial via getState
      fetchState();
    };

    ws.onmessage = (msg) => {
      console.log("ðŸ“¨ Mensagem recebida:", msg.data);
      try {
        const data = JSON.parse(msg.data);
        if (data.type === "TIMER_UPDATED" && data.chamado === chamado) {
          setAlerta({
            chamado: data.chamado,
            timerActive: data.timerActive,
            startedAt: data.startedAt,
            durationMinutes: data.durationMinutes,
            elapsedSeconds: data.elapsedSeconds || 0,
            timeRemaining: data.timeRemaining,
          });
        }
      } catch (e) {
        console.error("âŒ Erro ao processar mensagem WS:", e);
      }
    };

    ws.onerror = (err) => console.error("âŒ WebSocket erro:", err);
    ws.onclose = () => console.log("ðŸ”Œ WebSocket desconectado");

    wsRef.current = ws;
    return () => ws.close();
  }, [chamado]);

  // Atualizar cronÃ´metro a cada segundo
  useEffect(() => {
    if (!alerta) return;
    if (intervalRef.current) clearInterval(intervalRef.current);

    if (alerta.timerActive) {
      intervalRef.current = setInterval(() => {
        setAlerta((prev) => {
          if (!prev) return prev;
          return {
            ...prev,
            timeRemaining: Math.max(prev.timeRemaining - 1, 0),
          };
        });
      }, 1000);
    }

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [alerta?.timerActive]);

  // FunÃ§Ã£o para buscar estado via GET
  const fetchState = async () => {
    try {
      console.log("ðŸŒ Buscando estado inicial...");
      const res = await fetch(`${GET_STATE_URL}?chamado=${chamado}`);
      const data = await res.json();
      console.log("ðŸ“Š Estado inicial:", data);
      setAlerta({
        chamado: data.chamado,
        timerActive: data.timerActive,
        startedAt: data.startedAt,
        durationMinutes: data.durationMinutes,
        elapsedSeconds: data.elapsedSeconds || 0,
        timeRemaining: data.timeRemaining,
      });
    } catch (e) {
      console.error("âŒ Erro ao buscar estado:", e);
    }
  };

  // Enviar aÃ§Ã£o via WebSocket
  const sendAction = (action: "startTimer" | "pauseTimer") => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      console.log(`ðŸ“¤ Enviando ${action}...`);
      wsRef.current.send(JSON.stringify({ action, chamado }));
    } else {
      console.warn("âš ï¸ WebSocket nÃ£o estÃ¡ aberto");
    }
  };

  // Formatar tempo restante
  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
  };

  return (
    <div style={{ padding: "20px", border: "1px solid #ccc", width: "250px" }}>
      <h3>Chamado: {chamado}</h3>
      <p>Status: {alerta?.timerActive ? "Ativo" : "Pausado"}</p>
      <p>Tempo restante: {alerta ? formatTime(alerta.timeRemaining) : "--:--"}</p>
      <button onClick={() => sendAction("startTimer")}>Iniciar</button>
      <button onClick={() => sendAction("pauseTimer")}>Pausar</button>
    </div>
  );
};

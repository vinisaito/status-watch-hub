// src/components/Timer.tsx
import React, { useEffect, useState, useRef } from "react";

interface TimerData {
  chamado: number;
  startedAt: string | null;
  durationMinutes: number;
  timerActive: boolean;
}

const WS_URL = "wss://SEU_ENDPOINT.execute-api.us-east-1.amazonaws.com/dev"; // substituir
const API_URL = "https://SEU_ENDPOINT.execute-api.us-east-1.amazonaws.com/prod/dados"; // substituir

const Timer: React.FC = () => {
  const [timers, setTimers] = useState<TimerData[]>([]);
  const [wsConnected, setWsConnected] = useState(false);
  const ws = useRef<WebSocket | null>(null);

  // Fetch inicial para pegar timers persistentes
  useEffect(() => {
    fetch(API_URL)
      .then((res) => res.json())
      .then((data) => {
        setTimers(data);
        console.log("‚úÖ Dados recebidos da API:", data);
      })
      .catch(console.error);
  }, []);

  // Conex√£o WebSocket
  useEffect(() => {
    ws.current = new WebSocket(WS_URL);

    ws.current.onopen = () => {
      console.log("‚úÖ WebSocket conectado");
      setWsConnected(true);
    };

    ws.current.onmessage = (event) => {
      const data = JSON.parse(event.data);
      console.log("üì© Mensagem recebida:", data);
      if (data.type === "TIMER_UPDATED") {
        setTimers((prev) =>
          prev.map((t) =>
            t.chamado === data.chamado
              ? { ...t, ...data }
              : t
          )
        );
      }
    };

    ws.current.onclose = () => {
      console.log("‚ùå WebSocket desconectado");
      setWsConnected(false);
    };

    ws.current.onerror = (err) => {
      console.error("‚ö† WebSocket erro:", err);
      setWsConnected(false);
    };

    return () => ws.current?.close();
  }, []);

  // Atualiza timers a cada segundo para efeito de cron√¥metro
  useEffect(() => {
    const interval = setInterval(() => {
      setTimers((prev) => [...prev]);
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  // Calcula tempo restante
  const getRemaining = (timer: TimerData) => {
    const duration = timer.durationMinutes ?? 0;
    if (!timer.startedAt) return duration * 60;

    const startedAtDate = new Date(timer.startedAt);
    if (isNaN(startedAtDate.getTime())) return duration * 60;

    const elapsed = (new Date().getTime() - startedAtDate.getTime()) / 1000;
    return Math.max(0, duration * 60 - elapsed);
  };

  // Envia a√ß√£o para a Lambda via WebSocket
  const sendAction = (chamado: number, action: "startTimer" | "pauseTimer") => {
    if (ws.current?.readyState === WebSocket.OPEN) {
      ws.current.send(JSON.stringify({ action, chamado }));
      console.log("üì§ Mensagem enviada:", { action, chamado });
    } else {
      console.warn("‚ö† WebSocket n√£o est√° conectado");
      alert("WebSocket n√£o est√° conectado. Atualize a p√°gina.");
    }
  };

  return (
    <div>
      <h1>Painel de Alertas</h1>
      {!wsConnected && <p style={{ color: "red" }}>WebSocket desconectado</p>}
      {timers.length === 0 && <p>Carregando alertas...</p>}
      {timers.map((t) => (
        <div key={t.chamado} style={{ border: "1px solid gray", padding: 10, margin: 5 }}>
          <p>Chamado: {t.chamado}</p>
          <p>Status: {t.timerActive ? "Rodando" : "Pausado"}</p>
          <p>
            Tempo restante:{" "}
            {`${Math.floor(getRemaining(t) / 60)
              .toString()
              .padStart(2, "0")}:${Math.floor(getRemaining(t) % 60)
              .toString()
              .padStart(2, "0")}`}
          </p>
          <button onClick={() => sendAction(t.chamado, "startTimer")}>Iniciar</button>
          <button onClick={() => sendAction(t.chamado, "pauseTimer")}>Pausar</button>
        </div>
      ))}
    </div>
  );
};

export default Timer;

import os
import pyodbc
import json
import time
import boto3
from datetime import datetime
from botocore.exceptions import ClientError

# DynamoDB e API Gateway
dynamodb = boto3.resource("dynamodb")
connections_table = dynamodb.Table("painelmonitoracao_connections")

# Endpoint da sua API WebSocket (ex: wss://xxxxx.execute-api.us-east-1.amazonaws.com/prod)
WEBSOCKET_ENDPOINT = os.environ.get("WEBSOCKET_ENDPOINT")

def lambda_handler(event, context):
    start_total = time.time()
    print("[INÍCIO] Execução da Lambda")

    try:
        # Variáveis de ambiente
        server = os.environ['DB_SERVER']
        username = os.environ['DB_USER']
        password = os.environ['DB_PASSWORD']
        port = os.environ.get('DB_PORT', '1433')
        database = 'mdb'

        # String de conexão
        connection_string = (
            f'DRIVER={{ODBC Driver 18 for SQL Server}};'
            f'SERVER={server},{port};'
            f'DATABASE={database};'
            f'UID={username};'
            f'PWD={password};'
            f'Encrypt=no;TrustServerCertificate=yes;'
            f'CHARSET=UTF8;'
        )

        # Conexão com o banco
        conn = pyodbc.connect(connection_string, timeout=5)
        cursor = conn.cursor()
        print("[OK] Conectado ao banco.")

        # Consulta SQL
        query = """
            SELECT [chamado]
                  ,[tipo_chamado]
                  ,[status_chamado]
                  ,[abertura_chamado]
                  ,[resumo_chamado]
                  ,[grupo_chamado]
                  ,[severidade_chamado]
                  ,[acionado]
                  ,[link_chamado]
            FROM [mdb].[dbo].[view_ciops_acionamento]
            WHERE TRY_CONVERT(DATETIME, abertura_chamado, 103) >= DATEADD(HOUR, -10, GETDATE());
        """

        cursor.execute(query)
        rows = cursor.fetchall()

        # Processamento dos dados
        columns = [column[0] for column in cursor.description]
        results = []
        for row in rows:
            row_dict = dict(zip(columns, row))
            if isinstance(row_dict.get("abertura_chamado"), datetime):
                row_dict["abertura_chamado"] = row_dict["abertura_chamado"].strftime("%Y-%m-%dT%H:%M:%S")
            results.append(row_dict)

        cursor.close()
        conn.close()

        # Envia os dados via WebSocket
        if WEBSOCKET_ENDPOINT:
            send_to_all_connections({
                "type": "NEW_ALERTS",
                "data": results
            })

        # Retorna resposta REST normal
        return {
            'statusCode': 200,
            'headers': {
                'Content-Type': 'application/json; charset=utf-8',
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps(results, ensure_ascii=False)
        }

    except Exception as e:
        print("[ERRO]", str(e))
        return {
            'statusCode': 500,
            'headers': {
                'Content-Type': 'application/json; charset=utf-8',
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({'error': str(e)}, ensure_ascii=False)
        }


def send_to_all_connections(message):
    """Envia o payload para todos os clientes WebSocket conectados"""
    if not WEBSOCKET_ENDPOINT:
        print("[AVISO] WEBSOCKET_ENDPOINT não configurado.")
        return

    apigw = boto3.client("apigatewaymanagementapi", endpoint_url=WEBSOCKET_ENDPOINT)

    try:
        connections = connections_table.scan().get("Items", [])
        print(f"[INFO] Enviando para {len(connections)} conexões ativas.")

        for conn in connections:
            connection_id = conn.get("connectionId")
            try:
                apigw.post_to_connection(
                    ConnectionId=connection_id,
                    Data=json.dumps(message).encode("utf-8")
                )
            except ClientError as e:
                # Remove conexões inativas
                if e.response["Error"]["Code"] == "GoneException":
                    print(f"[REMOVENDO] Conexão {connection_id} inativa.")
                    connections_table.delete_item(Key={"connectionId": connection_id})
                else:
                    print(f"[ERRO] Falha ao enviar para {connection_id}: {e}")

    except Exception as e:
        print("[ERRO WEBSOCKET]", str(e))

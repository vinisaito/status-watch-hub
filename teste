import boto3
import json
from datetime import datetime, timezone
from decimal import Decimal

# DynamoDB
DDB = boto3.resource("dynamodb", region_name="us-east-1")
ACOMP_TABLE = DDB.Table("painelmonitoracao_acompanhamento")
CONN_TABLE = DDB.Table("painelmonitoracao_connections")

# API Gateway Management API (WebSocket)
APIGW_ENDPOINT = "https://cn8i8z6f81.execute-api.us-east-1.amazonaws.com/prod"
apigw = boto3.client("apigatewaymanagementapi", endpoint_url=APIGW_ENDPOINT)

# Serializa√ß√£o Decimal
def json_serial(obj):
    if isinstance(obj, Decimal):
        return int(obj) if obj % 1 == 0 else float(obj)
    raise TypeError

def to_decimal(value):
    return Decimal(str(value))

# C√°lculo do tempo restante
def calculate_remaining(alerta):
    try:
        duration = Decimal(str(alerta.get("durationMinutes", 15)))
        timer_active = alerta.get("timerActive", False)
        elapsed = Decimal(str(alerta.get("elapsedSeconds", 0)))
        started_at = alerta.get("startedAt")

        print(f"üîç calculate_remaining(): duration={duration}, timer_active={timer_active}, elapsed={elapsed}, started_at={started_at}")

        if timer_active and started_at:
            started_dt = datetime.fromisoformat(str(started_at).replace("Z", "+00:00"))
            now = datetime.utcnow().replace(tzinfo=timezone.utc)
            elapsed += Decimal(str((now - started_dt).total_seconds()))
            print(f"‚è±Ô∏è Tempo decorrido atualizado: {elapsed}")

        remaining = max(0, float(duration * 60 - elapsed))
        print(f"‚è≥ Tempo restante: {remaining}")
        return int(remaining), timer_active, elapsed
    except Exception as e:
        print(f"‚ùå Erro em calculate_remaining: {e}")
        return 0, False, Decimal(0)

def lambda_handler(event, context):
    print("üì• Evento recebido:", json.dumps(event))
    route = event.get("requestContext", {}).get("routeKey")
    connection_id = event.get("requestContext", {}).get("connectionId")

    if route == "$connect":
        print(f"üîå Nova conex√£o: {connection_id}")
        CONN_TABLE.put_item(Item={"connectionId": connection_id})
        return {"statusCode": 200}

    elif route == "$disconnect":
        print(f"üîå Desconectando: {connection_id}")
        CONN_TABLE.delete_item(Key={"connectionId": connection_id})
        return {"statusCode": 200}

    elif route == "sendMessage":
        print("üì® Mensagem recebida pelo WS")
        body = json.loads(event.get("body", "{}"))
        print("üì¶ Conte√∫do do body:", body)
        action = body.get("action")
        chamado = body.get("chamado")

        if not chamado or not action:
            print("‚ö†Ô∏è Falta 'chamado' ou 'action'")
            return {"statusCode": 400, "body": "Chamado ou a√ß√£o ausente"}

        # Busca chamado
        alerta_resp = ACOMP_TABLE.get_item(Key={"chamado": int(chamado)})
        alerta = alerta_resp.get("Item")
        print(f"üîé Alerta encontrado: {alerta}")
        if not alerta:
            print("‚ùå Chamado n√£o encontrado")
            return {"statusCode": 404, "body": "Chamado n√£o encontrado"}

        now_iso = datetime.utcnow().replace(tzinfo=timezone.utc).isoformat()
        remaining, timer_active, elapsed = calculate_remaining(alerta)
        print(f"üìä Estado antes da a√ß√£o: remaining={remaining}, timer_active={timer_active}, elapsed={elapsed}")

        # A√ß√µes
        if action == "startTimer":
            print("‚ñ∂Ô∏è Iniciando timer")
            ACOMP_TABLE.update_item(
                Key={"chamado": int(chamado)},
                UpdateExpression="SET timerActive=:t, startedAt=:s, elapsedSeconds=:e",
                ExpressionAttributeValues={
                    ":t": True,
                    ":s": now_iso,
                    ":e": to_decimal(elapsed)
                }
            )
        elif action == "pauseTimer":
            print("‚è∏Ô∏è Pausando timer")
            ACOMP_TABLE.update_item(
                Key={"chamado": int(chamado)},
                UpdateExpression="SET timerActive=:t, elapsedSeconds=:e",
                ExpressionAttributeValues={
                    ":t": False,
                    ":e": to_decimal(elapsed)
                }
            )
        else:
            print("‚ö†Ô∏è A√ß√£o inv√°lida")
            return {"statusCode": 400, "body": "A√ß√£o inv√°lida"}

        # Atualiza alerta para broadcast
        alerta_resp = ACOMP_TABLE.get_item(Key={"chamado": int(chamado)})
        alerta = alerta_resp.get("Item")
        print(f"üì¶ Alerta atualizado: {alerta}")
        remaining, timer_active, _ = calculate_remaining(alerta)

        # Broadcast
        connections = CONN_TABLE.scan().get("Items", [])
        print(f"üì° Enviando atualiza√ß√£o para {len(connections)} conex√µes")
        for conn in connections:
            try:
                apigw.post_to_connection(
                    ConnectionId=conn["connectionId"],
                    Data=json.dumps({
                        "type": "TIMER_UPDATED",
                        "chamado": alerta["chamado"],
                        "timerActive": timer_active,
                        "startedAt": alerta.get("startedAt"),
                        "durationMinutes": alerta.get("durationMinutes", 15),
                        "timeRemaining": remaining
                    }, default=json_serial)
                )
                print(f"‚úÖ Mensagem enviada para {conn['connectionId']}")
            except apigw.exceptions.GoneException:
                print(f"‚ö†Ô∏è Conex√£o {conn['connectionId']} n√£o existe mais, removendo")
                CONN_TABLE.delete_item(Key={"connectionId": conn["connectionId"]})

        return {"statusCode": 200, "body": json.dumps({"message": "ok"})}

    elif route == "getState":
        chamado = event.get("queryStringParameters", {}).get("chamado")
        print(f"üåê Requisi√ß√£o getState para chamado: {chamado}")
        if not chamado:
            return {"statusCode": 400, "body": "Chamado ausente"}

        alerta_resp = ACOMP_TABLE.get_item(Key={"chamado": int(chamado)})
        alerta = alerta_resp.get("Item")
        print(f"üîç Estado encontrado: {alerta}")
        if not alerta:
            return {"statusCode": 404, "body": "Chamado n√£o encontrado"}

        remaining, timer_active, _ = calculate_remaining(alerta)
        alerta["timeRemaining"] = remaining
        alerta["timerActive"] = timer_active

        return {"statusCode": 200, "body": json.dumps(alerta, default=json_serial)}

    else:
        print(f"‚ö†Ô∏è Rota {route} n√£o suportada")
        return {"statusCode": 400, "body": "Rota n√£o suportada"}

import json
import boto3
import os
import traceback
from datetime import datetime, timezone
from decimal import Decimal

# ---------- Config ----------
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table(os.environ["RDM_TABLE"])

# ---------- Headers CORS ----------
cors_headers = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "OPTIONS,POST,GET",
    "Access-Control-Allow-Headers": "Content-Type"
}

def _to_native(obj):
    # Converte Decimal recursivamente para int/float; mantém outros tipos
    if isinstance(obj, list):
        return [_to_native(x) for x in obj]
    if isinstance(obj, dict):
        return {k: _to_native(v) for k, v in obj.items()}
    if isinstance(obj, Decimal):
        return int(obj) if obj % 1 == 0 else float(obj)
    return obj

def _parse_rdms_from_event(event):
    # Suporta ?rdm=123, ?rdm=123,456 e ?rdm=123&rdm=456
    qsp = event.get("queryStringParameters") or {}
    mv = event.get("multiValueQueryStringParameters") or {}
    rdms = []

    if "rdm" in mv and isinstance(mv["rdm"], list):
        for token in mv["rdm"]:
            for part in str(token).split(","):
                s = part.strip()
                if s:
                    rdms.append(s)
    elif "rdm" in qsp:
        for part in str(qsp["rdm"]).split(","):
            s = part.strip()
            if s:
                rdms.append(s)

    if not rdms:
        return []

    # valida numérico
    valid = []
    for r in rdms:
        try:
            valid.append(int(r))
        except ValueError:
            # ignora entradas inválidas
            pass
    return valid

def lambda_handler(event, context):
    """
    Lambda REST API para registrar e consultar RDMs no DynamoDB.
    Métodos:
      - POST → cria/atualiza um RDM
      - GET  → busca 1 ou N RDMs (?rdm=123 ou ?rdm=123,456 ou ?rdm=123&rdm=456)
      - OPTIONS → resposta CORS
    """
    try:
        method = event.get("httpMethod", "")

        # --- Requisição OPTIONS (CORS preflight) ---
        if method == "OPTIONS":
            return {
                "statusCode": 200,
                "headers": cors_headers,
                "body": json.dumps({"message": "CORS preflight OK"})
            }

        # --- Método GET (consultar RDM) ---
        if method == "GET":
            rdms = _parse_rdms_from_event(event)

            if not rdms:
                return {
                    "statusCode": 400,
                    "headers": cors_headers,
                    "body": json.dumps({"error": "Parâmetro 'rdm' é obrigatório no GET (ex.: ?rdm=123 ou ?rdm=123,456)"})
                }

            # 1 rdm → objeto único (compatibilidade)
            if len(rdms) == 1:
                rdm = rdms[0]
                response = table.get_item(Key={"rdm": Decimal(rdm)})
                item = response.get("Item")
                if not item:
                    return {
                        "statusCode": 404,
                        "headers": cors_headers,
                        "body": json.dumps({"error": f"RDM {rdm} não encontrado"})
                    }
                return {
                    "statusCode": 200,
                    "headers": cors_headers,
                    "body": json.dumps(_to_native(item))
                }

            # N rdms → lista de itens encontrados (não encontrados são ignorados)
            found = []
            for r in rdms:
                try:
                    resp = table.get_item(Key={"rdm": Decimal(r)})
                    it = resp.get("Item")
                    if it:
                        found.append(_to_native(it))
                except Exception:
                    # continua para os demais, sem derrubar tudo
                    pass

            return {
                "statusCode": 200,
                "headers": cors_headers,
                "body": json.dumps(found)
            }

        # --- Método POST (registrar/atualizar RDM) ---
        if method == "POST":
            raw_body = event.get("body")
            body = json.loads(raw_body) if raw_body else {}

            rdm = body.get("rdm")
            status = body.get("status")
            timestamp = body.get("timestamp")

            if rdm is None or status is None:
                return {
                    "statusCode": 400,
                    "headers": cors_headers,
                    "body": json.dumps({"error": "Campos obrigatórios: rdm e status"})
                }

            try:
                rdm = int(rdm)
            except (ValueError, TypeError):
                return {
                    "statusCode": 400,
                    "headers": cors_headers,
                    "body": json.dumps({"error": "O campo 'rdm' deve ser numérico"})
                }

            if not timestamp:
                timestamp = datetime.now(timezone.utc).isoformat()

            table.put_item(
                Item={
                    "rdm": Decimal(rdm),
                    "status": str(status),
                    "timestamp": str(timestamp),
                }
            )

            return {
                "statusCode": 200,
                "headers": cors_headers,
                "body": json.dumps({
                    "message": "RDM registrado com sucesso!",
                    "item": {"rdm": rdm, "status": status, "timestamp": timestamp}
                }),
            }

        # --- Método não suportado ---
        return {
            "statusCode": 405,
            "headers": cors_headers,
            "body": json.dumps({"error": f"Método {method} não permitido"})
        }

    except Exception as e:
        # Log detalhado para diagnóstico em CloudWatch
        print("Erro ao processar:", e)
        print("Traceback:", traceback.format_exc())
        return {
            "statusCode": 500,
            "headers": cors_headers,
            "body": json.dumps({"error": str(e)}),
        }

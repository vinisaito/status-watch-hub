import React, { useEffect, useState, useRef } from "react";

interface TimerData {
  chamado: number;
  timerActive: boolean;
  startedAt: string | null;
  durationMinutes: number;
  timeRemaining: number;
}

const WS_URL = "wss://YOUR_API_ID.execute-api.us-east-1.amazonaws.com/prod";
const GET_STATE_URL = "https://YOUR_API_ID.execute-api.us-east-1.amazonaws.com/prod/getState";

const Timer: React.FC<{ chamado: number }> = ({ chamado }) => {
  const [timerData, setTimerData] = useState<TimerData | null>(null);
  const wsRef = useRef<WebSocket | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  // Fun√ß√£o para buscar o estado inicial do chamado
  const fetchInitialState = async () => {
    try {
      console.log("üåê Chamando getState");
      const res = await fetch(`${GET_STATE_URL}?chamado=${chamado}`);
      const data = await res.json();
      console.log("üì¶ getState retornou:", data);
      setTimerData(data);
    } catch (err) {
      console.error("‚ùå Erro no getState:", err);
    }
  };

  // Inicializa WebSocket
  useEffect(() => {
    console.log("üîå Abrindo WebSocket");
    const ws = new WebSocket(WS_URL);
    wsRef.current = ws;

    ws.onopen = () => {
      console.log("‚úÖ WebSocket conectado");
      fetchInitialState();
    };

    ws.onmessage = (event) => {
      console.log("üì® Mensagem WS recebida:", event.data);
      try {
        const msg = JSON.parse(event.data);
        if (msg.type === "TIMER_UPDATED" && msg.chamado === chamado) {
          console.log("‚è± Atualizando timer do estado:", msg);
          setTimerData(msg);
        }
      } catch (err) {
        console.error("‚ùå Erro parseando WS message:", err);
      }
    };

    ws.onerror = (err) => console.error("‚ùå WS error:", err);
    ws.onclose = () => console.log("‚ùå WebSocket fechado");

    return () => {
      console.log("üîå Fechando WebSocket");
      ws.close();
    };
  }, [chamado]);

  // Intervalo local para decrementar timeRemaining
  useEffect(() => {
    if (intervalRef.current) clearInterval(intervalRef.current);

    intervalRef.current = setInterval(() => {
      setTimerData((prev) => {
        if (prev && prev.timerActive && prev.timeRemaining > 0) {
          return { ...prev, timeRemaining: prev.timeRemaining - 1 };
        }
        return prev;
      });
    }, 1000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  const sendAction = (action: "startTimer" | "pauseTimer") => {
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
      console.warn("‚ö†Ô∏è WS ainda n√£o conectado");
      return;
    }
    console.log(`üì§ Enviando action ${action}`);
    wsRef.current.send(JSON.stringify({ action, chamado }));
  };

  if (!timerData) return <div>Carregando timer...</div>;

  const minutes = Math.floor(timerData.timeRemaining / 60);
  const seconds = timerData.timeRemaining % 60;

  return (
    <div>
      <h2>Chamado: {chamado}</h2>
      <p>
        Tempo restante: {minutes.toString().padStart(2, "0")}:
        {seconds.toString().padStart(2, "0")}
      </p>
      <p>Status: {timerData.timerActive ? "Ativo" : "Pausado"}</p>
      <button onClick={() => sendAction("startTimer")}>Iniciar</button>
      <button onClick={() => sendAction("pauseTimer")}>Pausar</button>
    </div>
  );
};

export default Timer;

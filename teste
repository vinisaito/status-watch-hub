// src/store/useChamadoStore.ts
import { create } from "zustand";

/** -----------------------------
 *   Tipos do estado no Front
 * ----------------------------- */
export interface ChamadoView {
  status: "pending" | "confirmed" | "escalating" | "completed";
  currentLevel: number;       // 0..4
  timeRemaining: number;      // em segundos
  timerActive: boolean;
  observations: string;       // observação do nível atual
  isAttended: boolean;        // true se statusFinal === "attended"
}

interface StoreShape {
  chamados: Record<string, ChamadoView>;
  initChamado: (id: string) => void;
  updateChamado: (id: string, data: Partial<ChamadoView>) => void;
  setFromWS: (id: string, data: Partial<ChamadoView>) => void;
  tick: () => void;
  reset: () => void;
}

/** -----------------------------
 *   WS: URL e socket
 * ----------------------------- */
const WS_URL =
  process.env.NEXT_PUBLIC_WS_URL ||
  "wss://rsgjd6wsza.execute-api.us-east-1.amazonaws.com/dev";

let socket: WebSocket | null = null;

/** -----------------------------
 *   Store (Zustand)
 * ----------------------------- */
export const useChamadoStore = create<StoreShape>((set, get) => ({
  chamados: {},

  initChamado: (id: string) =>
    set((state) => {
      if (state.chamados[id]) return state;
      return {
        chamados: {
          ...state.chamados,
          [id]: {
            status: "pending",
            currentLevel: 0,
            timeRemaining: 1200, // 20min default p/ nível 0
            timerActive: false,
            observations: "",
            isAttended: false,
          },
        },
      };
    }),

  updateChamado: (id, data) =>
    set((state) => ({
      chamados: {
        ...state.chamados,
        [id]: { ...(state.chamados[id] || {}), ...data },
      },
    })),

  setFromWS: (id, data) =>
    set((state) => ({
      chamados: {
        ...state.chamados,
        [id]: { ...(state.chamados[id] || {}), ...data },
      },
    })),

  tick: () =>
    set((state) => {
      const next: Record<string, ChamadoView> = {};
      for (const [id, c] of Object.entries(state.chamados)) {
        if (c.timerActive && c.timeRemaining > 0) {
          next[id] = { ...c, timeRemaining: c.timeRemaining - 1 };
        } else if (c.timerActive && c.timeRemaining <= 0) {
          next[id] = { ...c, timeRemaining: 0, timerActive: false };
        } else {
          next[id] = c;
        }
      }
      return { chamados: next };
    }),

  reset: () => set({ chamados: {} }),
}));

/** -----------------------------
 *   Helpers de mapeamento (Lambda → Store)
 * ----------------------------- */

// calcula segundos restantes a partir de ISO + duração
function remainingFromStart(iso?: string, duration?: number): number | undefined {
  if (!iso || typeof duration !== "number") return undefined;
  const startSec = Math.floor(new Date(iso).getTime() / 1000);
  const nowSec = Math.floor(Date.now() / 1000);
  return Math.max(0, startSec + duration - nowSec);
}

// dado um state do DDB, tenta inferir o "nível ativo" mais recente
function inferCurrentLevelFromItem(item: any): number {
  // se tiver statusFinal => já finalizado, manter último nível que tiver timerStart
  let bestLevel = 0;
  let bestStart = 0;
  for (let lvl = 0; lvl <= 4; lvl++) {
    const ts = item?.[`level${lvl}_timerStart`];
    if (typeof ts === "string") {
      const t = new Date(ts).getTime();
      if (t > bestStart) {
        bestStart = t;
        bestLevel = lvl;
      }
    }
  }
  return bestLevel;
}

function toViewFromBroadcast(msg: any): Partial<ChamadoView> {
  // msg.event: "startTimer" | "updateObservacao" | "updateStatusFinal" | "updateOperador"
  const event = msg?.event;
  const level = Number(msg?.level ?? 0);
  const state = msg?.state || {};
  const dur = state[`level${level}_duration`];
  const startISO = state[`level${level}_timerStart`];
  const obs = state[`level${level}_observacao`] ?? "";

  if (event === "startTimer") {
    const rem = remainingFromStart(startISO, dur);
    return {
      status: level === 0 ? "pending" : "escalating",
      currentLevel: level,
      timeRemaining: typeof rem === "number" ? rem : 0,
      timerActive: typeof rem === "number" ? rem > 0 : false,
      observations: level === 0 ? "" : obs,
    };
  }

  if (event === "updateObservacao") {
    // regra: se for nível 0, tratamos como "confirmado" e paramos o timer
    if (level === 0) {
      return {
        status: "confirmed",
        currentLevel: 0,
        timerActive: false,
        observations: obs,
      };
    }
    // níveis > 0: apenas atualiza observações
    return {
      observations: obs,
    };
  }

  if (event === "updateStatusFinal") {
    const statusFinal = state?.statusFinal;
    return {
      status: "completed",
      timerActive: false,
      isAttended: statusFinal === "attended",
      observations: state[`level${level}_observacao`] ?? "",
    };
  }

  // updateOperador ou outros — não mexe no visual principal
  return {};
}

function toViewFromGetState(item: any): Partial<ChamadoView> {
  if (!item || typeof item !== "object") return {};

  // finalizado?
  if (item.statusFinal === "attended" || item.statusFinal === "not-attended") {
    const lvl = inferCurrentLevelFromItem(item);
    return {
      status: "completed",
      currentLevel: lvl,
      timerActive: false,
      timeRemaining: 0,
      observations: item[`level${lvl}_observacao`] ?? "",
      isAttended: item.statusFinal === "attended",
    };
  }

  // caso não finalizado: pega o nível mais recente
  const lvl = inferCurrentLevelFromItem(item);
  const dur = item[`level${lvl}_duration`];
  const startISO = item[`level${lvl}_timerStart`];
  const obs = item[`level${lvl}_observacao`] ?? "";
  const rem = remainingFromStart(startISO, dur);

  // heurística de status visual
  let status: ChamadoView["status"] = "pending";
  if (lvl === 0) {
    // se tiver observação no nível 0, considera "confirmado"
    status = obs?.trim() ? "confirmed" : "pending";
  } else {
    status = "escalating";
  }

  return {
    status,
    currentLevel: lvl,
    timeRemaining: typeof rem === "number" ? rem : 0,
    timerActive: typeof rem === "number" ? rem > 0 : false,
    observations: obs,
    isAttended: false,
  };
}

/** -----------------------------
 *   WebSocket: init e handlers
 * ----------------------------- */
export const initWebSocket = () => {
  if (socket) return;

  socket = new WebSocket(WS_URL);

  socket.onopen = () => {
    console.log("[WS] Conectado:", WS_URL);
  };

  socket.onmessage = (event) => {
    const raw = event.data;

    // Ignora respostas não-JSON (ex.: "Timer iniciado")
    if (typeof raw !== "string" || !raw.trim().startsWith("{")) {
      // opcional: console.debug("[WS] Ack/Texto ignorado:", raw);
      return;
    }

    let msg: any;
    try {
      msg = JSON.parse(raw);
    } catch (e) {
      console.warn("[WS] JSON inválido:", raw);
      return;
    }

    // Broadcast da Lambda tem { event, chamado, level, state }
    if (msg && typeof msg === "object" && "event" in msg) {
      const chamado = String(msg.chamado);
      const partial = toViewFromBroadcast(msg);
      useChamadoStore.getState().setFromWS(chamado, partial);
      return;
    }

    // Resposta do getState (a Lambda retorna o Item direto no body)
    if (msg && typeof msg === "object" && ("chamado" in msg)) {
      const chamado = String(msg.chamado);
      const partial = toViewFromGetState(msg);
      useChamadoStore.getState().setFromWS(chamado, partial);
      return;
    }

    // Demais casos — ignorar silenciosamente
    // console.debug("[WS] Mensagem ignorada:", msg);
  };

  socket.onclose = () => {
    console.log("[WS] Fechada. Reabrindo em 3s…");
    socket = null;
    setTimeout(initWebSocket, 3000);
  };

  socket.onerror = (err) => {
    console.error("[WS] Erro:", err);
    socket?.close();
  };
};

export const sendWS = (payload: any) => {
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify(payload));
  } else {
    console.warn("[WS] Socket não conectado. Payload perdido:", payload);
  }
};

/** -----------------------------
 *   Wrappers de ação (convenientes)
 * ----------------------------- */
export const wsStartTimer = (chamado: number, level: number, duration?: number) => {
  sendWS({ action: "startTimer", chamado, level, ...(duration ? { duration } : {}) });
};
export const wsUpdateObservacao = (chamado: number, level: number, observacao: string) => {
  sendWS({ action: "updateObservacao", chamado, level, observacao });
};
export const wsUpdateStatusFinal = (
  chamado: number,
  status: "attended" | "not-attended"
) => {
  sendWS({ action: "updateStatusFinal", chamado, status });
};
export const wsGetState = (chamado: number) => {
  sendWS({ action: "getState", chamado });
};

/** -----------------------------
 *   Tick global (1s)
 * ----------------------------- */
if (typeof window !== "undefined") {
  setInterval(() => {
    useChamadoStore.getState().tick();
  }, 1000);
}

import React, { useEffect, useState, useRef } from "react";

type TimerData = {
  chamado: number;
  timerActive: boolean;
  startedAt: string | null;
  durationMinutes: number;
  timeRemaining: number;
};

const WEBSOCKET_URL = "wss://SEU_ENDPOINT.execute-api.us-east-1.amazonaws.com/dev"; // substituir
const API_URL = "https://SEU_ENDPOINT.execute-api.us-east-1.com/prod/getState";      // substituir

interface TimerProps {
  chamado: number;
}

const Timer: React.FC<TimerProps> = ({ chamado }) => {
  const [timerData, setTimerData] = useState<TimerData | null>(null);
  const wsRef = useRef<WebSocket | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  // Conecta WebSocket
  useEffect(() => {
    const ws = new WebSocket(WEBSOCKET_URL);
    wsRef.current = ws;

    ws.onopen = () => console.log("✅ WebSocket conectado");
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === "TIMER_UPDATED" && data.chamado === chamado) {
        setTimerData({
          chamado: data.chamado,
          timerActive: data.timerActive,
          startedAt: data.startedAt,
          durationMinutes: data.durationMinutes,
          timeRemaining: data.timeRemaining,
        });
      }
    };
    ws.onclose = () => console.log("❌ WebSocket desconectado");

    return () => ws.close();
  }, [chamado]);

  // Busca estado inicial
  useEffect(() => {
    const fetchState = async () => {
      try {
        const res = await fetch(`${API_URL}?chamado=${chamado}`);
        const data = await res.json();
        setTimerData(data);
      } catch (err) {
        console.error("Erro ao buscar estado inicial:", err);
      }
    };
    fetchState();
  }, [chamado]);

  // Atualiza timer a cada segundo
  useEffect(() => {
    if (!timerData) return;

    if (intervalRef.current) clearInterval(intervalRef.current);

    intervalRef.current = setInterval(() => {
      setTimerData((prev) => {
        if (!prev) return prev;
        if (!prev.timerActive) return prev;

        const startedAtDate = new Date(prev.startedAt!);
        const elapsed = Math.floor((new Date().getTime() - startedAtDate.getTime()) / 1000);
        const remaining = Math.max(prev.durationMinutes * 60 - elapsed, 0);

        return { ...prev, timeRemaining: remaining };
      });
    }, 1000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [timerData?.timerActive]);

  const startTimer = () => {
    wsRef.current?.send(JSON.stringify({ action: "startTimer", chamado }));
  };

  const pauseTimer = () => {
    wsRef.current?.send(JSON.stringify({ action: "pauseTimer", chamado }));
  };

  const formatTime = (seconds: number) => {
    const m = Math.floor(seconds / 60)
      .toString()
      .padStart(2, "0");
    const s = Math.floor(seconds % 60)
      .toString()
      .padStart(2, "0");
    return `${m}:${s}`;
  };

  if (!timerData) return <div>Carregando...</div>;

  return (
    <div>
      <h2>Chamado: {timerData.chamado}</h2>
      <p>Status: {timerData.timerActive ? "Ativo" : "Pausado"}</p>
      <p>Tempo restante: {formatTime(timerData.timeRemaining)}</p>
      <button onClick={startTimer} disabled={timerData.timerActive}>
        Iniciar
      </button>
      <button onClick={pauseTimer} disabled={!timerData.timerActive}>
        Pausar
      </button>
    </div>
  );
};

export default Timer;

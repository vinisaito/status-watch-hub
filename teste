import React, { useState, useCallback } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { ProgressIndicator } from '@/components/ui/progress-indicator';
import { TimerDisplay } from '@/components/ui/timer-display';
import { ArrowRight, CheckCircle, X, AlertTriangle, Lightbulb, MessageSquare, Timer, Building2, Users, Clock, User, Phone } from 'lucide-react';
import { toast } from '@/hooks/use-toast';
import { cn } from '@/lib/utils';

interface ModernTimerModalProps {
  isOpen: boolean;
  onClose: () => void;
  chamado: number;
  currentLevel: number;
  remainingTime: number;
  chamadoData?: any;
  formatTime: (seconds: number) => string;
  onNextLevel: (chamado: number, level: number, observacao: string) => void;
  updateStatusFinal: (chamado: number, levelStatusKey: string, status: string) => void;
  updateObservacao: (chamado: number, level: number, observacao: string) => void;
  updateAcionamento: (chamado: number, level: number, operador: string, pessoaAcionada: string, statusAcionamento: string) => void;

}

const LEVEL_INFO = {
  1: {
    title: "Primeiro Acionamento",
    subtitle: "",
    nextAction: "Avançar para 1ª Escalação",
    icon: Clock,
    color: "from-blue-500 to-blue-600",
    bgColor: "bg-blue-500/5 border-blue-200",
    description: "Atendimento Inicial da Equipe"
  },
  2: {
    title: "1ª Escalação",
    subtitle: "",
    nextAction: "Avançar para 2ª Escalação",
    icon: Users,
    color: "from-orange-500 to-orange-600",
    bgColor: "bg-orange-500/5 border-orange-200",
    description: "Acionamento do Gestor de Incidente ou Plantonista"
  },
  3: {
    title: "2ª Escalação",
    subtitle: "",
    nextAction: "Avançar para 3ª Escalação",
    icon: Building2,
    color: "from-red-500 to-red-600",
    bgColor: "bg-red-500/5 border-red-200",
    description: "Acionamento do Coordenador"
  },
  4: {
    title: "3ª Escalação",
    subtitle: "",
    nextAction: "Avançar para 4ª Escalação",
    icon: Users,
    color: "from-purple-500 to-purple-600",
    bgColor: "bg-purple-500/5 border-purple-200",
    description: "Acionamento do Gerente"
  },
  5: {
    title: "4ª Escalação",
    subtitle: "",
    nextAction: "Finalizar Chamado",
    icon: Building2,
    color: "from-red-600 to-red-700",
    bgColor: "bg-red-600/5 border-red-300",
    description: "Acionamento do Kleber Costa"
  }
};

export const ModernTimerModal: React.FC<ModernTimerModalProps> = ({
  isOpen,
  onClose,
  chamado,
  currentLevel,
  remainingTime,
  chamadoData,
  formatTime,
  onNextLevel,
  updateStatusFinal,
  updateObservacao,
  updateAcionamento
}) => {
  const [observacao, setObservacao] = useState('');
  const [pessoaAcionada, setPessoaAcionada] = useState('');
  const [statusAtendimento, setStatusAtendimento] = useState('');
  const [operador, setOperador] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);

  const levelStatusKey = `level${currentLevel}_status`;
  const [finalizado, setFinalizado] = useState(
    chamadoData?.statusFinal === "finished" || chamadoData?.[levelStatusKey] === "finished"
  );

  React.useEffect(() => {
    setFinalizado(
      chamadoData?.statusFinal === "finished" || chamadoData?.[levelStatusKey] === "finished"
    );
  }, [chamadoData, levelStatusKey]);

  const levelInfo = finalizado
    ? {
      title: "Chamado Finalizado",
      subtitle: "Processo encerrado com sucesso",
      description: "O chamado foi resolvido e encerrado",
      icon: CheckCircle,
      color: "from-success to-success/90",
      bgColor: "bg-success/5 border-success/20",
      nextAction: "Finalizado"
    }
    : LEVEL_INFO[currentLevel as keyof typeof LEVEL_INFO];

  const validateForm = useCallback(() => {
    const errors = [];

    if (!operador) {
      errors.push("Operador é obrigatório");
    }

    if (!pessoaAcionada.trim()) {
      errors.push("Nome da pessoa acionada é obrigatório");
    } else if (pessoaAcionada.trim().length < 2) {
      errors.push("Nome deve ter pelo menos 2 caracteres");
    }

    if (!statusAtendimento) {
      errors.push("Status de atendimento é obrigatório");
    }

    if (!observacao.trim()) {
      errors.push("Observações são obrigatórias");
    } else if (observacao.trim().length < 10) {
      errors.push("Observações devem ter pelo menos 10 caracteres");
    }

    if (errors.length > 0) {
      toast({
        title: "⚠️ Campos Obrigatórios",
        description: errors.join(". "),
        variant: "destructive",
      });
      return false;
    }

    return true;
  }, [operador, pessoaAcionada, statusAtendimento, observacao]);

  const handleAction = useCallback(async (action: 'next' | 'finish') => {
    if (!validateForm()) return;

    setIsProcessing(true);

    try {
      const fullObservacao = `Operador: ${operador}\nPessoa Acionada: ${pessoaAcionada.trim()}\nStatus: ${statusAtendimento}\n\nDetalhes: ${observacao.trim()}`;

      if (finalizado && action !== 'finish') {
        toast({
          title: "⚠️ Chamado já finalizado",
          description: "Não é possível alterar níveis pois o chamado está finalizado",
          variant: "destructive",
        });
        return;
      }

      switch (action) {
        case 'next': {
          const updates = [
            updateStatusFinal(chamado, levelStatusKey, "finished"),
            updateObservacao(chamado, currentLevel, observacao || ""),
            updateAcionamento(chamado, currentLevel, operador || "", pessoaAcionada || "", statusAtendimento || "")
          ];

          if (currentLevel >= 5) {
            await Promise.all(updates);
            toast({
              title: "✅ Chamado Finalizado",
              description: `Chamado ${chamado} foi finalizado com sucesso!`
            });
          } else {
            await Promise.all(updates);
            await onNextLevel(chamado, currentLevel + 1, observacao || "");

            const nextLevelInfo = LEVEL_INFO[(currentLevel + 1) as keyof typeof LEVEL_INFO];
            toast({
              title: `🚀 ${nextLevelInfo?.title} Iniciado`,
              description: `Timer de 20 minutos iniciado para ${nextLevelInfo?.title}`,
            });
          }
          break;
        }

        case 'finish': {
          const updates = [
            updateStatusFinal(chamado, levelStatusKey, "finished"),
            updateObservacao(chamado, currentLevel, observacao || "")
          ];

          if (pessoaAcionada || statusAtendimento || operador) {
            updates.push(
              updateAcionamento(chamado, currentLevel, pessoaAcionada || "", statusAtendimento || "", operador || "")
            );
          }

          await Promise.all(updates);
          setFinalizado(true);
          toast({
            title: "✅ Chamado Finalizado",
            description: `Chamado ${chamado} foi finalizado com sucesso!`,
          });
          break;
        }
      }

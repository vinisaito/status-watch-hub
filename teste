import json
import boto3
import os
import decimal
import uuid
import sys
from datetime import datetime, timedelta

# ---------- Config ----------
dynamodb = boto3.resource("dynamodb", region_name=os.environ.get("AWS_REGION", "us-east-1"))
connections_table = dynamodb.Table(os.environ["CONNECTIONS_TABLE"])  # PK: connectionId (String)
chamados_table = dynamodb.Table(os.environ["CHAMADOS_TABLE"])        # PK: chamado (Number)

# Quando = "1", não chama API Gateway Management (post_to_connection/broadcast)
DISABLE_APIGW_POST = os.environ.get("DISABLE_APIGW_POST", "0") == "1"

# ---------- Utils ----------
class DecimalEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, decimal.Decimal):
            return int(o) if o % 1 == 0 else float(o)
        return super().default(o)

def to_json(data):
    return json.dumps(data, cls=DecimalEncoder, ensure_ascii=False)

TRACE_ID = None
def log(msg, **kwargs):
    """Log estruturado com trace e flush para CloudWatch."""
    global TRACE_ID
    if not TRACE_ID:
        TRACE_ID = str(uuid.uuid4())[:8]
    payload = {"trace": TRACE_ID, "msg": msg}
    payload.update(kwargs)
    print(json.dumps(payload, default=str))
    sys.stdout.flush()

def now_ts():
    return int(datetime.utcnow().timestamp())

def now_iso():
    return datetime.utcnow().isoformat()

def json_response(status:int, body_obj:dict):
    """Garante sempre JSON no body."""
    return {
        "statusCode": status,
        "headers": {"Content-Type": "application/json"},
        "body": to_json(body_obj)
    }

def parse_body_safe(event):
    """
    Faz o parse do body uma única vez e guarda em event['parsedBody'].
    Aceita:
      - dict
      - JSON string -> dict
      - string simples: "getState" -> {"action": "getState"}
    """
    if "parsedBody" in event:
        return event["parsedBody"]

    body_raw = event.get("body")
    body = {}
    if body_raw is None:
        body = {}
    elif isinstance(body_raw, dict):
        body = body_raw
    elif isinstance(body_raw, (bytes, bytearray)):
        try:
            body = json.loads(body_raw.decode("utf-8"))
        except Exception as e:
            log("JSON parse error (bytes?)", error=str(e))
            body = {}
    elif isinstance(body_raw, str):
        try:
            parsed = json.loads(body_raw)
            # pode virar str (ex.: "\"getState\"")
            if isinstance(parsed, str):
                body = {"action": parsed}
            elif isinstance(parsed, dict):
                body = parsed
            else:
                body = {}
        except Exception:
            # se vier como string crua não-JSON: tenta tratar como ação
            body = {"action": body_raw.strip()}
    else:
        body = {}

    event["parsedBody"] = body
    return body

def get_body_field(event, key, default=None):
    body = parse_body_safe(event)
    return body.get(key, default)

def get_apigw_client(event):
    rc = event["requestContext"]
    endpoint_url = f"https://{rc['domainName']}/{rc['stage']}"
    log("get_apigw_client", endpoint_url=endpoint_url)
    return boto3.client("apigatewaymanagementapi", endpoint_url=endpoint_url)

def send_to_connection(apigw, connection_id, message: dict):
    """Envia uma mensagem JSON para UMA conexão. Remove conexões mortas."""
    if DISABLE_APIGW_POST:
        log("post_to_connection SKIPPED (DISABLE_APIGW_POST=1)",
            connectionId=connection_id, action=message.get("action"))
        return True
    try:
        apigw.post_to_connection(Data=to_json(message), ConnectionId=connection_id)
        log("post_to_connection OK", connectionId=connection_id, action=message.get("action"))
        return True
    except apigw.exceptions.GoneException:
        log("GoneException - removendo conexão", connectionId=connection_id)
        try:
            connections_table.delete_item(Key={"connectionId": connection_id})
        except Exception as e:
            log("erro ao remover conexão Gone", error=str(e))
        return False
    except Exception as e:
        log("post_to_connection ERROR", connectionId=connection_id, error=str(e))
        return False

def broadcast(event, message):
    """Envia a mesma mensagem para TODAS as conexões ativas."""
    if DISABLE_APIGW_POST:
        log("broadcast SKIPPED (DISABLE_APIGW_POST=1)",
            action=message.get("action"), chamado=message.get("chamado"), message=message)
        return json_response(200, {"ok": True, "skipped": True})

    apigw = get_apigw_client(event)
    try:
        scan = connections_table.scan()
        connections = scan.get("Items", [])
        log("broadcast scan OK", total=len(connections))
    except Exception as e:
        log("broadcast scan ERROR", error=str(e))
        return json_response(500, {"error": "erro ao listar conexões"})

    log("broadcast begin", total=len(connections),
        action=message.get("action"), chamado=message.get("chamado"))
    sent = 0
    for conn in connections:
        if send_to_connection(apigw, conn["connectionId"], message):
            sent += 1
    log("broadcast end", sent=sent, total=len(connections))
    return json_response(200, {"ok": True, "sent": sent, "total": len(connections)})

# ---------- Persistência do estado do Chamado ----------
def load_state(chamado:int) -> dict:
    try:
        resp = chamados_table.get_item(Key={"chamado": chamado})
        item = resp.get("Item", {})
        return item or {}
    except Exception as e:
        log("DDB get_item ERROR", error=str(e), chamado=chamado)
        return {}

def save_state(state:dict):
    try:
        chamados_table.put_item(Item=item)
        logger.info(f"[UPDATE] Chamado {chamado_id} salvo no DynamoDB: {item}")
        return True
    except Exception as e:
        logger.error(f"[DynamoDB] Erro ao salvar chamado {chamado_id}: {e}")
        return False

def ensure_initial_state(chamado:int) -> dict:
    st = load_state(chamado)
    if not st:
        st = {
            "chamado": chamado,            # PK (Number)
            "nivelAtual": 0,               # 0=primeiro acionamento; 1..4 = escalacoes
            "statusGeral": "pendente",     # pendente|em_andamento|concluido
            "statusFinal": None,           # attended|not-attended|None
            "niveis": {},                  # "0".. "4" -> dados do nível
            "ultimoUpdate": now_ts()
        }
    return st

def resolve_level(body:dict):
    """
    Suporta:
      - body["nivel"] -> int
      - body["timer"] -> "primeiroAcionado" | "escalacao1".."escalacao4"
    Retorna int 0..4
    """
    if "nivel" in body:
        return int(body["nivel"])
    timer = body.get("timer")
    if timer == "primeiroAcionado":
        return 0
    if isinstance(timer, str) and timer.startswith("escalacao"):
        try:
            n = int(timer.replace("escalacao", ""))
            if 1 <= n <= 4:
                return n
        except Exception:
            pass
    return None

def level_duration_seconds(nivel:int) -> int:
    # Regras: nível 0 => 20min; níveis 1..4 => 10min
    return 20*60 if nivel == 0 else 10*60

# ---------- Handler ----------
def lambda_handler(event, context):
    global TRACE_ID
    TRACE_ID = str(uuid.uuid4())[:8]

    print("=== Lambda Iniciada ===", flush=True)
    print(json.dumps(event, default=str), flush=True)

    # Para chamadas diretas (testes) sem requestContext
    rc = event.get("requestContext")
    if not isinstance(rc, dict):
        log("invalid_test_event_missing_requestContext", eventKeys=list(event.keys()))
        # Permite exercitar rotas com 'route' e 'body'
        route = event.get("route")
        if route:
            log("direct_invoke_route_detected", route=route)
            fake_event = {
                "requestContext": {
                    "routeKey": route,
                    "connectionId": event.get("connectionId", "direct-invoke"),
                    "domainName": event.get("domainName", "example.execute-api.us-east-1.amazonaws.com"),
                    "stage": event.get("stage", "dev"),
                },
                "body": event.get("body")
            }
            parse_body_safe(fake_event)
            return _dispatch(fake_event)
        return json_response(400, {"error": "Evento inválido: faltou requestContext.routeKey"})

    # parse body uma única vez
    parse_body_safe(event)
    return _dispatch(event)

def _dispatch(event):
    route = event["requestContext"]["routeKey"]
    rc = event["requestContext"]
    body = parse_body_safe(event)
    log("invoke", routeKey=route, connectionId=rc.get("connectionId"), body=body)

    try:
        if route == "$connect":
            return on_connect(event)
        elif route == "$disconnect":
            return on_disconnect(event)
        elif route == "getState":
            return get_state(event)
        elif route == "startLevel":
            return start_level(event)
        elif route == "advanceLevel":
            return advance_level(event)
        elif route == "rollbackLevel":
            return rollback_level(event)
        elif route == "setObservation":
            return set_observation(event)
        elif route == "setStatusFinal":
            return set_status_final(event)
        elif route == "complete":
            return complete(event)
        elif route == "$default":
            # Roteamento por body.action quando a rota é $default
            action = body.get("action")
            log("$default received", action=action)
            if action in ("getState", "startLevel", "advanceLevel", "rollbackLevel",
                          "setObservation", "setStatusFinal", "complete"):
                event2 = dict(event)
                event2["requestContext"] = dict(event["requestContext"])
                event2["requestContext"]["routeKey"] = action
                return _dispatch(event2)
            # Não broadcastar nada "vazio" — evita {ok:true} indo ao front
            return json_response(200, {"ok": True, "noop": True})
        else:
            log("rota inválida", route=route)
            return json_response(400, {"error": "rota inválida"})
    except Exception as e:
        log("dispatch ERROR", error=str(e))
        return json_response(500, {"error": str(e)})

# ---------- Rotas WebSocket ----------
def on_connect(event):
    connection_id = event["requestContext"]["connectionId"]
    resp = connections_table.put_item(Item={"connectionId": connection_id, "connectedAt": now_ts()})
    log("on_connect OK", connectionId=connection_id, resp=resp)
    return json_response(200, {"ok": True})

def on_disconnect(event):
    connection_id = event["requestContext"]["connectionId"]
    try:
        resp = connections_table.delete_item(Key={"connectionId": connection_id})
        log("on_disconnect OK", connectionId=connection_id, resp=resp)
    except Exception as e:
        log("on_disconnect ERROR", connectionId=connection_id, error=str(e))
    return json_response(200, {"ok": True})

# ---------- Ações de estado ----------
def start_level(event):
    body = parse_body_safe(event)
    chamado = int(body["chamado"])
    nivel = resolve_level(body)
    if nivel is None:
        return json_response(400, {"error": "nivel/timer inválido ou ausente"})

    observacao = body.get("observacao", "")
    duracao = int(body.get("duracao", level_duration_seconds(nivel)))
    timer_start = now_ts()
    timer_end = timer_start + duracao

    st = ensure_initial_state(chamado)
    st["niveis"][str(nivel)] = {
        "status": "em_andamento",
        "timerStart": timer_start,
        "duracao": duracao,
        "timerEnd": timer_end,
        "observacao": observacao,
    }
    st["nivelAtual"] = nivel
    st["statusGeral"] = "em_andamento"
    st["ultimoUpdate"] = now_ts()

    save_state(st)

    message = {
        "action": "levelStarted",
        "chamado": chamado,
        "serverTime": now_ts(),
        **st
    }
    return broadcast(event, message)

def advance_level(event):
    body = parse_body_safe(event)
    chamado = int(body["chamado"])
    nivel = resolve_level(body)
    if nivel is None:
        return json_response(400, {"error": "nivel/timer inválido ou ausente"})

    # Observação é obrigatória para avançar
    observacao = (body.get("observacao") or "").strip()
    if not observacao:
        return json_response(400, {"error": "observacao obrigatória para avançar"})

    st = ensure_initial_state(chamado)

    # Conclui o nível anterior (se existir)
    prev = st.get("nivelAtual", None)
    if prev is not None:
        prev_key = str(prev)
        prev_level = st["niveis"].get(prev_key)
        if prev_level:
            prev_level["status"] = "concluido"

    # Inicia o novo nível
    duracao = int(body.get("duracao", level_duration_seconds(nivel)))
    timer_start = now_ts()
    timer_end = timer_start + duracao

    st["niveis"][str(nivel)] = {
        "status": "em_andamento",
        "timerStart": timer_start,
        "duracao": duracao,
        "timerEnd": timer_end,
        "observacao": observacao,
    }
    st["nivelAtual"] = nivel
    st["statusGeral"] = "em_andamento"
    st["ultimoUpdate"] = now_ts()

    save_state(st)

    message = {
        "action": "levelAdvanced",
        "chamado": chamado,
        "serverTime": now_ts(),
        **st
    }
    return broadcast(event, message)

def rollback_level(event):
    body = parse_body_safe(event)
    chamado = int(body["chamado"])
    nivel = resolve_level(body)
    if nivel is None:
        return json_response(400, {"error": "nivel/timer inválido ou ausente"})

    # Observação é obrigatória para retroceder
    observacao = (body.get("observacao") or "").strip()
    if not observacao:
        return json_response(400, {"error": "observacao obrigatória para retroceder"})

    st = ensure_initial_state(chamado)

    # Marca o nível atual como pendente (não remove dados de timer)
    lv = st["niveis"].get(str(nivel), {})
    lv["status"] = "pendente"
    lv["observacao"] = observacao
    st["niveis"][str(nivel)] = lv

    st["nivelAtual"] = nivel
    st["ultimoUpdate"] = now_ts()

    save_state(st)

    message = {
        "action": "levelRolledBack",
        "chamado": chamado,
        "serverTime": now_ts(),
        **st
    }
    return broadcast(event, message)

def set_observation(event):
    body = parse_body_safe(event)
    chamado = int(body["chamado"])
    nivel = resolve_level(body)
    if nivel is None:
        return json_response(400, {"error": "nivel/timer inválido ou ausente"})
    observacao = body.get("observacao", "")

    st = ensure_initial_state(chamado)
    lv = st["niveis"].get(str(nivel))
    if not lv:
        # se nível não existe ainda, inicia como pendente com a observação
        lv = {
            "status": "pendente",
            "timerStart": None,
            "duracao": None,
            "timerEnd": None,
            "observacao": observacao,
        }
    else:
        lv["observacao"] = observacao

    st["niveis"][str(nivel)] = lv
    st["ultimoUpdate"] = now_ts()
    save_state(st)

    message = {
        "action": "observationUpdated",
        "chamado": chamado,
        "nivel": nivel,
        "serverTime": now_ts(),
        **st
    }
    return broadcast(event, message)

def set_status_final(event):
    body = parse_body_safe(event)
    chamado = int(body["chamado"])
    status_final = (body.get("statusFinal") or "").strip()
    if status_final not in ("attended", "not-attended"):
        return json_response(400, {"error": "statusFinal deve ser 'attended' ou 'not-attended'"})

    st = ensure_initial_state(chamado)
    st["statusFinal"] = status_final
    st["ultimoUpdate"] = now_ts()
    save_state(st)

    message = {
        "action": "finalStatusUpdated",
        "chamado": chamado,
        "serverTime": now_ts(),
        **st
    }
    return broadcast(event, message)

def complete(event):
    body = parse_body_safe(event)
    chamado = int(body["chamado"])
    observacao = (body.get("observacao") or "").strip()

    st = ensure_initial_state(chamado)
    # Conclui nível atual, se houver
    cur = st.get("nivelAtual", None)
    if cur is not None:
        lv = st["niveis"].get(str(cur))
        if lv:
            lv["status"] = "concluido"
            if observacao:
                lv["observacao"] = observacao
            st["niveis"][str(cur)] = lv

    st["statusGeral"] = "concluido"
    st["ultimoUpdate"] = now_ts()
    save_state(st)

    message = {
        "action": "completed",
        "chamado": chamado,
        "serverTime": now_ts(),
        **st
    }
    return broadcast(event, message)

def get_state(event):
    """Envia o estado atual do chamado APENAS para a conexão solicitante (sem broadcast)."""
    body = parse_body_safe(event)
    chamado = int(body["chamado"])
    connection_id = event["requestContext"]["connectionId"]

    st = ensure_initial_state(chamado)
    apigw = get_apigw_client(event)
    message = {
        "action": "currentState",
        "chamado": chamado,
        "serverTime": now_ts(),
        **st
    }
    log("get_state -> enviando", chamado=chamado, connectionId=connection_id)
    send_to_connection(apigw, connection_id, message)
    return json_response(200, {"ok": True})

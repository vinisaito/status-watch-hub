import React, { useLayoutEffect, useRef, useState, forwardRef } from "react";
import type { ProductLine, RDM } from "@/types/rdm";
import { CheckCircle2, XCircle, Clock } from "lucide-react";
import { cn } from "@/lib/utils";
import { ProductSummary } from "./ProductSummary";

interface RDMTimelineProps {
  productLine: ProductLine;
}

// Local RDMNode component (inlined from ./RDMNode)
interface RDMNodeProps {
  rdm: RDM;
  color: string;
  isFirst?: boolean;
  isLast?: boolean;
  productLineId?: string;
}

const RDMNode = forwardRef<HTMLDivElement, RDMNodeProps>(
  ({ rdm, color, isFirst, isLast, productLineId }: RDMNodeProps, ref) => {
    const isEpsilon = productLineId === "produto-5";
    const showSideInfo =
      rdm.number === "008" ||
      rdm.number === "016" ||
      (isEpsilon && rdm.number === "024");
    const sideIsLeft = rdm.number === "016";
    const sideIsRight = rdm.number === "008" || (isEpsilon && rdm.number === "024");

    const getStatusIcon = () => {
      switch (rdm.status) {
        case "executed":
          return <CheckCircle2 className="w-5 h-5" />;
        case "failed":
          return <XCircle className="w-5 h-5" />;
        case "pending":
          return <Clock className="w-5 h-5" />;
      }
    };

    const getStatusColor = () => {
      switch (rdm.status) {
        case "executed":
          return "rdm-node-success";
        case "failed":
          return "rdm-node-error";
        case "pending":
          return "rdm-node-pending";
      }
    };

    const getStatusShadow = () => {
      switch (rdm.status) {
        case "executed":
          return `var(--rdm-node-shadow) hsl(var(--rdm-success) / 0.25)`;
        case "failed":
          return `var(--rdm-node-shadow) hsl(var(--rdm-error) / 0.25)`;
        case "pending":
          return `var(--rdm-node-shadow) hsl(var(--rdm-pending) / 0.15)`;
      }
    };

    return (
      <div className="relative flex flex-col items-center gap-2 group">
        <div className="relative z-10" ref={ref}>
          <div
            className={cn(
              "w-12 h-12 rounded-full border-[3px] flex items-center justify-center",
              "rdm-node-hover cursor-pointer backdrop-blur-sm",
              "hover:shadow-2xl",
              getStatusColor()
            )}
            style={{
              borderColor: rdm.status === "pending" ? color : undefined,
              boxShadow: getStatusShadow(),
            }}
          >
            {getStatusIcon()}
          </div>
        </div>

        <div
          className={cn(
            "flex flex-col items-center gap-1.5 mt-2",
            showSideInfo && "absolute top-1/2 -translate-y-1/2 z-10 mt-0",
            showSideInfo && sideIsRight && "left-full ml-4 items-start",
            showSideInfo && sideIsLeft && "right-full mr-4 items-end"
          )}
        >
          <div
            className="font-bold text-sm px-3 py-1.5 rounded-full whitespace-nowrap rdm-badge-glow"
            style={{
              backgroundColor: `${color}20`,
              color: color,
              border: `1.5px solid ${color}40`,
            }}
          >
            {rdm.number}
          </div>
          <div className="text-xs font-semibold text-muted-foreground bg-card/80 backdrop-blur-sm px-3 py-1 rounded-lg border border-border shadow-md">
            {rdm.time}
          </div>
        </div>

        {rdm.description && (
          <div className="absolute top-full mt-20 opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 pointer-events-none group-hover:pointer-events-auto transform group-hover:-translate-y-1">
            <div className="bg-card/95 backdrop-blur-md border-2 border-border rounded-xl p-4 shadow-2xl min-w-[200px] max-w-[280px]">
              <p className="text-sm text-foreground leading-relaxed">{rdm.description}</p>
            </div>
          </div>
        )}
      </div>
    );
  }
);

RDMNode.displayName = "RDMNode";

export const RDMTimeline: React.FC<RDMTimelineProps> = ({ productLine }) => {
  const nodesPerRow = 8;
  const rows = Math.ceil(productLine.rdms.length / nodesPerRow);
  const containerRef = useRef<HTMLDivElement | null>(null);
  const nodeRefs = useRef<Array<HTMLDivElement | null>>([]);
  const [linePositions, setLinePositions] = useState<
    Array<{ x1: number; y1: number; x2: number; y2: number }>
  >([]);

  if (nodeRefs.current.length !== productLine.rdms.length) {
    nodeRefs.current = Array(productLine.rdms.length).fill(null);
  }

  const recalcPositions = () => {
    if (!containerRef.current) return;
    const containerRect = containerRef.current.getBoundingClientRect();
    const positions: Array<{ x: number; y: number; ok: boolean }> = nodeRefs.current.map((el) => {
      if (!el) return { x: 0, y: 0, ok: false };
      const rect = el.getBoundingClientRect();
      return {
        x: rect.left - containerRect.left + rect.width / 2,
        y: rect.top - containerRect.top + rect.height / 2,
        ok: rect.width > 0 && rect.height > 0,
      };
    });

    const lines: Array<{ x1: number; y1: number; x2: number; y2: number }> = [];
    for (let i = 0; i < positions.length - 1; i++) {
      const p1 = positions[i];
      const p2 = positions[i + 1];
      if (p1.ok && p2.ok) {
        lines.push({ x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y });
      }
    }
    setLinePositions(lines);
  };

  useLayoutEffect(() => {
    recalcPositions();
    const onResize = () => recalcPositions();
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  }, [productLine.rdms.length, nodesPerRow]);

  return (
    <div className="mb-16 last:mb-0">
      <div className="mb-8">
        <h3 
          className="text-2xl font-bold tracking-tight"
          style={{
            color: productLine.color,
            textShadow: `0 2px 8px ${productLine.color}20`
          }}
        >
          {productLine.name}
        </h3>
      </div>

      <div className="relative w-full mb-6 bg-card/40 backdrop-blur-sm rounded-2xl border border-border/50 shadow-lg overflow-hidden" ref={containerRef}>
        <svg className="absolute inset-0 w-full h-full pointer-events-none" style={{ zIndex: 1 }}>
          <defs>
            <linearGradient id={`gradient-${productLine.id}`} x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stopColor={productLine.color} stopOpacity="0.6" />
              <stop offset="50%" stopColor={productLine.color} stopOpacity="0.8" />
              <stop offset="100%" stopColor={productLine.color} stopOpacity="0.6" />
            </linearGradient>
            <filter id={`glow-${productLine.id}`}>
              <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
              <feMerge>
                <feMergeNode in="coloredBlur"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          {linePositions.map((pos, index) => (
            <line
              key={`line-${index}`}
              x1={pos.x1}
              y1={pos.y1}
              x2={pos.x2}
              y2={pos.y2}
              stroke={`url(#gradient-${productLine.id})`}
              strokeWidth={3}
              strokeLinecap="round"
              filter={`url(#glow-${productLine.id})`}
              style={{
                transition: "all 0.3s ease-in-out"
              }}
            />
          ))}
        </svg>

        <div
          className="relative grid gap-x-6 gap-y-10 p-8"
          style={{
            gridTemplateColumns: `repeat(${nodesPerRow}, 1fr)`,
            minHeight: `${rows * 160}px`,
            zIndex: 10,
          }}
        >
          {productLine.rdms.map((rdm, index) => {
            const row = Math.floor(index / nodesPerRow);
            const col = index % nodesPerRow;
            const isRightToLeft = row % 2 === 1;
            const gridCol = isRightToLeft ? nodesPerRow - col : col + 1;

            return (
              <div
                key={rdm.id}
                style={{ gridColumn: gridCol, gridRow: row + 1 }}
                className="flex justify-center"
              >
                <RDMNode
                  ref={(el) => (nodeRefs.current[index] = el)}
                  rdm={rdm}
                  color={productLine.color}
                  isFirst={index === 0}
                  isLast={index === productLine.rdms.length - 1}
                  productLineId={productLine.id}
                />
              </div>
            );
          })}
        </div>
      </div>

      <ProductSummary productLine={productLine} />
    </div>
  );
};

export { RDMNode };
export default RDMTimeline;

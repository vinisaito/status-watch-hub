import React, { useLayoutEffect, useRef, useState, forwardRef } from "react";
import type { ProductLine, RDM } from "@/types/rdm";
import { CheckCircle2, XCircle, Clock } from "lucide-react";
import { cn } from "@/lib/utils";
import { ProductSummary } from "./ProductSummary";

interface RDMTimelineProps {
  productLine: ProductLine;
}

interface RDMNodeProps {
  rdm: RDM;
  color: string;
  isFirst?: boolean;
  isLast?: boolean;
  productLineId?: string;
  index: number;
}

const RDMNode = forwardRef<HTMLDivElement, RDMNodeProps>(
  ({ rdm, color, isFirst, isLast, productLineId, index }: RDMNodeProps, ref) => {
    const isEpsilon = productLineId === "produto-5";
    const showSideInfo =
      rdm.number === "008" ||
      rdm.number === "016" ||
      (isEpsilon && rdm.number === "024");
    const sideIsLeft = rdm.number === "016";
    const sideIsRight = rdm.number === "008" || (isEpsilon && rdm.number === "024");

    const getStatusIcon = () => {
      switch (rdm.status) {
        case "executed":
          return <CheckCircle2 className="w-5 h-5" />;
        case "failed":
          return <XCircle className="w-5 h-5" />;
        case "pending":
          return <Clock className="w-5 h-5" />;
      }
    };

    const getStatusStyles = () => {
      switch (rdm.status) {
        case "executed":
          return {
            bg: "bg-gradient-to-br from-green-50 to-emerald-100",
            border: "border-green-400",
            text: "text-green-600",
            glow: "shadow-[0_0_20px_rgba(34,197,94,0.3)]",
          };
        case "failed":
          return {
            bg: "bg-gradient-to-br from-red-50 to-rose-100",
            border: "border-red-400",
            text: "text-red-600",
            glow: "shadow-[0_0_20px_rgba(239,68,68,0.3)]",
          };
        case "pending":
          return {
            bg: "bg-gradient-to-br from-slate-50 to-slate-100",
            border: "border-slate-300",
            text: "text-slate-500",
            glow: "",
          };
      }
    };

    const statusStyles = getStatusStyles();

    return (
      <div
        className="relative flex flex-col items-center gap-2 group"
        style={{
          animation: `fade-in-up 0.6s ease-out ${index * 0.05}s both`,
        }}
      >
        <div className="relative z-10" ref={ref}>
          <div
            className={cn(
              "w-12 h-12 rounded-full border-[3px] flex items-center justify-center",
              "transition-all duration-500 cursor-pointer",
              "hover:scale-125 hover:rotate-12",
              statusStyles.bg,
              statusStyles.border,
              statusStyles.text,
              statusStyles.glow
            )}
            style={{
              borderColor: rdm.status === "pending" ? color : undefined,
            }}
          >
            <div className="transition-transform duration-300 group-hover:scale-110">
              {getStatusIcon()}
            </div>
          </div>
          
          {/* Pulsing ring animation for pending items */}
          {rdm.status === "pending" && (
            <div
              className="absolute inset-0 rounded-full animate-pulse-glow pointer-events-none"
              style={{
                border: `2px solid ${color}`,
                opacity: 0.3,
              }}
            />
          )}
        </div>

        <div
          className={cn(
            "flex flex-col items-center gap-1 mt-2 transition-all duration-300",
            showSideInfo && "absolute top-1/2 -translate-y-1/2 z-10 mt-0",
            showSideInfo && sideIsRight && "left-full ml-4 items-start",
            showSideInfo && sideIsLeft && "right-full mr-4 items-end"
          )}
        >
          <div
            className="font-bold text-xs px-3 py-1.5 rounded-full whitespace-nowrap shadow-md transition-all duration-300 hover:shadow-lg hover:scale-105"
            style={{
              background: `linear-gradient(135deg, ${color}15, ${color}35)`,
              color: color,
              border: `1.5px solid ${color}40`,
            }}
          >
            {rdm.number}
          </div>
          <div className="text-xs font-semibold text-muted-foreground bg-card/80 backdrop-blur-sm px-3 py-1 rounded-full border border-border shadow-sm transition-all duration-300 hover:shadow-md hover:scale-105">
            {rdm.time}
          </div>
        </div>

        {rdm.description && (
          <div className="absolute top-full mt-24 opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 pointer-events-none group-hover:pointer-events-auto transform translate-y-2 group-hover:translate-y-0">
            <div className="bg-card/95 backdrop-blur-md border border-border/50 rounded-xl p-4 shadow-2xl min-w-[200px] max-w-[280px]">
              <div className="absolute -top-2 left-1/2 -translate-x-1/2 w-4 h-4 bg-card/95 border-l border-t border-border/50 rotate-45" />
              <p className="text-xs leading-relaxed text-foreground/90">{rdm.description}</p>
            </div>
          </div>
        )}
      </div>
    );
  }
);

RDMNode.displayName = "RDMNode";

export const RDMTimeline: React.FC<RDMTimelineProps> = ({ productLine }) => {
  const nodesPerRow = 8;
  const rows = Math.ceil(productLine.rdms.length / nodesPerRow);
  const containerRef = useRef<HTMLDivElement | null>(null);
  const nodeRefs = useRef<Array<HTMLDivElement | null>>([]);
  const [linePositions, setLinePositions] = useState<
    Array<{ x1: number; y1: number; x2: number; y2: number }>
  >([]);

  if (nodeRefs.current.length !== productLine.rdms.length) {
    nodeRefs.current = Array(productLine.rdms.length).fill(null);
  }

  const recalcPositions = () => {
    if (!containerRef.current) return;
    const containerRect = containerRef.current.getBoundingClientRect();
    const positions: Array<{ x: number; y: number; ok: boolean }> = nodeRefs.current.map((el) => {
      if (!el) return { x: 0, y: 0, ok: false };
      const rect = el.getBoundingClientRect();
      return {
        x: rect.left - containerRect.left + rect.width / 2,
        y: rect.top - containerRect.top + rect.height / 2,
        ok: rect.width > 0 && rect.height > 0,
      };
    });

    const lines: Array<{ x1: number; y1: number; x2: number; y2: number }> = [];
    for (let i = 0; i < positions.length - 1; i++) {
      const p1 = positions[i];
      const p2 = positions[i + 1];
      if (p1.ok && p2.ok) {
        lines.push({ x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y });
      }
    }
    setLinePositions(lines);
  };

  useLayoutEffect(() => {
    recalcPositions();
    const onResize = () => recalcPositions();
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  }, [productLine.rdms.length, nodesPerRow]);

  return (
    <div className="mb-16 last:mb-0">
      <div className="mb-8">
        <h3 className="text-2xl font-bold text-foreground tracking-tight">{productLine.name}</h3>
      </div>

      <div className="relative w-full mb-6" ref={containerRef}>
        <svg className="absolute inset-0 w-full h-full pointer-events-none" style={{ zIndex: 0 }}>
          <defs>
            <linearGradient id={`gradient-${productLine.id}`} x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stopColor={productLine.color} stopOpacity="0.3" />
              <stop offset="50%" stopColor={productLine.color} stopOpacity="0.6" />
              <stop offset="100%" stopColor={productLine.color} stopOpacity="0.3" />
            </linearGradient>
            <filter id={`glow-${productLine.id}`}>
              <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
              <feMerge>
                <feMergeNode in="coloredBlur"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          {linePositions.map((pos, index) => (
            <g key={`line-${index}`}>
              {/* Shadow line for depth */}
              <line
                x1={pos.x1}
                y1={pos.y1}
                x2={pos.x2}
                y2={pos.y2}
                stroke={productLine.color}
                strokeWidth={4}
                strokeLinecap="round"
                opacity={0.2}
                style={{
                  filter: `url(#glow-${productLine.id})`,
                }}
              />
              {/* Main line */}
              <line
                x1={pos.x1}
                y1={pos.y1}
                x2={pos.x2}
                y2={pos.y2}
                stroke={`url(#gradient-${productLine.id})`}
                strokeWidth={3}
                strokeLinecap="round"
                style={{
                  strokeDasharray: 1000,
                  animation: `draw-line 1.5s ease-in-out ${index * 0.1}s forwards`,
                }}
              />
            </g>
          ))}
        </svg>

        <div
          className="relative grid gap-x-6 gap-y-12 py-12"
          style={{
            gridTemplateColumns: `repeat(${nodesPerRow}, 1fr)`,
            minHeight: `${rows * 160}px`,
            zIndex: 1,
          }}
        >
          {productLine.rdms.map((rdm, index) => {
            const row = Math.floor(index / nodesPerRow);
            const col = index % nodesPerRow;
            const isRightToLeft = row % 2 === 1;
            const gridCol = isRightToLeft ? nodesPerRow - col : col + 1;

            return (
              <div
                key={rdm.id}
                style={{ gridColumn: gridCol, gridRow: row + 1 }}
                className="flex justify-center"
              >
                <RDMNode
                  ref={(el) => (nodeRefs.current[index] = el)}
                  rdm={rdm}
                  color={productLine.color}
                  isFirst={index === 0}
                  isLast={index === productLine.rdms.length - 1}
                  productLineId={productLine.id}
                  index={index}
                />
              </div>
            );
          })}
        </div>
      </div>

      <ProductSummary productLine={productLine} />
    </div>
  );
};

export default RDMTimeline;

// src/store/useChamadoStore.ts
import { create } from "zustand";

/** ===== Tipos de visualização no front ===== */
export interface ChamadoView {
  status: "pending" | "confirmed" | "escalating" | "completed";
  currentLevel: number;    // 0..4
  timeRemaining: number;   // segundos
  timerActive: boolean;
  observations: string;    // observação do nível atual
  isAttended: boolean;     // statusFinal === "attended"
}

interface StoreShape {
  chamados: Record<string, ChamadoView>;
  initChamado: (id: string) => void;
  updateChamado: (id: string, data: Partial<ChamadoView>) => void;
  setFromWS: (id: string, data: Partial<ChamadoView>) => void;
  tick: () => void;
  reset: () => void;
}

/** ===== Singleton helpers (evita duplicações no HMR) ===== */
declare global {
  // eslint-disable-next-line no-var
  var __CHAMADO_WS__: WebSocket | null | undefined;
  // eslint-disable-next-line no-var
  var __CHAMADO_TICK__: number | undefined;
}
const getWS = () =>
  typeof window !== "undefined" ? (window as any).__CHAMADO_WS__ ?? null : null;
const setWS = (ws: WebSocket | null) => {
  if (typeof window !== "undefined") (window as any).__CHAMADO_WS__ = ws;
};
const getTick = () =>
  typeof window !== "undefined" ? (window as any).__CHAMADO_TICK__ : undefined;
const setTick = (id: number) => {
  if (typeof window !== "undefined") (window as any).__CHAMADO_TICK__ = id;
};

/** ===== URL do WebSocket ===== */
const WS_URL =
  process.env.NEXT_PUBLIC_WS_URL ||
  "wss://rsgjd6wsza.execute-api.us-east-1.amazonaws.com/dev";

/** ===== Store (Zustand) ===== */
export const useChamadoStore = create<StoreShape>((set, get) => ({
  chamados: {},

  initChamado: (id: string) =>
    set((state) => {
      if (state.chamados[id]) return state;
      return {
        chamados: {
          ...state.chamados,
          [id]: {
            status: "pending",
            currentLevel: 0,
            timeRemaining: 1200, // 20 min p/ nível 0
            timerActive: false,
            observations: "",
            isAttended: false,
          },
        },
      };
    }),

  updateChamado: (id, data) =>
    set((state) => ({
      chamados: {
        ...state.chamados,
        [id]: { ...(state.chamados[id] || {}), ...data },
      },
    })),

  setFromWS: (id, data) =>
    set((state) => ({
      chamados: {
        ...state.chamados,
        [id]: { ...(state.chamados[id] || {}), ...data },
      },
    })),

  tick: () =>
    set((state) => {
      const next: Record<string, ChamadoView> = {};
      for (const [id, c] of Object.entries(state.chamados)) {
        if (c.timerActive && c.timeRemaining > 0) {
          next[id] = { ...c, timeRemaining: c.timeRemaining - 1 };
        } else if (c.timerActive && c.timeRemaining <= 0) {
          next[id] = { ...c, timeRemaining: 0, timerActive: false };
        } else {
          next[id] = c;
        }
      }
      return { chamados: next };
    }),

  reset: () => set({ chamados: {} }),
}));

/** ===== Helpers de mapeamento (Lambda → Store) ===== */
function remainingFromStart(iso?: string, duration?: number): number | undefined {
  if (!iso || typeof duration !== "number") return undefined;
  const startSec = Math.floor(new Date(iso).getTime() / 1000);
  const nowSec = Math.floor(Date.now() / 1000);
  return Math.max(0, startSec + duration - nowSec);
}

function inferCurrentLevelFromItem(item: any): number {
  let bestLevel = 0;
  let bestStart = 0;
  for (let lvl = 0; lvl <= 4; lvl++) {
    const ts = item?.[`level${lvl}_timerStart`];
    if (typeof ts === "string") {
      const t = new Date(ts).getTime();
      if (t > bestStart) {
        bestStart = t;
        bestLevel = lvl;
      }
    }
  }
  return bestLevel;
}

function toViewFromBroadcast(msg: any): Partial<ChamadoView> {
  const event = msg?.event as string | undefined;
  const level = Number(msg?.level ?? 0);
  const state = msg?.state || {};
  const dur = state[`level${level}_duration`];
  const startISO = state[`level${level}_timerStart`];
  const obs = state[`level${level}_observacao`] ?? "";

  if (event === "startTimer") {
    const rem = remainingFromStart(startISO, dur);
    return {
      status: level === 0 ? "pending" : "escalating",
      currentLevel: level,
      timeRemaining: typeof rem === "number" ? rem : 0,
      timerActive: typeof rem === "number" ? rem > 0 : false,
      observations: level === 0 ? "" : obs,
    };
  }

  if (event === "updateObservacao") {
    if (level === 0) {
      // confirmação = observação no nível 0
      return {
        status: "confirmed",
        currentLevel: 0,
        timerActive: false,
        observations: obs,
      };
    }
    return { observations: obs };
  }

  if (event === "updateStatusFinal") {
    const statusFinal = state?.statusFinal;
    const lvl = inferCurrentLevelFromItem(state);
    return {
      status: "completed",
      timerActive: false,
      isAttended: statusFinal === "attended",
      currentLevel: lvl,
      observations: state[`level${lvl}_observacao`] ?? "",
      timeRemaining: 0,
    };
  }

  return {};
}

function toViewFromGetState(item: any): Partial<ChamadoView> {
  if (!item || typeof item !== "object") return {};
  if (item.statusFinal === "attended" || item.statusFinal === "not-attended") {
    const lvl = inferCurrentLevelFromItem(item);
    return {
      status: "completed",
      currentLevel: lvl,
      timerActive: false,
      timeRemaining: 0,
      observations: item[`level${lvl}_observacao`] ?? "",
      isAttended: item.statusFinal === "attended",
    };
  }
  const lvl = inferCurrentLevelFromItem(item);
  const dur = item[`level${lvl}_duration`];
  const startISO = item[`level${lvl}_timerStart`];
  const obs = item[`level${lvl}_observacao`] ?? "";
  const rem = remainingFromStart(startISO, dur);

  let status: ChamadoView["status"] = "pending";
  status = lvl === 0 ? (obs?.trim() ? "confirmed" : "pending") : "escalating";

  return {
    status,
    currentLevel: lvl,
    timeRemaining: typeof rem === "number" ? rem : 0,
    timerActive: typeof rem === "number" ? rem > 0 : false,
    observations: obs,
    isAttended: false,
  };
}

/** ===== WebSocket: init e handlers ===== */
export const initWebSocket = () => {
  if (typeof window === "undefined") return;
  if (getWS()) return;

  const ws = new WebSocket(WS_URL);
  setWS(ws);

  ws.onopen = () => {
    console.log("[WS] Conectado:", WS_URL);
  };

  ws.onmessage = (event) => {
    const raw = event.data;

    // Ignora mensagens não-JSON (ex.: "Timer iniciado")
    if (typeof raw !== "string" || !raw.trim().startsWith("{")) return;

    let msg: any;
    try {
      msg = JSON.parse(raw);
    } catch {
      return;
    }

    // Broadcast: { event, chamado, level, state }
    if (msg && typeof msg === "object" && "event" in msg) {
      const chamado = String(msg.chamado);
      const partial = toViewFromBroadcast(msg);
      useChamadoStore.getState().setFromWS(chamado, partial);
      return;
    }

    // Resposta do getState: é o item do DDB (inclui "chamado")
    if (msg && typeof msg === "object" && "chamado" in msg) {
      const chamado = String(msg.chamado);
      const partial = toViewFromGetState(msg);
      useChamadoStore.getState().setFromWS(chamado, partial);
      return;
    }
  };

  ws.onclose = () => {
    console.log("[WS] Fechada. Reabrindo em 3s…");
    setWS(null);
    setTimeout(initWebSocket, 3000);
  };

  ws.onerror = (err) => {
    console.error("[WS] Erro:", err);
    ws.close();
  };

  // Intervalo global (1s) — singleton
  if (!getTick()) {
    const id = window.setInterval(() => {
      useChamadoStore.getState().tick();
    }, 1000);
    setTick(id);
  }
};

export const sendWS = (payload: any) => {
  const ws = getWS();
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify(payload));
  } else {
    console.warn("[WS] Socket não conectado. Payload:", payload);
  }
};

/** ===== Wrappers convenientes ===== */
export const wsStartTimer = (chamado: number, level: number, duration?: number) => {
  sendWS({ action: "startTimer", chamado, level, ...(duration ? { duration } : {}) });
};
export const wsUpdateObservacao = (chamado: number, level: number, observacao: string) => {
  sendWS({ action: "updateObservacao", chamado, level, observacao });
};
export const wsUpdateStatusFinal = (
  chamado: number,
  status: "attended" | "not-attended"
) => {
  sendWS({ action: "updateStatusFinal", chamado, status });
};
export const wsGetState = (chamado: number) => {
  sendWS({ action: "getState", chamado });
};

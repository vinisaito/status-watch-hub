import { create } from "zustand";

export type EscalationStatus = "pending" | "confirmed" | "escalating" | "completed";

export interface EscalationState {
  status: EscalationStatus;
  currentLevel: 0 | 1 | 2 | 3 | 4;
  timeRemaining: number;
  timerActive: boolean;
  isAttended: boolean;
  observations: string;
}

type AnyLevel = 0 | 1 | 2 | 3 | 4;

interface ChamadoStore {
  chamados: Record<string, EscalationState>;
  socket: WebSocket | null;
  initWebSocket: (url?: string) => void;

  // envio para o backend
  sendStartTimer: (chamado: string | number, level: AnyLevel, durationSec?: number) => void;
  sendUpdateObservacao: (chamado: string | number, level: AnyLevel, observacao: string) => void;
  sendUpdateOperador: (chamado: string | number, operador: string) => void;
  sendUpdateStatusFinal: (chamado: string | number, status: "attended" | "not-attended", obs?: string, level?: AnyLevel) => void;
  requestState: (chamado: string | number) => void;

  // local
  updateLocal: (chamado: string, patch: Partial<EscalationState>) => void;
  tick: () => void;
}

// 👉 coloque aqui seu endpoint WSS (ou passe na initWebSocket(url))
const DEFAULT_WS_URL = "wss://SEU-ENDPOINT.execute-api.us-east-1.amazonaws.com/dev";

// ---- helpers de cálculo (mapeando o estado vindo da Lambda “simples”) ----
function secRemainingFromItem(item: any, level: number): number {
  const startStr = item?.[`level${level}_timerStart`];
  const dur = Number(item?.[`level${level}_duration`] ?? 0);
  if (!startStr || !dur) return 0;
  const started = Date.parse(startStr);
  if (Number.isNaN(started)) return 0;
  const elapsed = Math.max(0, Math.floor((Date.now() - started) / 1000));
  return Math.max(0, dur - elapsed);
}

function stateFromDdbItem(item: any, level: AnyLevel): EscalationState {
  const remaining = secRemainingFromItem(item, level);
  const obs = String(item?.[`level${level}_observacao`] ?? "");
  const statusFinal = item?.statusFinal; // "attended" | "not-attended" | undefined

  let status: EscalationStatus = "pending";
  if (statusFinal) status = "completed";
  else if (level > 0 && (item?.[`level${level}_status`] === "running" || remaining > 0)) status = "escalating";
  else if (level === 0 && obs) status = "confirmed";
  else status = "pending";

  return {
    status,
    currentLevel: level,
    timeRemaining: remaining,
    timerActive: remaining > 0,
    isAttended: statusFinal === "attended",
    observations: obs,
  };
}

export const useChamadoStore = create<ChamadoStore>((set, get) => {
  // ticker único por módulo
  if (typeof window !== "undefined" && !(window as any).__chamadoTicker) {
    (window as any).__chamadoTicker = setInterval(() => {
      get().tick();
    }, 1000);
  }

  const wsSend = (payload: any) => {
    const { socket } = get();
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(payload));
    } else {
      console.warn("[WS] não conectado. payload não enviado:", payload);
    }
  };

  const applyEvent = (data: any) => {
    // Formato esperado da Lambda “simples”:
    // { event: "startTimer" | "updateObservacao" | "updateOperador" | "updateStatusFinal", chamado, level?, state }
    const ev = data?.event;
    const chamadoNum = data?.chamado;
    if (typeof chamadoNum !== "number") return;

    const id = String(chamadoNum);
    const ddbItem = data?.state ?? {};
    const level: AnyLevel =
      typeof data?.level === "number" ? Math.max(0, Math.min(4, data.level)) as AnyLevel : 0;

    // mapeia sempre com base no item completo vindo da Lambda
    const mapped = stateFromDdbItem(ddbItem, level);

    // Regras extras por evento:
    if (ev === "updateObservacao" && level === 0 && mapped.observations) {
      // ao atualizar observação do nível 0, marcamos como confirmado
      mapped.status = "confirmed";
      mapped.timerActive = false;
      mapped.timeRemaining = Math.max(0, mapped.timeRemaining);
    }
    if (ev === "updateStatusFinal") {
      mapped.status = "completed";
      mapped.timerActive = false;
      mapped.timeRemaining = 0;
    }

    set((state) => ({
      chamados: {
        ...state.chamados,
        [id]: {
          ...(state.chamados[id] ?? mapped),
          ...mapped,
        },
      },
    }));
  };

  return {
    chamados: {},
    socket: null,

    initWebSocket: (url?: string) => {
      if (get().socket) return;
      const ws = new WebSocket(url || DEFAULT_WS_URL);

      ws.onopen = () => {
        console.log("[WS] conectado");
      };
      ws.onmessage = (event) => {
        try {
          if (!event.data) return;
          const msg = typeof event.data === "string" ? JSON.parse(event.data) : event.data;
          if (msg?.event) {
            applyEvent(msg);
          } else if (msg?.body) {
            // caso raro: getState retornando body com o item puro
            // tente mapear nível atual pelo maior level com _status "running"
            const item = typeof msg.body === "string" ? JSON.parse(msg.body) : msg.body;
            const ch = item?.chamado ?? item?.id;
            if (typeof ch === "number") {
              let guessLevel: AnyLevel = 0;
              for (let L = 4; L >= 0; L--) {
                if (item[`level${L}_status`] === "running" || item[`level${L}_timerStart`]) {
                  guessLevel = L as AnyLevel;
                  break;
                }
              }
              applyEvent({ event: "getState", chamado: ch, level: guessLevel, state: item });
            }
          } else {
            // ACKs ou mensagens que não interessam
          }
        } catch (e) {
          console.error("[WS] erro ao processar mensagem", e, event.data);
        }
      };
      ws.onclose = () => {
        console.log("[WS] desconectado. tentando reconectar em 2s");
        set({ socket: null });
        setTimeout(() => get().initWebSocket(url), 2000);
      };
      ws.onerror = (e) => {
        console.error("[WS] erro", e);
        ws.close();
      };

      set({ socket: ws });
    },

    sendStartTimer: (chamado, level, durationSec) => {
      const id = Number(chamado);
      const dur =
        typeof durationSec === "number"
          ? durationSec
          : level === 0
          ? 20 * 60
          : 10 * 60;

      wsSend({
        action: "startTimer",
        chamado: id,
        level,
        duration: dur,
      });
    },

    sendUpdateObservacao: (chamado, level, observacao) => {
      const id = Number(chamado);
      wsSend({
        action: "updateObservacao",
        chamado: id,
        level,
        observacao,
      });
    },

    sendUpdateOperador: (chamado, operador) => {
      const id = Number(chamado);
      wsSend({
        action: "updateOperador",
        chamado: id,
        operador,
      });
    },

    sendUpdateStatusFinal: (chamado, status, obs, level) => {
      const id = Number(chamado);
      // Se vier observação junto, grava também (nível atual ou informado)
      if (obs && typeof level === "number") {
        wsSend({
          action: "updateObservacao",
          chamado: id,
          level,
          observacao: obs,
        });
      }
      wsSend({
        action: "updateStatusFinal",
        chamado: id,
        status,
      });
    },

    requestState: (chamado) => {
      const id = Number(chamado);
      wsSend({
        action: "getState",
        chamado: id,
      });
    },

    updateLocal: (chamado, patch) =>
      set((state) => ({
        chamados: {
          ...state.chamados,
          [chamado]: {
            ...(state.chamados[chamado] ?? {
              status: "pending",
              currentLevel: 0,
              timeRemaining: 0,
              timerActive: false,
              isAttended: false,
              observations: "",
            }),
            ...patch,
          },
        },
      })),

    tick: () =>
      set((state) => {
        const next: Record<string, EscalationState> = {};
        for (const [id, ch] of Object.entries(state.chamados)) {
          if (ch.timerActive && ch.timeRemaining > 0) {
            next[id] = { ...ch, timeRemaining: ch.timeRemaining - 1 };
          } else if (ch.timerActive && ch.timeRemaining <= 0) {
            next[id] = { ...ch, timerActive: false, timeRemaining: 0 };
          } else {
            next[id] = ch;
          }
        }
        return { chamados: next };
      }),
  };
});

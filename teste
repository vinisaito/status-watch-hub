import React, { useEffect, useRef, useState } from "react";

const WS_URL = "wss://m89s04n9ve.execute-api.us-east-1.amazonaws.com/prod";
const REST_URL = "https://m89s04n9ve.execute-api.us-east-1.amazonaws.com/prod/getState";
const CHAMADO = 123; // üîπ Defina o ID do chamado fixo para teste

const Timer: React.FC = () => {
  const [timeRemaining, setTimeRemaining] = useState<number>(0);
  const [timerActive, setTimerActive] = useState<boolean>(false);
  const [connected, setConnected] = useState<boolean>(false);
  const wsRef = useRef<WebSocket | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  // üîπ Conecta no WebSocket
  useEffect(() => {
    console.log("üîå Conectando ao WebSocket...");
    const ws = new WebSocket(WS_URL);
    wsRef.current = ws;

    ws.onopen = () => {
      console.log("‚úÖ WebSocket conectado!");
      setConnected(true);
    };

    ws.onmessage = (msg) => {
      try {
        const data = JSON.parse(msg.data);
        console.log("üì© Mensagem recebida do WS:", data);

        if (data.type === "TIMER_UPDATED") {
          setTimeRemaining(data.timeRemaining);
          setTimerActive(data.timerActive);
        }
      } catch (err) {
        console.error("‚ùå Erro ao parsear mensagem:", err);
      }
    };

    ws.onerror = (err) => {
      console.error("‚ùå Erro no WebSocket:", err);
    };

    ws.onclose = () => {
      console.warn("‚ö†Ô∏è WebSocket fechado!");
      setConnected(false);
    };

    return () => {
      console.log("üîå Fechando WebSocket...");
      ws.close();
    };
  }, []);

  // üîπ Busca estado inicial do timer
  useEffect(() => {
    console.log(`üåê Buscando estado inicial de ${CHAMADO}...`);
    fetch(`${REST_URL}?chamado=${CHAMADO}`)
      .then((res) => res.json())
      .then((data) => {
        console.log("üì• Estado inicial:", data);
        setTimeRemaining(data.timeRemaining || 0);
        setTimerActive(data.timerActive || false);
      })
      .catch((err) => console.error("‚ùå Erro ao buscar estado inicial:", err));
  }, []);

  // üîπ Atualiza cron√¥metro localmente
  useEffect(() => {
    if (intervalRef.current) clearInterval(intervalRef.current);

    if (timerActive) {
      console.log("‚ñ∂Ô∏è Timer rodando...");
      intervalRef.current = setInterval(() => {
        setTimeRemaining((prev) => Math.max(prev - 1, 0));
      }, 1000);
    } else {
      console.log("‚è∏Ô∏è Timer pausado.");
    }

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [timerActive]);

  // üîπ Envia a√ß√£o pelo WebSocket
  const sendAction = (action: string) => {
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
      console.error("‚ùå WebSocket n√£o est√° pronto para enviar!");
      return;
    }

    const payload = JSON.stringify({ action, chamado: CHAMADO });
    console.log(`üì§ Enviando para WS:`, payload);
    wsRef.current.send(payload);
  };

  // üîπ Alterna entre iniciar e pausar
  const toggleTimer = () => {
    if (!connected) {
      console.error("‚ùå N√£o conectado ao WebSocket!");
      return;
    }
    if (timerActive) {
      sendAction("pauseTimer");
    } else {
      sendAction("startTimer");
    }
  };

  // üîπ Formata tempo
  const formatTime = (seconds: number) => {
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
  };

  return (
    <div style={{ fontFamily: "Arial", padding: "20px" }}>
      <h2>üïí Timer Chamado {CHAMADO}</h2>
      <p>Status: {timerActive ? "Ativo" : "Pausado"}</p>
      <p>Tempo Restante: {formatTime(timeRemaining)}</p>
      <p>WS: {connected ? "‚úÖ Conectado" : "‚ùå Desconectado"}</p>
      <button onClick={toggleTimer} style={{ padding: "10px", fontSize: "16px" }}>
        {timerActive ? "Pausar" : "Iniciar"}
      </button>
    </div>
  );
};

export default Timer;

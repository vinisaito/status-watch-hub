import { create } from "zustand";
import { ws } from "@/services/websocket"; // deve exportar: subscribe(cb) e send(payload)

// --- helpers ---
type ID = string | number;
const toNum = (id: ID) =>
  typeof id === "number" ? id : Number(String(id).trim());

const isValidNum = (n: number) => Number.isFinite(n) && !Number.isNaN(n);

// --- mensagens que a Lambda envia ---
type IncomingAction =
  | "currentState"
  | "timerStarted"
  | "statusUpdated"
  | "operadorUpdated"
  | "observacaoUpdated"
  | "statusFinalUpdated";

type IncomingMsg = {
  action: IncomingAction;
  chamado?: number; // a Lambda usa 'chamado'
  [k: string]: any;
};

interface StoreState {
  // chaveada por string para não ter surpresa com keys numéricas no objeto
  chamados: Record<string, any>;

  // inicialização/estado
  initChamado: (id: ID) => void;

  // ações de negócio que a coluna usa
  startChamado: (id: ID) => void; // inicia "primeiroAcionado"
  confirmChamado: (id: ID, observation: string) => void; // confirma + salva obs
  escalateChamado: (id: ID, level: 1 | 2 | 3 | 4) => void; // inicia escalacaoN

  // (opcionais caso use)
  updateOperador?: (id: ID, operador: string) => void;
  updateStatusFinal?: (id: ID, statusFinal: string) => void;
}

// assinamos o WS apenas uma vez por processo
let subscribed = false;

export const useChamadoStore = create<StoreState>((set, get) => {
  const ensureSubscribed = () => {
    if (subscribed) return;
    subscribed = true;

    ws.subscribe((raw: any) => {
      const msg: IncomingMsg = raw || {};
      const chamado = typeof msg.chamado === "number" ? msg.chamado : undefined;
      if (chamado === undefined) return;

      const key = String(chamado);

      // atualiza o estado do chamado com o payload recebido
      set((s) => ({
        chamados: {
          ...s.chamados,
          [key]: {
            ...(s.chamados[key] || {}),
            ...msg, // você pode normalizar aqui se preferir
          },
        },
      }));
    });
  };

  return {
    chamados: {},

    initChamado: (id) => {
      ensureSubscribed();
      const n = toNum(id);
      if (!isValidNum(n)) {
        console.warn("[Store] chamado inválido:", id);
        return;
      }
      // pede o estado inicial desse chamado
      ws.send({ action: "getState", chamado: n });
    },

    // Inicia o timer do "Primeiro Acionado" (20min) — alinha com a Lambda
    startChamado: (id) => {
      const n = toNum(id);
      if (!isValidNum(n)) return;
      ws.send({ action: "startTimer", chamado: n, timer: "primeiroAcionado" });
    },

    // Confirma recebimento: salva observação no passo atual e marca status
    // -> mapeei para: updateObservacao (no passo base) + updateStatus
    confirmChamado: (id, observation) => {
      const n = toNum(id);
      if (!isValidNum(n)) return;

      // salva observação do "primeiroAcionado" (ajuste se quiser em etapa corrente)
      ws.send({
        action: "updateObservacao",
        chamado: n,
        timer: "primeiroAcionado",
        observacao: observation,
      });

      // marca status "confirmed" (ajuste conforme seu domínio)
      ws.send({ action: "updateStatus", chamado: n, status: "confirmed" });
    },

    // Escalação N => inicia timer escalacao{N}
    escalateChamado: (id, level) => {
      const n = toNum(id);
      if (!isValidNum(n)) return;
      const timerKey = `escalacao${level}` as const;
      ws.send({ action: "startTimer", chamado: n, timer: timerKey });
    },
  };
});

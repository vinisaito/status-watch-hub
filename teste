import { useState, useEffect, useMemo, useCallback } from 'react';
import { Check, AlertTriangle, ExternalLink, Zap, Group, Calendar, Info, XCircle, Flame, ChevronLeft, ChevronRight, ArrowUpDown, ArrowUp, ArrowDown, User, FileText, Save, Edit3, CheckCircle, X, RefreshCw, Clock, Search } from 'lucide-react';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { toast } from '@/hooks/use-toast';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { useChatAcionados } from '@/hooks/use-chat-acionados';
import { useChatAcionadosTimestamps } from '@/hooks/use-chat-acionados-timestamps';

interface AlertData {
  id: string;
  chamado: string;
  tipo_chamado: string;
  grupo_chamado: string;
  status_chamado: string;
  abertura_chamado: string;
  resumo_chamado: string;
  severidade_chamado: string;
  acionado: string;
  chat: boolean;
}

interface ObservacaoData {
  chamado: number;
  observacao: string;
  status: string;
  operador: string;
  CreatedAt?: string;
}

interface ActionTableProps {
  alertData: AlertData[];
  onUpdateAcknowledgment: (alertId: string, acknowledged: boolean) => void;
  loading: boolean;
}

interface Obsstatus {
  status: string;
}

const Obsstatus: React.FC<Obsstatus> = ({ status }) => {
  if (status === "finalizado") {
    return null; // não renderiza nada
  }
}
export default Obsstatus;

type SortField = 'chamado' | 'tipo_chamado' | 'grupo_chamado' | 'status_chamado' | 'abertura_chamado' | 'resumo_chamado' | 'severidade_chamado' | 'acionado';
type SortDirection = 'asc' | 'desc' | null;

export const ActionTable = ({ alertData, onUpdateAcknowledgment, loading }: ActionTableProps) => {
  const [selectedIncident, setSelectedIncident] = useState<AlertData | null>(null);
  const [crisisDialogOpen, setCrisisDialogOpen] = useState(false);
  const [expandedRows, setExpandedRows] = useState<Set<string>>(new Set());
  const [currentPage, setCurrentPage] = useState(1);
  const [searchTerm, setSearchTerm] = useState('');
  const [itemsPerPage, setItemsPerPage] = useState<number>(() => {
    const saved = sessionStorage.getItem("itemsPerPage");
    return saved ? parseInt(saved, 10) : 5;
  });

  // Estados para ordenação
  const [sortField, setSortField] = useState<SortField>('chamado');
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc');

  // Usando o hook personalizado para chat acionados
  const { acionadosSet, isAcionado, addAcionado } = useChatAcionados();

  // Estados para observações
  const [observacoesData, setObservacoesData] = useState<Map<string, ObservacaoData>>(new Map());
  const [observacaoDialogOpen, setObservacaoDialogOpen] = useState(false);
  const [selectedChamadoForEdit, setSelectedChamadoForEdit] = useState<string>('');
  const [tempOperador, setTempOperador] = useState<string>('');
  const [tempObservacao, setTempObservacao] = useState<string>('');

  const { getTimestampForChamado, hasTimestamp, fetchTimestamps } = useChatAcionadosTimestamps();

  // Modal para detalhes do chamado
  const [chamadoModalOpen, setChamadoModalOpen] = useState(false);

  // Função para buscar observações da API com retry
  const fetchObservacoes = useCallback(async (retryCount = 0) => {
    try {
      const response = await fetch('https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/obs', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (response.ok) {
        const data: ObservacaoData[] = await response.json();
        const observacoesMap = new Map<string, ObservacaoData>();
        data.forEach(obs => {
          observacoesMap.set(obs.chamado.toString(), obs);
        });
        setObservacoesData(observacoesMap);
        console.log(`Observações carregadas: ${data.length} registros`);
      } else if (response.status === 404) {
        // API retorna 404 quando não há dados, isso é normal
        console.log('Nenhuma observação encontrada na API');
        setObservacoesData(new Map());
      } else {
        throw new Error(`API retornou status: ${response.status}`);
      }
    } catch (error) {
      console.error('Erro ao buscar observações:', error);

      // Retry até 3 tentativas
      if (retryCount < 3) {
        console.log(`Tentando novamente... (${retryCount + 1}/3)`);
        setTimeout(() => fetchObservacoes(retryCount + 1), 2000 * (retryCount + 1));
      } else {
        toast({
          title: 'Erro ao carregar observações',
          description: 'Não foi possível carregar dados salvos. As novas alterações funcionarão normalmente.',
          variant: 'destructive',
        });
      }
    }
  }, []);

  // Carrega observações ao montar o componente
  useEffect(() => {
    fetchObservacoes();
    fetchTimestamps();
  }, [fetchObservacoes, fetchTimestamps]);

  // Auto-refresh a cada 5 minutos
  useEffect(() => {
    const interval = setInterval(() => {
      fetchObservacoes();
      fetchTimestamps();
    }, 5 * 60 * 1000); // 5 minutos

    return () => clearInterval(interval);
  }, [fetchObservacoes, fetchTimestamps]);

  // Funções para manipular observações
  const handleOpenObservacao = (chamado: string) => {
    setSelectedChamadoForEdit(chamado);
    const existingObs = observacoesData.get(chamado);
    if (existingObs) {
      setTempOperador(existingObs.operador);
      setTempObservacao(existingObs.observacao);
    } else {
      setTempOperador('');
      setTempObservacao('');
    }
    setObservacaoDialogOpen(true);
  };

  const handleSaveObservacao = async () => {
    if (!tempOperador || !tempObservacao.trim() || !selectedChamadoForEdit) {
      toast({
        title: 'Campos obrigatórios',
        description: 'Preencha o operador e a observação',
        variant: 'destructive',
      });
      return;
    }

    try {
      const payload: ObservacaoData = {
        chamado: parseInt(selectedChamadoForEdit),
        observacao: tempObservacao.trim(),
        status: 'acionado',
        operador: tempOperador,
      };

      const response = await fetch('https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/obs', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`Erro na API: ${response.status}`);
      }

      // Atualiza o estado local
      const updatedObsData = new Map(observacoesData);
      updatedObsData.set(selectedChamadoForEdit, payload);
      setObservacoesData(updatedObsData);

      toast({
        title: 'Observação salva',
        description: 'A observação foi salva com sucesso',
      });

      // Recarrega dados da API para pegar o CreatedAt
      fetchObservacoes();

      handleCancelObservacao();
    } catch (error) {
      console.error('Erro ao salvar observação:', error);
      toast({
        title: 'Erro ao salvar',
        description: 'Não foi possível salvar a observação',
        variant: 'destructive',
      });
    }
  };

  const handleCancelObservacao = () => {
    setObservacaoDialogOpen(false);
    setSelectedChamadoForEdit('');
    setTempOperador('');
    setTempObservacao('');
  };

def check_cooldown(chamado, cooldown=10):
    """Verifica se jÃ¡ se passaram X segundos desde a Ãºltima aÃ§Ã£o"""
    resp = table.get_item(Key={"chamado": chamado})
    item = resp.get("Item", {})

    if item and "lastActionAt" in item:
        last = datetime.fromisoformat(item["lastActionAt"].replace("Z", "+00:00"))
        diff = (datetime.now(timezone.utc) - last).total_seconds()
        if diff < cooldown:
            raise Exception(f"AÃ§Ã£o bloqueada. Tente novamente em {int(cooldown - diff)}s.")

    return item


def handle_update_status_final(event, trace, body):
    chamado = int(body["chamado"])
    status = body["status"]
    level = body.get("level")  # opcional
    now = datetime.now(timezone.utc).isoformat()

    # ðŸ”’ cooldown
    check_cooldown(chamado)

    # Evita finalizar duas vezes
    expected = "attribute_not_exists(#sf) OR #sf <> :finished"
    expr_names = {"#sf": "statusFinal"}
    expr_values = {":finished": "finished"}

    resp = table.get_item(Key={"chamado": chamado})
    state_atual = resp.get("Item", {})

    update = {"statusFinal": status, "statusFinal_updatedAt": now, "lastActionAt": now}

    if level:
        update[f"level{level}_status"] = status
        update[f"level{level}_updatedAt"] = now
    else:
        for i in range(1, 6):
            if state_atual.get(f"level{i}_status") == "running":
                update[f"level{i}_status"] = status
                update[f"level{i}_updatedAt"] = now
                break

    state = update_chamado(trace, chamado, update, expected, expr_names, expr_values)
    broadcast({"event": "updateStatusFinal", "chamado": chamado, "state": state})
    return {"statusCode": 200, "body": json.dumps({"msg": "Status final atualizado"}, cls=DecimalEncoder)}


def handle_update_acionamento(event, trace, body):
    chamado = int(body["chamado"])
    level = int(body.get("level", 1))
    now = datetime.now(timezone.utc).isoformat()

    # ðŸ”’ cooldown
    check_cooldown(chamado)

    observacao = body.get("observacao")
    pessoa_acionada = body.get("pessoaAcionada")
    status_acionamento = body.get("statusAcionamento")
    operador = body.get("operador")

    update = {f"level{level}_updatedAt": now, "lastActionAt": now}

    if observacao is not None:
        update[f"level{level}_observacao"] = observacao
    if pessoa_acionada is not None:
        update[f"level{level}_pessoaAcionada"] = pessoa_acionada
    if status_acionamento is not None:
        update[f"level{level}_statusAcionamento"] = status_acionamento
    if operador is not None:
        update[f"level{level}_operador"] = operador

    expected = "attribute_not_exists(#lvl) OR #lvl <> :finished"
    expr_names = {"#lvl": f"level{level}_status"}
    expr_values = {":finished": "finished"}

    state = update_chamado(trace, chamado, update, expected, expr_names, expr_values)

    broadcast({
        "event": "updateAcionamento",
        "chamado": chamado,
        "level": level,
        "state": state
    })
    return {"statusCode": 200, "body": json.dumps({"msg": f"Dados do acionamento do level {level} atualizados"}, cls=DecimalEncoder)}

import { useState, useEffect, useMemo, useCallback } from 'react';
import { Check, AlertTriangle, ExternalLink, Zap, Group, Calendar, Info, XCircle, Flame, ChevronLeft, ChevronRight, ArrowUpDown, ArrowUp, ArrowDown, User, FileText, Save, Edit3, CheckCircle, X, RefreshCw, Clock, Search } from 'lucide-react';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { toast } from '@/hooks/use-toast';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';

interface AlertData {
  id: string;
  chamado: string;
  tipo_chamado: string;
  grupo_chamado: string;
  status_chamado: string;
  abertura_chamado: string;
  resumo_chamado: string;
  severidade_chamado: string;
  acionado: string;
  chat: boolean;
}

interface ObservacaoData {
  chamado: number;
  observacao: string;
  status: string;
  operador: string;
  CreatedAt?: string;
}

interface ActionTableProps {
  alertData: AlertData[];
  onUpdateAcknowledgment: (alertId: string, acknowledged: boolean) => void;
  loading: boolean;
}

interface Obsstatus {
  status: string;
}

const Obsstatus: React.FC<Obsstatus> = ({ status }) => {
  if (status === "finalizado") {
    return null; // não renderiza nada
  }
}
export default Obsstatus;

type SortField = 'chamado' | 'tipo_chamado' | 'grupo_chamado' | 'status_chamado' | 'abertura_chamado' | 'resumo_chamado' | 'severidade_chamado' | 'acionado';
type SortDirection = 'asc' | 'desc' | null;

export const ActionTable = ({ alertData, onUpdateAcknowledgment, loading }: ActionTableProps) => {
  const [selectedIncident, setSelectedIncident] = useState<AlertData | null>(null);
  const [crisisDialogOpen, setCrisisDialogOpen] = useState(false);
  const [expandedRows, setExpandedRows] = useState<Set<string>>(new Set());
  const [currentPage, setCurrentPage] = useState(1);
  const [searchTerm, setSearchTerm] = useState('');
  const [itemsPerPage, setItemsPerPage] = useState(5);

  // Estados para ordenação
  const [sortField, setSortField] = useState<SortField>('chamado');
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc');

  // Usando hooks mockados (você pode implementar os reais)
  const acionadosSet = new Set();
  const isAcionado = (chamado: string) => acionadosSet.has(chamado);
  const addAcionado = (chamado: string) => acionadosSet.add(chamado);

  // Estados para observações
  const [observacoesData, setObservacoesData] = useState<Map<string, ObservacaoData>>(new Map());
  const [observacaoDialogOpen, setObservacaoDialogOpen] = useState(false);
  const [selectedChamadoForEdit, setSelectedChamadoForEdit] = useState<string>('');
  const [tempOperador, setTempOperador] = useState<string>('');
  const [tempObservacao, setTempObservacao] = useState<string>('');

  // Modal para detalhes do chamado
  const [chamadoModalOpen, setChamadoModalOpen] = useState(false);

  // Lista de operadores
  const operadores = [
    'ALBERTO LAGES',
    'ALEXANDRE LIMA SILVA',
    'ANSELMO ALVES PESSOA',
    'BRUNO MAZZO FEITOSA',
    'CAIO CESAR ALVES DA LUZ',
    'CLAUDIA ZORZAN DE CAMARGO',
    'JEFFERSON DA SILVA SOUZA',
    'JULIANA BEATRIZ DE ANGELO',
    'MARIA LUIZA DOS SANTOS COIADO',
    'RAFAEL NUNES PACHECO',
    'SERGIO ANTONIO DA SILVA',
    'VICTOR HUGO ALMEIDA FERNANDES',
    'VINICIUS RHYU VITURINO SAITO'
  ];

  // Função para buscar observações da API com retry
  const fetchObservacoes = useCallback(async (retryCount = 0) => {
    try {
      const response = await fetch('https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/obs', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (response.ok) {
        const data: ObservacaoData[] = await response.json();
        const observacoesMap = new Map<string, ObservacaoData>();
        data.forEach(obs => {
          observacoesMap.set(obs.chamado.toString(), obs);
        });
        setObservacoesData(observacoesMap);
        console.log(`Observações carregadas: ${data.length} registros`);
      } else if (response.status === 404) {
        // API retorna 404 quando não há dados, isso é normal
        console.log('Nenhuma observação encontrada na API');
        setObservacoesData(new Map());
      } else {
        throw new Error(`API retornou status: ${response.status}`);
      }
    } catch (error) {
      console.error('Erro ao buscar observações:', error);

      // Retry até 3 tentativas
      if (retryCount < 3) {
        console.log(`Tentando novamente... (${retryCount + 1}/3)`);
        setTimeout(() => fetchObservacoes(retryCount + 1), 2000 * (retryCount + 1));
      } else {
        toast({
          title: 'Erro ao carregar observações',
          description: 'Não foi possível carregar dados salvos. As novas alterações funcionarão normalmente.',
          variant: 'destructive',
        });
      }
    }
  }, []);

  // Carrega observações ao montar o componente
  useEffect(() => {
    fetchObservacoes();
  }, [fetchObservacoes]);

  // Auto-refresh a cada 5 minutos
  useEffect(() => {
    const interval = setInterval(() => {
      fetchObservacoes();
    }, 5 * 60 * 1000); // 5 minutos

    return () => clearInterval(interval);
  }, [fetchObservacoes]);

  // Funções para manipular observações
  const handleOpenObservacao = (chamado: string) => {
    setSelectedChamadoForEdit(chamado);
    const existingObs = observacoesData.get(chamado);
    if (existingObs) {
      setTempOperador(existingObs.operador);
      setTempObservacao(existingObs.observacao);
    } else {
      setTempOperador('');
      setTempObservacao('');
    }
    setObservacaoDialogOpen(true);
  };

  const handleSaveObservacao = async () => {
    if (!tempOperador || !tempObservacao.trim() || !selectedChamadoForEdit) {
      toast({
        title: 'Campos obrigatórios',
        description: 'Preencha o operador e a observação',
        variant: 'destructive',
      });
      return;
    }

    try {
      const payload: ObservacaoData = {
        chamado: parseInt(selectedChamadoForEdit),
        observacao: tempObservacao.trim(),
        status: 'acionado',
        operador: tempOperador,
      };

      const response = await fetch('https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/obs', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`Erro na API: ${response.status}`);
      }

      // Atualiza o estado local
      const updatedObsData = new Map(observacoesData);
      updatedObsData.set(selectedChamadoForEdit, payload);
      setObservacoesData(updatedObsData);

      toast({
        title: 'Observação salva',
        description: 'A observação foi salva com sucesso',
      });

      // Recarrega dados da API para pegar o CreatedAt
      fetchObservacoes();

      handleCancelObservacao();
    } catch (error) {
      console.error('Erro ao salvar observação:', error);
      toast({
        title: 'Erro ao salvar',
        description: 'Não foi possível salvar a observação',
        variant: 'destructive',
      });
    }
  };

  const handleCancelObservacao = () => {
    setObservacaoDialogOpen(false);
    setSelectedChamadoForEdit('');
    setTempOperador('');
    setTempObservacao('');
  };

  // Função para lidar com clique no cabeçalho da coluna
  const handleSort = (field: SortField) => {
    if (sortField === field) {
      // Se já está ordenando por este campo, alterna a direção
      if (sortDirection === 'asc') {
        setSortDirection('desc');
      } else if (sortDirection === 'desc') {
        setSortDirection(null);
        setSortField('chamado'); // volta para o padrão
      } else {
        setSortDirection('asc');
      }
    } else {
      // Se é um campo diferente, começa com ascendente
      setSortField(field);
      setSortDirection('asc');
    }
  };

  // Função para obter o ícone de ordenação
  const getSortIcon = (field: SortField) => {
    if (sortField !== field) {
      return <ArrowUpDown className="h-4 w-4 ml-1 opacity-50" />;
    }
    if (sortDirection === 'asc') {
      return <ArrowUp className="h-4 w-4 ml-1" />;
    }
    if (sortDirection === 'desc') {
      return <ArrowDown className="h-4 w-4 ml-1" />;
    }
    return <ArrowUpDown className="h-4 w-4 ml-1 opacity-50" />;
  };

  // Função para formatar data de forma segura
  const formatDate = (dateString: string) => {
    if (!dateString || dateString === '' || dateString === 'null' || dateString === 'undefined') {
      return '-';
    }

    try {
      let date: Date;
      const cleanString = String(dateString).trim();

      // Caso 1: Timestamp em milissegundos
      if (/^\d{13}$/.test(cleanString)) {
        date = new Date(parseInt(cleanString));
      }
      // Caso 2: Timestamp em segundos  
      else if (/^\d{10}$/.test(cleanString)) {
        date = new Date(parseInt(cleanString) * 1000);
      }
      // Caso 3: Formato brasileiro dd/mm/yyyy ou dd/mm/yyyy hh:mm:ss
      else if (/^\d{2}\/\d{2}\/\d{4}/.test(cleanString)) {
        const parts = cleanString.split(' ');
        const datePart = parts[0];
        const timePart = parts[1] || '00:00:00';

        const [day, month, year] = datePart.split('/');
        const [hour, minute, second] = timePart.split(':');

        date = new Date(
          parseInt(year),
          parseInt(month) - 1, // mês é 0-indexed
          parseInt(day),
          parseInt(hour || '0'),
          parseInt(minute || '0'),
          parseInt(second || '0')
        );
      }
      // Caso 4: ISO string ou outros formatos padrão
      else {
        date = new Date(cleanString);
      }

      // Verifica se a data é válida
      if (isNaN(date.getTime())) {
        return cleanString; // Retorna o valor original
      }

      // Verifica se a data é muito antiga ou muito futura (validação básica)
      const year = date.getFullYear();
      if (year < 1900 || year > 2100) {
        return cleanString;
      }

      return date.toLocaleString('pt-BR', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
      });
    } catch (error) {
      return String(dateString); // Garante que retorna string
    }
  };

  // Função para formatar o status "Acionado"
  const formatAcionadoStatus = (acionado: string) => {
    if (!acionado) return { text: '-', isOk: false };

    const upperAcionado = acionado.toUpperCase();
    if (upperAcionado === 'OK') {
      return { text: 'ACIONADO', isOk: true };
    } else if (upperAcionado === 'NOK') {
      return { text: 'NÃO ACIONADO', isOk: false };
    }

    return { text: acionado, isOk: false };
  };

  // Função para filtrar dados baseado no termo de pesquisa
  const filteredData = useMemo(() => {
    if (!searchTerm.trim()) {
      return alertData;
    }

    const searchLower = searchTerm.toLowerCase().trim();
    return alertData.filter(alert =>
      alert.chamado.toLowerCase().includes(searchLower) ||
      alert.tipo_chamado.toLowerCase().includes(searchLower) ||
      alert.grupo_chamado.toLowerCase().includes(searchLower) ||
      alert.status_chamado.toLowerCase().includes(searchLower) ||
      alert.resumo_chamado.toLowerCase().includes(searchLower) ||
      alert.severidade_chamado.toLowerCase().includes(searchLower) ||
      alert.acionado.toLowerCase().includes(searchLower)
    );
  }, [alertData, searchTerm]);

  // Dados ordenados e paginados
  const { sortedAndPaginatedData, totalPages } = useMemo(() => {
    let sortedData = [...filteredData];

    // Aplica ordenação se houver campo e direção definidos
    if (sortField && sortDirection) {
      sortedData.sort((a, b) => {
        let aValue: any = a[sortField];
        let bValue: any = b[sortField];

        // Tratamento especial para diferentes tipos de dados
        if (sortField === 'chamado') {
          aValue = parseInt(a.chamado) || 0;
          bValue = parseInt(b.chamado) || 0;
        } else if (sortField === 'abertura_chamado') {
          aValue = new Date(a.abertura_chamado).getTime() || 0;
          bValue = new Date(b.abertura_chamado).getTime() || 0;
        } else {
          // Para strings, converte para minúsculo para ordenação case-insensitive
          aValue = String(aValue).toLowerCase();
          bValue = String(bValue).toLowerCase();
        }

        if (aValue < bValue) {
          return sortDirection === 'asc' ? -1 : 1;
        }
        if (aValue > bValue) {
          return sortDirection === 'asc' ? 1 : -1;
        }
        return 0;
      });
    } else {
      // Ordenação padrão por chamado decrescente
      sortedData.sort((a, b) => {
        const chamadoA = parseInt(a.chamado) || 0;
        const chamadoB = parseInt(b.chamado) || 0;
        return chamadoB - chamadoA;
      });
    }

    // Calcula paginação
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const paginatedData = sortedData.slice(startIndex, endIndex);
    const totalPages = Math.ceil(sortedData.length / itemsPerPage);

    return {
      sortedAndPaginatedData: paginatedData,
      totalPages
    };
  }, [filteredData, currentPage, itemsPerPage, sortField, sortDirection]);

  // Reset página quando dados mudam ou pesquisa muda
  useEffect(() => {
    setCurrentPage(1);
  }, [filteredData, itemsPerPage]);

  const truncateText = (text: string, maxLength: number) => {
    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
  };

  const handleIncidentClick = (alert: AlertData) => {
    if (alert.tipo_chamado.toLowerCase().includes('incidente')) {
      setSelectedIncident(alert);
      setCrisisDialogOpen(true);
    }
  };

  const getSeverityColor = (severity: string) => {
    return severity.includes('4')
      ? 'bg-destructive text-destructive-foreground'
      : 'bg-yellow-500 text-yellow-950';
  };

  const handleChamadoClick = (alert: AlertData) => {
    setSelectedIncident(alert);
    setChamadoModalOpen(true);
  };

  const getStatusBadgeClass = (chat: boolean) =>
    chat
      ? 'bg-green-500 text-white border-green-400'
      : 'bg-red-500 text-white border-red-400';

  const getStatusIcon = (chat: boolean) =>
    chat ? <Check className="h-4 w-4" /> : <XCircle className="h-4 w-4" />;

  const getStatusText = (chat: boolean) => {
    return chat ? 'ACIONADO VIA CHAT' : 'NÃO ACIONADO VIA CHAT';
  };

  const handlePageChange = (page: number) => {
    setCurrentPage(page);
  };

  const handleItemsPerPageChange = (value: string) => {
    setItemsPerPage(parseInt(value));
    setCurrentPage(1); // Reset para a primeira página
  };

  const handleAcknowledgment = (alert: AlertData) => {
    addAcionado(alert.chamado);
    onUpdateAcknowledgment(alert.id, true);
    toast({
      title: 'Alerta acionado',
      description: `Chamado ${alert.chamado} foi marcado como acionado`,
    });
  };

  return (
    <TooltipProvider>
      <Card className="bg-card border-border">
        <CardHeader>
          {/* Campo de Pesquisa */}
          <div className="relative mb-4">
            <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              placeholder="Pesquisar por chamado, tipo, grupo, status, título..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="pl-10"
            />
          </div>

          {/* Controles superiores */}
          <div className="flex items-center justify-between mb-4">
            {/* Seletor de itens por página */}
            <div className="flex items-center gap-2">
              <Label htmlFor="itemsPerPage" className="text-sm font-medium">
                Alertas por página:
              </Label>
              <Select value={itemsPerPage.toString()} onValueChange={handleItemsPerPageChange}>
                <SelectTrigger className="w-20">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Indicador de resultados */}
            {searchTerm && (
              <div className="text-sm text-muted-foreground">
                {filteredData.length === 0 ? (
                  <span>Nenhum resultado encontrado para "{searchTerm}"</span>
                ) : (
                  <span>
                    {filteredData.length} resultado{filteredData.length !== 1 ? 's' : ''}
                    {filteredData.length !== alertData.length && ` de ${alertData.length} `}
                       para "{searchTerm}"
                  </span>
                )}
              </div>
            )}
          </div>
        </CardHeader>
        <CardContent>
          {/* Layout para Mobile (oculto em desktop) */}
          <div className="block lg:hidden space-y-4">
            {loading ? (
              <div className="text-center py-8">
                <div className="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-primary mb-4"></div>
                <p>Carregando dados...</p>
              </div>
            ) : sortedAndPaginatedData.length === 0 ? (
              <div className="text-center py-8 text-muted-foreground">
                {searchTerm ? 'Nenhum resultado encontrado' : 'Nenhum dado disponível'}
              </div>
            ) : (
              sortedAndPaginatedData.map((alert) => {
                const isChat = acionadosSet.has(alert.chamado.toString());
                const isExpanded = expandedRows.has(alert.id);
                const observacao = observacoesData.get(alert.chamado);
                return (
                  <Card key={alert.id} className="bg-secondary border-border w-full">
                    <CardContent className="p-3 sm:p-4">
                      <div className="flex items-center justify-between mb-3 gap-2 flex-wrap">
                        <div className="flex items-center gap-1 sm:gap-2 flex-wrap">
                          <Badge variant="outline" className="text-xs">
                            <Button
                              variant="link"
                              size="sm"
                              className="text-xs p-0 hover:underline"
                              onClick={() => handleChamadoClick(alert)}
                            >
                              {alert.chamado}
                            </Button>
                          </Badge>
                          <Badge variant="outline" className="text-xs max-w-[100px] truncate">
                            {alert.tipo_chamado}
                          </Badge>
                          <Badge className={`${getSeverityColor(alert.severidade_chamado)} text-xs`}>
                            {alert.severidade_chamado}
                          </Badge>
                        </div>
                      </div>

                      <div className="space-y-2">
                        <div className="w-full">
                          <p className="text-sm font-medium break-words">
                            {truncateText(alert.resumo_chamado, isExpanded ? 200 : 60)}
                          </p>
                        </div>

                        <div className="flex items-center justify-between text-xs text-muted-foreground gap-2">
                          <span className="text-sm font-semibold text-foreground truncate flex-1">
                            {alert.grupo_chamado}
                          </span>
                          <span className="truncate">{alert.status_chamado}</span>
                        </div>

                        <div className="text-xs text-muted-foreground">
                          {formatDate(alert.abertura_chamado)}
                        </div>

                        <div className="flex items-center justify-between pt-3 gap-2">

                          <div className="flex gap-2">
                            <Button
                              variant={isChat ? 'default' : 'outline'}
                              size="sm"
                              onClick={() => !isChat && handleAcknowledgment(alert)}
                              disabled={isChat}
                              className={`h-7 px-2 sm:px-3 text-xs flex-shrink-0 ${isChat
                                ? 'bg-green-600 text-white hover:bg-green-700'
                                : 'border-border hover:bg-accent'
                                }`}
                            >
                              {isChat ? (
                                <>
                                  <Check className="h-3 w-3 mr-1" />
                                  <span className="hidden sm:inline">Acionado</span>
                                </>
                              ) : (
                                <>
                                  <AlertTriangle className="h-3 w-3 mr-1" />
                                  <span className="hidden sm:inline">Acionar</span>
                                </>
                              )}
                            </Button>

                            <Button
                              variant={observacao ? "default" : "outline"}
                              size="sm"
                              onClick={() => handleOpenObservacao(alert.chamado)}
                              className={`h-7 px-2 text-xs ${observacao
                                ? 'bg-green-600 text-white hover:bg-green-700'
                                : 'border-border hover:bg-accent'
                                }`}
                            >
                              {observacao ? (
                                <>
                                  <CheckCircle className="h-3 w-3 mr-1" />
                                  <span className="hidden sm:inline">Finalizado</span>
                                </>
                              ) : (
                                <>
                                  <Edit3 className="h-3 w-3 mr-1" />
                                  <span className="hidden sm:inline">Observação</span>
                                </>
                              )}
                            </Button>
                          </div>
                        </div>
                      </div>
                    </CardContent>
                  </Card>
                );
              })
            )}

            {/* Paginação Mobile */}
            {!loading && sortedAndPaginatedData.length > 0 && totalPages > 1 && (
              <div className="flex items-center justify-between mt-4 px-2">
                <div className="text-sm text-muted-foreground">
                  Página {currentPage} de {totalPages}
                </div>
                <div className="flex items-center gap-1">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => handlePageChange(currentPage - 1)}
                    disabled={currentPage === 1}
                    className="h-8 w-8 p-0"
                  >
                    <ChevronLeft className="h-4 w-4" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => handlePageChange(currentPage + 1)}
                    disabled={currentPage === totalPages}
                    className="h-8 w-8 p-0"
                  >
                    <ChevronRight className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            )}
          </div>

          {/* Layout para Desktop */}
          <div className="hidden lg:block overflow-x-auto">
            <Table className="min-w-[1000px]">
              <TableHeader>
                <TableRow className="border-border hover:bg-accent">
                  <TableHead className="text-muted-foreground w-20">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('chamado')}
                    >
                      Chamado
                      {getSortIcon('chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground w-24">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('tipo_chamado')}
                    >
                      Classificação
                      {getSortIcon('tipo_chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground w-20">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('grupo_chamado')}
                    >
                      Grupo
                      {getSortIcon('grupo_chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground w-20">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('status_chamado')}
                    >
                      Status
                      {getSortIcon('status_chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground w-28">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('abertura_chamado')}
                    >
                      Abertura
                      {getSortIcon('abertura_chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground flex-1 min-w-40">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('resumo_chamado')}
                    >
                      Título
                      {getSortIcon('resumo_chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground w-20">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('severidade_chamado')}
                    >
                      Severidade
                      {getSortIcon('severidade_chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground w-16 text-center">Chat</TableHead>
                  <TableHead className="text-muted-foreground w-32 text-center">Observação</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {loading ? (
                  <TableRow>
                    <TableCell colSpan={10} className="text-center py-8">
                      Carregando dados...
                    </TableCell>
                  </TableRow>
                ) : sortedAndPaginatedData.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={10} className="text-center py-8 text-muted-foreground">
                      {searchTerm ? 'Nenhum resultado encontrado' : 'Nenhum dado disponível'}
                    </TableCell>
                  </TableRow>
                ) : (
                  sortedAndPaginatedData.map((alert) => {
                    const isChat = acionadosSet.has(alert.chamado.toString());
                    const observacao = observacoesData.get(alert.chamado);
                    return (
                      <TableRow
                        key={alert.id}
                        className="border-border hover:bg-accent transition-colors"
                      >
                        <TableCell className="font-medium">
                          <Button
                            variant="link"
                            size="sm"
                            className="p-0 text-foreground hover:underline text-xs"
                            onClick={() => handleChamadoClick(alert)}
                          >
                            {alert.chamado}
                          </Button>
                        </TableCell>
                        <TableCell>
                          <Tooltip>
                            <TooltipTrigger asChild>
                              <span className="truncate block max-w-[80px] text-xs">
                                {alert.tipo_chamado}
                              </span>
                            </TooltipTrigger>
                            <TooltipContent>
                              <p className="max-w-xs">{alert.tipo_chamado}</p>
                            </TooltipContent>
                          </Tooltip>
                        </TableCell>
                        <TableCell className="text-xs">{alert.grupo_chamado}</TableCell>
                        <TableCell className="text-xs">{alert.status_chamado}</TableCell>
                        <TableCell className="text-xs">
                          {formatDate(alert.abertura_chamado)}
                        </TableCell>
                        <TableCell>
                          <div className="flex items-center gap-2">
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className="truncate block max-w-[120px] text-xs">
                                  {alert.resumo_chamado}
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <p className="max-w-md">{alert.resumo_chamado}</p>
                              </TooltipContent>
                            </Tooltip>
                          </div>
                        </TableCell>
                        <TableCell>
                          <Badge className={`${getSeverityColor(alert.severidade_chamado)} text-xs`}>
                            {alert.severidade_chamado}
                          </Badge>
                        </TableCell>
                        <TableCell>
                          <Button
                            variant={isChat ? "default" : "outline"}
                            size="sm"
                            onClick={() => !isChat && handleAcknowledgment(alert)}
                            disabled={isChat}
                            className={`${isChat
                              ? 'bg-green-600 text-white hover:bg-green-700'
                              : 'border-border hover:bg-accent'
                              } h-7 w-7 p-0`}
                          >
                            {isChat ? (
                              <Check className="h-3 w-3" />
                            ) : (
                              <AlertTriangle className="h-3 w-3" />
                            )}
                          </Button>
                        </TableCell>
                        <TableCell>
                          <Button
                            variant={observacao ? "default" : "outline"}
                            size="sm"
                            onClick={() => handleOpenObservacao(alert.chamado)}
                            className={`${observacao
                              ? 'bg-green-600 text-white hover:bg-green-700'
                              : 'border-border hover:bg-accent'
                              } h-7 w-7 p-0`}
                          >
                            {observacao ? (
                              <CheckCircle className="h-3 w-3" />
                            ) : (
                              <Edit3 className="h-3 w-3" />
                            )}
                          </Button>
                        </TableCell>
                      </TableRow>
                    );
                  })
                )}
              </TableBody>
            </Table>
          </div>

          {/* Paginação Desktop */}
          {!loading && sortedAndPaginatedData.length > 0 && totalPages > 1 && (
            <div className="flex items-center justify-between mt-4 pt-4 border-t border-border">
              <div className="text-sm text-muted-foreground">
                Mostrando {((currentPage - 1) * itemsPerPage) + 1} a {Math.min(currentPage * itemsPerPage, filteredData.length)} de {filteredData.length} registros
                {searchTerm && filteredData.length !== alertData.length && ` (filtrados de ${alertData.length})`}
              </div>
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handlePageChange(currentPage - 1)}
                  disabled={currentPage === 1}
                  className="h-8 px-3"
                >
                  <ChevronLeft className="h-4 w-4 mr-1" />
                  Anterior
                </Button>

                <div className="flex items-center gap-1">
                  {[...Array(Math.min(totalPages, 5))].map((_, index) => {
                    let page;
                    if (totalPages <= 5) {
                      page = index + 1;
                    } else if (currentPage <= 3) {
                      page = index + 1;
                    } else if (currentPage >= totalPages - 2) {
                      page = totalPages - 4 + index;
                    } else {
                      page = currentPage - 2 + index;
                    }

                    return (
                      <Button
                        key={page}
                        variant={currentPage === page ? "default" : "outline"}
                        size="sm"
                        onClick={() => handlePageChange(page)}
                        className="h-8 w-8 p-0"
                      >
                        {page}
                      </Button>
                    );
                  })}
                </div>

                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handlePageChange(currentPage + 1)}
                  disabled={currentPage === totalPages}
                  className="h-8 px-3"
                >
                  Próximo
                  <ChevronRight className="h-4 w-4 ml-1" />
                </Button>
              </div>
            </div>
          )}
        </CardContent>

        {/* Dialog para observações */}
        <Dialog open={observacaoDialogOpen} onOpenChange={setObservacaoDialogOpen}>
          <DialogContent className="sm:max-w-md">
            <DialogHeader>
              <DialogTitle>Observação - Chamado {selectedChamadoForEdit}</DialogTitle>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <Label htmlFor="operador">Operador</Label>
                <Select value={tempOperador} onValueChange={setTempOperador}>
                  <SelectTrigger>
                    <SelectValue placeholder="Selecione o operador" />
                  </SelectTrigger>
                  <SelectContent>
                    {operadores.map((operador) => (
                      <SelectItem key={operador} value={operador}>
                        {operador}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
              <div>
                <Label htmlFor="observacao">Observação</Label>
                <Textarea
                  id="observacao"
                  value={tempObservacao}
                  onChange={(e) => setTempObservacao(e.target.value)}
                  placeholder="Digite a observação..."
                  rows={4}
                />
              </div>
              <div className="flex justify-end gap-2">
                <Button variant="outline" onClick={handleCancelObservacao}>
                  Cancelar
                </Button>
                <Button onClick={handleSaveObservacao}>
                  Salvar
                </Button>
              </div>
            </div>
          </DialogContent>
        </Dialog>

        {/* Dialog para detalhes do chamado */}
        <Dialog open={chamadoModalOpen} onOpenChange={setChamadoModalOpen}>
          <DialogContent className="sm:max-w-2xl">
            <DialogHeader>
              <DialogTitle>Detalhes do Chamado {selectedIncident?.chamado}</DialogTitle>
            </DialogHeader>
            {selectedIncident && (
              <div className="space-y-4">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <Label className="font-semibold">Tipo:</Label>
                    <p className="text-sm">{selectedIncident.tipo_chamado}</p>
                  </div>
                  <div>
                    <Label className="font-semibold">Grupo:</Label>
                    <p className="text-sm">{selectedIncident.grupo_chamado}</p>
                  </div>
                  <div>
                    <Label className="font-semibold">Status:</Label>
                    <p className="text-sm">{selectedIncident.status_chamado}</p>
                  </div>
                  <div>
                    <Label className="font-semibold">Severidade:</Label>
                    <Badge className={getSeverityColor(selectedIncident.severidade_chamado)}>
                      {selectedIncident.severidade_chamado}
                    </Badge>
                  </div>
                  <div className="md:col-span-2">
                    <Label className="font-semibold">Abertura:</Label>
                    <p className="text-sm">{formatDate(selectedIncident.abertura_chamado)}</p>
                  </div>
                </div>
                <div>
                  <Label className="font-semibold">Resumo:</Label>
                  <p className="text-sm mt-1 p-3 bg-muted rounded-md">
                    {selectedIncident.resumo_chamado}
                  </p>
                </div>
              </div>
            )}
          </DialogContent>
        </Dialog>
      </Card>
    </TooltipProvider>
  );
};

import json
import boto3
import os
import uuid
from datetime import datetime, timezone
from decimal import Decimal

# ---------- Config ----------
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table(os.environ["CHAMADOS_TABLE"])  # Tabela principal (chamados)
conn_table = dynamodb.Table(os.environ["CONNECTIONS_TABLE"])  # Tabela de conex√µes
apigw = boto3.client(
    "apigatewaymanagementapi",
    endpoint_url=f"https://{os.environ['WS_API_ID']}.execute-api.{os.environ['AWS_REGION']}.amazonaws.com/{os.environ['WS_STAGE']}"
)

# ---------- Helpers ----------
class DecimalEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, Decimal):
            if o % 1 == 0:
                return int(o)
            return float(o)
        return super(DecimalEncoder, self).default(o)

def log(trace, msg, **kwargs):
    print(json.dumps({"trace": trace, "msg": msg, **kwargs}, cls=DecimalEncoder, default=str))

def send_to_connection(conn_id, data):
    """Envia mensagem para uma conex√£o espec√≠fica"""
    try:
        apigw.post_to_connection(
            ConnectionId=conn_id,
            Data=json.dumps(data, cls=DecimalEncoder).encode("utf-8")
        )
    except apigw.exceptions.GoneException:
        # Conex√£o morta -> remover
        conn_table.delete_item(Key={"connectionId": conn_id})
        log("broadcast", "Conex√£o removida (GoneException)", connectionId=conn_id)

def broadcast(data):
    """Envia mensagem para todos conectados"""
    conns = conn_table.scan().get("Items", [])
    for c in conns:
        send_to_connection(c["connectionId"], data)

def update_chamado(trace, chamado, update, expected=None, expr_names=None, expr_values=None):
    log(trace, "Atualizando chamado", chamado=chamado, update=update, expected=expected)

    params = {
        "Key": {"chamado": chamado},
        "UpdateExpression": "SET " + ", ".join(f"#{k} = :{k}" for k in update.keys()),
        "ExpressionAttributeNames": {f"#{k}": k for k in update.keys()},
        "ExpressionAttributeValues": {f":{k}": v for k, v in update.items()},
        "ReturnValues": "ALL_NEW"
    }

    if expected:
        params["ConditionExpression"] = expected
        if expr_names:
            params["ExpressionAttributeNames"].update(expr_names)
        if expr_values:
            params["ExpressionAttributeValues"].update(expr_values)

    try:
        resp = table.update_item(**params)
        state = resp.get("Attributes", {})
    except dynamodb.meta.client.exceptions.ConditionalCheckFailedException:
        log(trace, "Condicional falhou ‚Äî outro operador j√° atualizou", chamado=chamado)
        raise Exception("Conflito de concorr√™ncia: outro operador j√° atualizou este chamado")

    log(trace, "Chamado atualizado (state completo)", state=state)
    return state

# ---------- Handlers ----------
def handle_connect(event, trace):
    conn_id = event["requestContext"]["connectionId"]
    conn_table.put_item(Item={"connectionId": conn_id, "connectedAt": datetime.now(timezone.utc).isoformat()})
    log(trace, "Novo cliente conectado", connectionId=conn_id)
    return {"statusCode": 200}

def handle_disconnect(event, trace):
    conn_id = event["requestContext"]["connectionId"]
    conn_table.delete_item(Key={"connectionId": conn_id})
    log(trace, "Cliente desconectado", connectionId=conn_id)
    return {"statusCode": 200}

def handle_start_timer(event, trace, body):
    chamado = int(body["chamado"])
    level = int(body["level"])
    duration = int(body.get("duration", 1200))  
    now = datetime.now(timezone.utc).isoformat()

    update = {
        f"level{level}_timerStart": now,
        f"level{level}_duration": duration,
        f"level{level}_status": "running"
    }
    state = update_chamado(trace, chamado, update)
    broadcast({"event": "startTimer", "chamado": chamado, "level": level, "state": state})
    return {"statusCode": 200, "body": json.dumps({"msg": "Timer iniciado"}, cls=DecimalEncoder)}

def handle_update_observacao(event, trace, body):
    """Atualiza a observa√ß√£o de um level de um chamado"""
    chamado = int(body["chamado"])
    level = int(body.get("level", 1))  
    observacao = body["observacao"]

    update = {f"level{level}_observacao": observacao}
    state = update_chamado(trace, chamado, update)

    broadcast({"event": "updateObservacao", "chamado": chamado, "state": state})
    return {"statusCode": 200, "body": json.dumps({"msg": f"Observa√ß√£o do level {level} atualizada"}, cls=DecimalEncoder)}

def handle_update_operador(event, trace, body):
    chamado = int(body["chamado"])
    operador = body["operador"]
    update = {"operador": operador}
    state = update_chamado(trace, chamado, update)
    broadcast({"event": "updateOperador", "chamado": chamado, "state": state})
    return {"statusCode": 200, "body": json.dumps({"msg": "Operador atualizado"}, cls=DecimalEncoder)}

def handle_update_status_final(event, trace, body):
    chamado = int(body["chamado"])
    status = body["status"]
    level = body.get("level")  # opcional
    now = datetime.now(timezone.utc).isoformat()

    # üîí Evita finalizar duas vezes
    expected = "attribute_not_exists(#sf) OR #sf <> :finished"
    expr_names = {"#sf": "statusFinal"}
    expr_values = {":finished": "finished"}

    # Pega estado atual para decidir qual level finalizar
    resp = table.get_item(Key={"chamado": chamado})
    state_atual = resp.get("Item", {})

    update = {"statusFinal": status, "statusFinal_updatedAt": now}

    if level:
        update[f"level{level}_status"] = status
        update[f"level{level}_updatedAt"] = now
    else:
        for i in range(1, 6):
            if state_atual.get(f"level{i}_status") == "running":
                update[f"level{i}_status"] = status
                update[f"level{i}_updatedAt"] = now
                break

    state = update_chamado(trace, chamado, update, expected, expr_names, expr_values)
    broadcast({"event": "updateStatusFinal", "chamado": chamado, "state": state})
    return {"statusCode": 200, "body": json.dumps({"msg": "Status final atualizado"}, cls=DecimalEncoder)}

def handle_update_acionamento(event, trace, body):
    chamado = int(body["chamado"])
    level = int(body.get("level", 1))
    now = datetime.now(timezone.utc).isoformat()

    observacao = body.get("observacao")
    pessoa_acionada = body.get("pessoaAcionada")
    status_acionamento = body.get("statusAcionamento")
    operador = body.get("operador")

    update = {f"level{level}_updatedAt": now}

    if observacao is not None:
        update[f"level{level}_observacao"] = observacao
    if pessoa_acionada is not None:
        update[f"level{level}_pessoaAcionada"] = pessoa_acionada
    if status_acionamento is not None:
        update[f"level{level}_statusAcionamento"] = status_acionamento
    if operador is not None:
        update[f"level{level}_operador"] = operador

    # üîí S√≥ deixa atualizar se o n√≠vel ainda n√£o estiver finalizado
    expected = "attribute_not_exists(#lvl) OR #lvl <> :finished"
    expr_names = {"#lvl": f"level{level}_status"}
    expr_values = {":finished": "finished"}

    state = update_chamado(trace, chamado, update, expected, expr_names, expr_values)

    broadcast({
        "event": "updateAcionamento",
        "chamado": chamado,
        "level": level,
        "state": state
    })
    return {"statusCode": 200, "body": json.dumps({"msg": f"Dados do acionamento do level {level} atualizados"}, cls=DecimalEncoder)}

def handle_get_state(event, trace, body):
    chamado = int(body["chamado"])
    resp = table.get_item(Key={"chamado": chamado})
    state = resp.get("Item", {})
    log(trace, "Estado retornado", chamado=chamado, state=state)

    conn_id = event["requestContext"]["connectionId"]
    payload = {"event": "getState", "chamado": chamado, "state": state}
    send_to_connection(conn_id, payload)
    return {"statusCode": 200, "body": json.dumps({"msg": "Estado enviado"}, cls=DecimalEncoder)}

# ---------- Main ----------
def lambda_handler(event, context):
    trace = str(uuid.uuid4())[:8]
    req_ctx = event.get("requestContext", {})
    route = req_ctx.get("routeKey", "UNKNOWN")
    conn_id = req_ctx.get("connectionId", "N/A")

    log(trace, "invoke", routeKey=route, connectionId=conn_id, body=event.get("body"))

    try:
        if route == "$connect":
            return handle_connect(event, trace)
        elif route == "$disconnect":
            return handle_disconnect(event, trace)
        else:
            body = json.loads(event.get("body") or "{}")
            if route == "startTimer":
                return handle_start_timer(event, trace, body)
            elif route == "updateObservacao":
                return handle_update_observacao(event, trace, body)
            elif route == "updateOperador":
                return handle_update_operador(event, trace, body)
            elif route == "updateStatusFinal":
                return handle_update_status_final(event, trace, body)
            elif route == "updateAcionamento":
                return handle_update_acionamento(event, trace, body)
            elif route == "getState":
                return handle_get_state(event, trace, body)
            else:
                log(trace, "Rota inv√°lida", route=route)
                return {"statusCode": 400, "body": json.dumps({"error": "Invalid route"}, cls=DecimalEncoder)}
    except Exception as e:
        log(trace, "Erro na execu√ß√£o", error=str(e))
        return {"statusCode": 500, "body": json.dumps({"error": str(e)}, cls=DecimalEncoder)}

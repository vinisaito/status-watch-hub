import React, { useEffect, useRef, useState } from "react";

interface Alerta {
  chamado: number;
  timerActive: boolean;
  startedAt?: string;
  durationMinutes: number;
  elapsedSeconds: number;
  timeRemaining: number;
}

const WEBSOCKET_URL = "wss://SEU_ENDPOINT.execute-api.us-east-1.amazonaws.com/prod";
const GET_STATE_URL = "https://SEU_ENDPOINT.execute-api.us-east-1.amazonaws.com/prod/dados";

export const Timer: React.FC<{ chamado: number }> = ({ chamado }) => {
  const [alerta, setAlerta] = useState<Alerta | null>(null);
  const wsRef = useRef<WebSocket | null>(null);
  const intervalRef = useRef<number | null>(null); // <-- corrigido para number

  useEffect(() => {
    console.log("🔌 Conectando WebSocket...");
    const ws = new WebSocket(WEBSOCKET_URL);

    ws.onopen = () => {
      console.log("✅ WebSocket conectado");
      fetchState();
    };

    ws.onmessage = (msg) => {
      console.log("📨 Mensagem recebida:", msg.data);
      try {
        const data = JSON.parse(msg.data);
        if (data.type === "TIMER_UPDATED" && data.chamado === chamado) {
          setAlerta({
            chamado: data.chamado,
            timerActive: data.timerActive,
            startedAt: data.startedAt,
            durationMinutes: data.durationMinutes,
            elapsedSeconds: data.elapsedSeconds || 0,
            timeRemaining: data.timeRemaining,
          });
        }
      } catch (e) {
        console.error("❌ Erro ao processar mensagem WS:", e);
      }
    };

    ws.onerror = (err) => console.error("❌ WebSocket erro:", err);
    ws.onclose = () => console.log("🔌 WebSocket desconectado");

    wsRef.current = ws;
    return () => {
      ws.close();
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [chamado]);

  useEffect(() => {
    if (!alerta) return;

    if (intervalRef.current) clearInterval(intervalRef.current);

    if (alerta.timerActive) {
      intervalRef.current = window.setInterval(() => {
        setAlerta((prev) => {
          if (!prev) return prev;
          return {
            ...prev,
            timeRemaining: Math.max(prev.timeRemaining - 1, 0),
          };
        });
      }, 1000);
    }

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [alerta?.timerActive]);

  const fetchState = async () => {
    try {
      console.log("🌐 Buscando estado inicial...");
      const res = await fetch(`${GET_STATE_URL}?chamado=${chamado}`);
      const data = await res.json();
      console.log("📊 Estado inicial:", data);
      setAlerta({
        chamado: data.chamado,
        timerActive: data.timerActive,
        startedAt: data.startedAt,
        durationMinutes: data.durationMinutes,
        elapsedSeconds: data.elapsedSeconds || 0,
        timeRemaining: data.timeRemaining,
      });
    } catch (e) {
      console.error("❌ Erro ao buscar estado:", e);
    }
  };

  const sendAction = (action: "startTimer" | "pauseTimer") => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      console.log(`📤 Enviando ${action}...`);
      wsRef.current.send(JSON.stringify({ action, chamado }));
    } else {
      console.warn("⚠️ WebSocket não está aberto");
    }
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
  };

  return (
    <div style={{ padding: "20px", border: "1px solid #ccc", width: "250px" }}>
      <h3>Chamado: {chamado}</h3>
      <p>Status: {alerta?.timerActive ? "Ativo" : "Pausado"}</p>
      <p>Tempo restante: {alerta ? formatTime(alerta.timeRemaining) : "--:--"}</p>
      <button onClick={() => sendAction("startTimer")}>Iniciar</button>
      <button onClick={() => sendAction("pauseTimer")}>Pausar</button>
    </div>
  );
};

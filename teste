import React, { useEffect, useState, useRef } from "react";

interface TimerData {
  chamado: number;
  startedAt: string | null;
  durationMinutes: number;
  timerActive: boolean;
  remaining: number;
}

const WS_URL = "wss://SEU_ENDPOINT.execute-api.us-east-1.amazonaws.com/dev"; // substituir
const API_URL = "https://SEU_ENDPOINT.execute-api.us-east-1.amazonaws.com/prod/dados"; // endpoint REST que retorna todos os alertas

export const Timer: React.FC = () => {
  const [timers, setTimers] = useState<TimerData[]>([]);
  const ws = useRef<WebSocket | null>(null);

  // Carregar timers iniciais do back-end
  useEffect(() => {
    fetch(API_URL)
      .then((res) => res.json())
      .then((data) => {
        // Supondo que cada item tenha chamado, startedAt, durationMinutes, timerActive
        const initialTimers: TimerData[] = data.map((item: any) => {
          const remaining = item.startedAt
            ? Math.max(
                0,
                item.durationMinutes * 60 -
                  (new Date().getTime() - new Date(item.startedAt).getTime()) / 1000
              )
            : item.durationMinutes * 60;

          return {
            chamado: item.chamado,
            startedAt: item.startedAt,
            durationMinutes: item.durationMinutes,
            timerActive: item.timerActive,
            remaining,
          };
        });
        setTimers(initialTimers);
      })
      .catch((err) => console.error("Erro ao buscar alertas:", err));
  }, []);

  // Conexão WebSocket
  useEffect(() => {
    ws.current = new WebSocket(WS_URL);

    ws.current.onopen = () => {
      console.log("✅ WebSocket conectado");
    };

    ws.current.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === "TIMER_UPDATED") {
        setTimers((prev) => {
          const exists = prev.find((t) => t.chamado === data.chamado);
          const remaining = data.startedAt
            ? Math.max(
                0,
                data.durationMinutes * 60 -
                  (new Date().getTime() - new Date(data.startedAt).getTime()) / 1000
              )
            : data.durationMinutes * 60;

          if (exists) {
            return prev.map((t) =>
              t.chamado === data.chamado
                ? {
                    ...t,
                    startedAt: data.startedAt,
                    durationMinutes: data.durationMinutes,
                    timerActive: data.timerActive,
                    remaining,
                  }
                : t
            );
          } else {
            return [
              ...prev,
              {
                chamado: data.chamado,
                startedAt: data.startedAt,
                durationMinutes: data.durationMinutes,
                timerActive: data.timerActive,
                remaining,
              },
            ];
          }
        });
      }
    };

    ws.current.onclose = () => console.log("❌ WebSocket desconectado");

    return () => ws.current?.close();
  }, []);

  // Atualizar timer a cada segundo
  useEffect(() => {
    const interval = setInterval(() => {
      setTimers((prev) =>
        prev.map((t) => {
          if (t.startedAt && t.timerActive) {
            const elapsed =
              (new Date().getTime() - new Date(t.startedAt).getTime()) / 1000;
            const remaining = Math.max(0, t.durationMinutes * 60 - elapsed);
            return { ...t, remaining };
          }
          return { ...t };
        })
      );
    }, 1000);
    return () => clearInterval(interval);
  }, [timers]);

  const sendAction = (chamado: number, action: "startTimer" | "pauseTimer") => {
    if (ws.current && ws.current.readyState === WebSocket.OPEN) {
      ws.current.send(JSON.stringify({ action, chamado }));
    }
  };

  return (
    <div>
      <h1>Painel de Alertas</h1>
      {timers.length === 0 && <p>Carregando alertas...</p>}
      {timers.map((t) => (
        <div key={t.chamado} style={{ border: "1px solid gray", padding: 10, margin: 5 }}>
          <p>Chamado: {t.chamado}</p>
          <p>Status: {t.timerActive ? "Rodando" : "Pausado"}</p>
          <p>
            Tempo restante:{" "}
            {t.remaining
              ? `${Math.floor(t.remaining / 60)
                  .toString()
                  .padStart(2, "0")}:${Math.floor(t.remaining % 60)
                  .toString()
                  .padStart(2, "0")}`
              : "00:00"}
          </p>
          <button onClick={() => sendAction(t.chamado, "startTimer")}>Iniciar</button>
          <button onClick={() => sendAction(t.chamado, "pauseTimer")}>Pausar</button>
        </div>
      ))}
    </div>
  );
};

export default Timer;

import { useState, useEffect } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Clock } from 'lucide-react';

interface TimerData {
  chamado: string | number;
  status: string;
  operador: string;
  startedAt: string;
  durationMinutes?: number;
  timeRemaining: number;
  timerActive: boolean;
  currentLevel: number;
  isAttended: boolean;
  observations: string;
  updatedAt: string;
  obsChat?: string;
}

const API_URL = 'https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/acompanhamento';

export function Timer() {
  const [timerData, setTimerData] = useState<TimerData | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [currentTime, setCurrentTime] = useState(new Date());
  const [isPaused, setIsPaused] = useState(false);
  const [pausedAt, setPausedAt] = useState<Date | null>(null);
  const [timeOffset, setTimeOffset] = useState(0);

  // Função para buscar dados da API
  const fetchTimerData = async () => {
    try {
      const response = await fetch(API_URL);
      if (!response.ok) {
        throw new Error('Falha ao buscar dados do cronômetro');
      }
      const data = await response.json();
      
      // Buscar o primeiro timer ativo ou o mais recente
      const activeTimer = Array.isArray(data) 
        ? data.find((item: TimerData) => item.timerActive) || 
          data.sort((a: TimerData, b: TimerData) => 
            new Date(b.updatedAt || b.startedAt).getTime() - new Date(a.updatedAt || a.startedAt).getTime()
          )[0]
        : data;
      
      setTimerData(activeTimer);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erro desconhecido');
      console.error('Erro ao buscar dados:', err);
    }
  };

  // Atualizar tempo atual a cada segundo (apenas se não pausado)
  useEffect(() => {
    const timeInterval = setInterval(() => {
      if (!isPaused) {
        setCurrentTime(new Date());
      }
    }, 1000);

    return () => clearInterval(timeInterval);
  }, [isPaused]);

  // Polling da API a cada 3 segundos para sincronização
  useEffect(() => {
    fetchTimerData(); // Buscar dados iniciais
    
    const interval = setInterval(() => {
      fetchTimerData();
    }, 3000); // Polling a cada 3 segundos

    return () => clearInterval(interval);
  }, []);

  // Calcular tempo decorrido ou restante baseado no startedAt
  const calculateTimeDisplay = (): { display: string; isActive: boolean } => {
    if (!timerData || !timerData.startedAt) {
      return { display: '--:--', isActive: false };
    }

    const startTime = new Date(timerData.startedAt);
    let elapsed: number;

    if (isPaused && pausedAt) {
      // Se pausado, usar o tempo quando pausou
      elapsed = Math.floor((pausedAt.getTime() - startTime.getTime()) / 1000);
    } else {
      // Se não pausado, usar tempo atual
      elapsed = Math.floor((currentTime.getTime() - startTime.getTime()) / 1000);
    }

    // Aplicar offset de tempo (para voltar o tempo)
    elapsed = Math.max(0, elapsed + timeOffset);
    
    // Se o timer está ativo ou pausado localmente, mostrar tempo decorrido
    if (timerData.timerActive || isPaused) {
      return { 
        display: formatTime(elapsed), 
        isActive: !isPaused 
      };
    }
    
    // Se não está ativo mas tem timeRemaining, mostrar isso
    if (timerData.timeRemaining > 0) {
      return { 
        display: formatTime(timerData.timeRemaining), 
        isActive: false 
      };
    }

    // Caso contrário, mostrar tempo decorrido
    return { 
      display: formatTime(elapsed), 
      isActive: false 
    };
  };

  // Pausar/Retomar cronômetro
  const togglePause = () => {
    if (isPaused) {
      setIsPaused(false);
      setPausedAt(null);
    } else {
      setIsPaused(true);
      setPausedAt(new Date());
    }
  };

  // Voltar tempo em 10 segundos
  const rewindTime = () => {
    setTimeOffset(prev => prev - 10);
  };

  // Resetar cronômetro
  const resetTimer = () => {
    setTimeOffset(0);
    setIsPaused(false);
    setPausedAt(null);
  };

  // Formatar tempo em HH:MM:SS ou MM:SS
  const formatTime = (seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const remainingSeconds = seconds % 60;
    
    if (hours > 0) {
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    }
    
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  // Calcular cor baseada no status e tempo
  const getTimerColor = (isActive: boolean): string => {
    if (!timerData) return 'text-timer-inactive';
    
    if (isActive && timerData.timerActive) {
      return 'text-success'; // Verde para ativo
    }
    
    if (timerData.status === 'pending') {
      return 'text-warning'; // Amarelo para pendente
    }
    
    return 'text-timer-inactive'; // Cinza para inativo
  };

  const timeInfo = calculateTimeDisplay();

  return (
    <div className="w-full max-w-md mx-auto space-y-4">
      <Card className="bg-timer-bg border-timer-border">
        <CardContent className="p-6 text-center space-y-4">
          <div className="flex items-center justify-center gap-2 mb-4">
            <Clock className="h-5 w-5 text-primary" />
            <h2 className="text-lg font-semibold">Cronômetro Sincronizado</h2>
          </div>

          {error ? (
            <div className="text-destructive text-sm">
              <p>Erro: {error}</p>
              <button 
                onClick={fetchTimerData} 
                className="mt-2 px-3 py-1 bg-secondary text-secondary-foreground rounded text-xs hover:bg-secondary/80"
              >
                Tentar Novamente
              </button>
            </div>
          ) : (
            <>
              <div className="text-center space-y-3">
                <div className={`text-5xl font-mono font-bold transition-colors ${getTimerColor(timeInfo.isActive)}`}>
                  {timeInfo.display}
                </div>
                
                <div className="flex items-center justify-center gap-2">
                  <div className={`w-3 h-3 rounded-full ${
                    isPaused ? 'bg-warning' : timerData?.timerActive ? 'bg-success animate-pulse' : 'bg-timer-inactive'
                  }`} />
                  <span className="text-sm font-medium">
                    {isPaused ? 'PAUSADO' : timerData?.timerActive ? 'ATIVO' : 'INATIVO'}
                  </span>
                </div>
                
                {/* Controles do cronômetro */}
                <div className="flex items-center justify-center gap-2 mt-4">
                  <button 
                    onClick={togglePause}
                    className="px-3 py-1.5 bg-secondary text-secondary-foreground rounded text-sm hover:bg-secondary/80 transition-colors"
                  >
                    {isPaused ? 'Retomar' : 'Pausar'}
                  </button>
                  <button 
                    onClick={rewindTime}
                    className="px-3 py-1.5 bg-warning/20 text-warning-foreground rounded text-sm hover:bg-warning/30 transition-colors"
                  >
                    -10s
                  </button>
                  <button 
                    onClick={resetTimer}
                    className="px-3 py-1.5 bg-destructive/20 text-destructive-foreground rounded text-sm hover:bg-destructive/30 transition-colors"
                  >
                    Reset
                  </button>
                </div>
                
                {timerData && (
                  <div className="space-y-1 text-sm text-muted-foreground">
                    <p>Chamado: <span className="text-foreground font-mono">{timerData.chamado}</span></p>
                    <p>Status: <span className="text-foreground capitalize">{timerData.status}</span></p>
                    {timerData.operador && (
                      <p>Operador: <span className="text-foreground">{timerData.operador}</span></p>
                    )}
                    <p>Nível: <span className="text-foreground">{timerData.currentLevel}</span></p>
                  </div>
                )}
              </div>

              {(timerData?.observations || timerData?.obsChat) && (
                <div className="text-xs text-muted-foreground bg-muted/20 p-3 rounded border">
                  <p className="font-semibold mb-1">Observações:</p>
                  <p>{timerData.observations || timerData.obsChat}</p>
                </div>
              )}
            </>
          )}
        </CardContent>
      </Card>

      <div className="text-xs text-center text-muted-foreground space-y-1">
        <div className="flex items-center justify-center gap-1">
          <div className={`w-2 h-2 rounded-full ${timerData ? 'bg-success' : 'bg-destructive'}`} />
          <span>{timerData ? 'Conectado' : 'Desconectado'}</span>
        </div>
        <p>Sincronização automática a cada 3 segundos</p>
        {timerData?.updatedAt && (
          <p>Última atualização: {new Date(timerData.updatedAt).toLocaleTimeString()}</p>
        )}
      </div>
    </div>
  );
}

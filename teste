import json
import boto3
import os
import uuid
from datetime import datetime, timezone
from decimal import Decimal

# ---------- Config ----------
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table(os.environ["DDB_TABLE"])  # Tabela principal (chamados)
conn_table = dynamodb.Table(os.environ["CONNECTIONS_TABLE"])  # Tabela de conexões
apigw = boto3.client("apigatewaymanagementapi",
    endpoint_url=f"https://{os.environ['WS_API_ID']}.execute-api.{os.environ['AWS_REGION']}.amazonaws.com/{os.environ['WS_STAGE']}"
)

# ---------- Helpers ----------
def log(trace, msg, **kwargs):
    print(json.dumps({"trace": trace, "msg": msg, **kwargs}, default=str))

def send_to_connection(conn_id, data):
    """Envia mensagem para uma conexão específica"""
    try:
        apigw.post_to_connection(ConnectionId=conn_id, Data=json.dumps(data).encode("utf-8"))
    except apigw.exceptions.GoneException:
        # Conexão morta -> remover
        conn_table.delete_item(Key={"connectionId": conn_id})
        log("broadcast", "Conexão removida (GoneException)", connectionId=conn_id)

def broadcast(data):
    """Envia mensagem para todos conectados"""
    conns = conn_table.scan().get("Items", [])
    for c in conns:
        send_to_connection(c["connectionId"], data)

def update_chamado(trace, chamado, update):
    """Atualiza DynamoDB no chamado"""
    log(trace, "Atualizando chamado", chamado=chamado, update=update)
    resp = table.update_item(
        Key={"chamado": chamado},
        UpdateExpression="SET " + ", ".join(f"#{k} = :{k}" for k in update.keys()),
        ExpressionAttributeNames={f"#{k}": k for k in update.keys()},
        ExpressionAttributeValues={f":{k}": v for k, v in update.items()},
        ReturnValues="ALL_NEW"
    )
    log(trace, "Chamado atualizado", new_state=resp.get("Attributes"))
    return resp.get("Attributes")

# ---------- Handlers ----------
def handle_connect(event, trace):
    conn_id = event["requestContext"]["connectionId"]
    conn_table.put_item(Item={"connectionId": conn_id, "connectedAt": datetime.now(timezone.utc).isoformat()})
    log(trace, "Novo cliente conectado", connectionId=conn_id)
    return {"statusCode": 200}

def handle_disconnect(event, trace):
    conn_id = event["requestContext"]["connectionId"]
    conn_table.delete_item(Key={"connectionId": conn_id})
    log(trace, "Cliente desconectado", connectionId=conn_id)
    return {"statusCode": 200}

def handle_start_timer(event, trace, body):
    chamado = int(body["chamado"])
    level = int(body["level"])
    duration = int(body.get("duration", 1200))  # padrão 20min
    now = datetime.now(timezone.utc).isoformat()

    update = {
        f"level{level}_timerStart": now,
        f"level{level}_duration": duration,
        f"level{level}_status": "running"
    }
    state = update_chamado(trace, chamado, update)
    broadcast({"event": "startTimer", "chamado": chamado, "level": level, "state": state})
    return {"statusCode": 200, "body": "Timer iniciado"}

def handle_update_observacao(event, trace, body):
    chamado = int(body["chamado"])
    level = int(body["level"])
    obs = body["observacao"]
    update = {f"level{level}_observacao": obs}
    state = update_chamado(trace, chamado, update)
    broadcast({"event": "updateObservacao", "chamado": chamado, "level": level, "state": state})
    return {"statusCode": 200, "body": "Observação atualizada"}

def handle_update_operador(event, trace, body):
    chamado = int(body["chamado"])
    operador = body["operador"]
    update = {"operador": operador}
    state = update_chamado(trace, chamado, update)
    broadcast({"event": "updateOperador", "chamado": chamado, "state": state})
    return {"statusCode": 200, "body": "Operador atualizado"}

def handle_update_status_final(event, trace, body):
    chamado = int(body["chamado"])
    status = body["status"]
    update = {"statusFinal": status}
    state = update_chamado(trace, chamado, update)
    broadcast({"event": "updateStatusFinal", "chamado": chamado, "state": state})
    return {"statusCode": 200, "body": "Status final atualizado"}

def handle_get_state(event, trace, body):
    chamado = int(body["chamado"])
    resp = table.get_item(Key={"chamado": chamado})
    state = resp.get("Item", {})
    log(trace, "Estado retornado", chamado=chamado, state=state)
    return {"statusCode": 200, "body": json.dumps(state)}

# ---------- Main ----------
def lambda_handler(event, context):
    trace = str(uuid.uuid4())[:8]
    log(trace, "invoke", routeKey=event["requestContext"]["routeKey"], connectionId=event["requestContext"]["connectionId"], body=event.get("body"))

    route = event["requestContext"]["routeKey"]

    # Roteamento
    try:
        if route == "$connect":
            return handle_connect(event, trace)
        elif route == "$disconnect":
            return handle_disconnect(event, trace)
        else:
            # Mensagens normais -> parse body
            body = json.loads(event.get("body") or "{}")

            if route == "startTimer":
                return handle_start_timer(event, trace, body)
            elif route == "updateObservacao":
                return handle_update_observacao(event, trace, body)
            elif route == "updateOperador":
                return handle_update_operador(event, trace, body)
            elif route == "updateStatusFinal":
                return handle_update_status_final(event, trace, body)
            elif route == "getState":
                return handle_get_state(event, trace, body)
            else:
                log(trace, "Rota inválida", route=route)
                return {"statusCode": 400, "body": "Invalid route"}
    except Exception as e:
        log(trace, "Erro na execução", error=str(e))
        return {"statusCode": 500, "body": f"Erro: {str(e)}"}

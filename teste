import json
import boto3
import os
import decimal
from datetime import datetime
from collections import defaultdict

dynamodb = boto3.resource("dynamodb")
connections_table = dynamodb.Table(os.environ["CONNECTIONS_TABLE"])
chamados_table = dynamodb.Table(os.environ["CHAMADOS_TABLE"])

# ----- Decimal → JSON -----
class DecimalEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, decimal.Decimal):
            return int(o) if o % 1 == 0 else float(o)
        return super(DecimalEncoder, self).default(o)

def to_json(data):
    return json.dumps(data, cls=DecimalEncoder)

# ----- Handler -----
def lambda_handler(event, context):
    route = event["requestContext"]["routeKey"]

    if route == "$connect":
        return on_connect(event)
    elif route == "$disconnect":
        return on_disconnect(event)
    elif route == "startTimer":
        return start_timer(event)
    elif route == "updateStatus":
        return update_status(event)
    else:
        return {"statusCode": 400, "body": "Rota inválida"}

# ----- $connect -----
def on_connect(event):
    rc = event["requestContext"]
    connection_id = rc["connectionId"]
    domain_name = rc["domainName"]          # p.ex. abc123.execute-api.sa-east-1.amazonaws.com
    stage = rc["stage"]                      # p.ex. "prod"

    # Salva conexão com domínio e stage (fundamental p/ broadcast correto)
    connections_table.put_item(
        Item={
            "connectionId": connection_id,
            "connectedAt": int(datetime.utcnow().timestamp()),
            "domainName": domain_name,
            "stage": stage,
        }
    )
    print(f"[DEBUG] Conexão registrada: {connection_id} @ {domain_name}/{stage}")

    # Envia estado atual dos chamados para o NOVO cliente
    mgmt = boto3.client(
        "apigatewaymanagementapi",
        endpoint_url=f"https://{domain_name}/{stage}",
    )

    response = chamados_table.scan()
    items = response.get("Items", [])
    print(f"[DEBUG] Itens atuais (chamados): {to_json(items)}")

    for item in items:
        msg = {
            "action": "currentState",
            "chamado": int(item["chamado"]),
            "status": str(item.get("status", "pendente")),
            "timerStart": int(item["timerStart"]) if "timerStart" in item else None,  # seg
            # Se preferir já em ms: use int(item["timerStart"]) * 1000
        }
        try:
            mgmt.post_to_connection(Data=to_json(msg), ConnectionId=connection_id)
        except mgmt.exceptions.GoneException:
            print(f"[WARN] Conexão {connection_id} Gone no $connect. Removendo.")
            connections_table.delete_item(Key={"connectionId": connection_id})
            break
        except Exception as e:
            print(f"[ERROR] Falha ao enviar estado inicial p/ {connection_id}: {e}")

    return {"statusCode": 200}

# ----- $disconnect -----
def on_disconnect(event):
    connection_id = event["requestContext"]["connectionId"]
    connections_table.delete_item(Key={"connectionId": connection_id})
    print(f"[DEBUG] Conexão removida: {connection_id}")
    return {"statusCode": 200}

# ----- startTimer -----
def start_timer(event):
    body = json.loads(event["body"])
    chamado = int(body["chamado"])

    # Em segundos (compatível com sua versão funcional).
    # Se quiser em ms: trocar para int(datetime.utcnow().timestamp() * 1000)
    timer_start = int(datetime.utcnow().timestamp())

    chamados_table.put_item(
        Item={
            "chamado": chamado,
            "timerStart": timer_start,
            "status": "pendente",
        }
    )
    print(f"[DEBUG] Chamado salvo: {chamado} - timerStart={timer_start}s")

    _broadcast({
        "action": "timerStarted",
        "chamado": chamado,
        "timerStart": timer_start,
    })

    return {"statusCode": 200}

# ----- updateStatus -----
def update_status(event):
    body = json.loads(event["body"])
    chamado = int(body["chamado"])
    status = body["status"]

    chamados_table.update_item(
        Key={"chamado": chamado},
        UpdateExpression="SET #s = :s",
        ExpressionAttributeNames={"#s": "status"},
        ExpressionAttributeValues={":s": status},
    )
    print(f"[DEBUG] Status atualizado: {chamado} -> {status}")

    _broadcast({
        "action": "statusUpdated",
        "chamado": chamado,
        "status": status,
    })

    return {"statusCode": 200}

# ----- broadcast dinâmico por (domain, stage) -----
def _broadcast(message):
    connections = connections_table.scan().get("Items", [])
    if not connections:
        print("[DEBUG] Broadcast: 0 conexões. Nada a enviar.")
        return

    # Agrupa conexões por (domainName, stage) e cria 1 client por grupo
    groups = defaultdict(list)
    for c in connections:
        dn = c.get("domainName")
        st = c.get("stage")
        if not dn or not st:
            # Conexões antigas sem domínio/stage ⇒ ignore ou trate com um endpoint padrão se necessário
            print(f"[WARN] Conexão {c.get('connectionId')} sem domain/stage. Ignorando.")
            continue
        groups[(dn, st)].append(c["connectionId"])

    print(f"[DEBUG] Broadcast groups: { {k: len(v) for k,v in groups.items()} }  message={message}")

    for (domain_name, stage), conn_ids in groups.items():
        mgmt = boto3.client(
            "apigatewaymanagementapi",
            endpoint_url=f"https://{domain_name}/{stage}",
        )
        for cid in conn_ids:
            try:
                mgmt.post_to_connection(Data=to_json(message), ConnectionId=cid)
            except mgmt.exceptions.GoneException:
                print(f"[WARN] Conexão {cid} Gone. Removendo.")
                connections_table.delete_item(Key={"connectionId": cid})
            except Exception as e:
                print(f"[ERROR] Falha ao enviar para {cid}: {e}")

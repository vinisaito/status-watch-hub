import json
import boto3
import os
import decimal
import uuid
import sys
from datetime import datetime

# ---------- Config ----------
dynamodb = boto3.resource("dynamodb", region_name="us-east-1")
connections_table = dynamodb.Table(os.environ["CONNECTIONS_TABLE"])  # PK: connectionId
chamados_table = dynamodb.Table(os.environ["CHAMADOS_TABLE"])        # PK: chamado (Number)

DISABLE_APIGW_POST = os.environ.get("DISABLE_APIGW_POST", "0") == "1"

# ---------- Utils ----------
class DecimalEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, decimal.Decimal):
            return int(o) if o % 1 == 0 else float(o)
        return super().default(o)

def to_json(data):
    return json.dumps(data, cls=DecimalEncoder)

TRACE_ID = None
def log(msg, **kwargs):
    global TRACE_ID
    if not TRACE_ID:
        TRACE_ID = str(uuid.uuid4())[:8]
    payload = {"trace": TRACE_ID, "msg": msg}
    payload.update(kwargs)
    print(json.dumps(payload, default=str))
    sys.stdout.flush()

def now_ts():
    return int(datetime.utcnow().timestamp())

def get_apigw_client(event):
    rc = event["requestContext"]
    endpoint_url = f"https://{rc['domainName']}/{rc['stage']}"
    log("get_apigw_client", endpoint_url=endpoint_url)
    return boto3.client("apigatewaymanagementapi", endpoint_url=endpoint_url)

def send_to_connection(apigw, connection_id, message: dict):
    if DISABLE_APIGW_POST:
        log("post_to_connection SKIPPED", connectionId=connection_id, action=message.get("action"))
        return True
    try:
        apigw.post_to_connection(Data=to_json(message), ConnectionId=connection_id)
        log("post_to_connection OK", connectionId=connection_id, action=message.get("action"))
        return True
    except apigw.exceptions.GoneException:
        log("GoneException - removendo conex√£o", connectionId=connection_id)
        connections_table.delete_item(Key={"connectionId": connection_id})
        return False
    except Exception as e:
        log("post_to_connection ERROR", connectionId=connection_id, error=str(e))
        return False

def broadcast(event, message):
    if DISABLE_APIGW_POST:
        log("broadcast SKIPPED", action=message.get("action"), chamado=message.get("chamado"))
        return {"statusCode": 200, "body": "broadcast skipped"}

    apigw = get_apigw_client(event)
    scan = connections_table.scan()
    connections = scan.get("Items", [])
    log("broadcast begin", total=len(connections), action=message.get("action"))

    sent = 0
    for conn in connections:
        if send_to_connection(apigw, conn["connectionId"], message):
            sent += 1
    log("broadcast end", sent=sent, total=len(connections))
    return {"statusCode": 200, "body": f"Mensagem enviada para {sent}/{len(connections)} conex√µes"}

# ---------- Handler ----------
def lambda_handler(event, context):
    global TRACE_ID
    TRACE_ID = str(uuid.uuid4())[:8]

    print("=== Lambda Iniciada ===", flush=True)
    print(json.dumps(event, default=str), flush=True)

    rc = event.get("requestContext")
    if not isinstance(rc, dict):
        return {"statusCode": 400, "body": "Evento inv√°lido: faltou requestContext"}

    # üîë Sempre tenta parsear o body em dict
    body_raw = event.get("body")
    body = {}
    if body_raw:
        if isinstance(body_raw, str):
            try:
                body = json.loads(body_raw)
            except Exception as e:
                log("JSON parse error", error=str(e), bodyRaw=body_raw)
                body = {}
        elif isinstance(body_raw, dict):
            body = body_raw
    event["parsedBody"] = body   # guarda parse seguro para todas as rotas

    return _dispatch(event)

def _dispatch(event):
    route = event["requestContext"]["routeKey"]
    rc = event["requestContext"]
    body = event.get("parsedBody", {})

    log("invoke", routeKey=route, connectionId=rc.get("connectionId"), body=body)

    try:
        if route == "$connect":
            return on_connect(event)
        elif route == "$disconnect":
            return on_disconnect(event)
        elif route == "getState":
            return get_state(event, body)
        elif route == "startTimer":
            return start_timer(event, body)
        elif route == "updateOperador":
            return update_operador(event, body)
        elif route == "updateObservacao":
            return update_observacao(event, body)
        elif route == "updateStatusFinal":
            return update_status_final(event, body)
        elif route == "updateStatus":
            return update_status(event, body)
        elif route == "$default":
            action = body.get("action")
            if action in ("getState", "startTimer", "updateOperador",
                          "updateObservacao", "updateStatusFinal", "updateStatus"):
                event2 = dict(event)
                event2["requestContext"]["routeKey"] = action
                return _dispatch(event2)
            return {"statusCode": 200, "body": "no-op $default"}
        else:
            return {"statusCode": 400, "body": "rota inv√°lida"}
    except Exception as e:
        log("dispatch ERROR", error=str(e))
        return {"statusCode": 500, "body": str(e)}

# ---------- Rotas ----------
def on_connect(event):
    connection_id = event["requestContext"]["connectionId"]
    connections_table.put_item(Item={"connectionId": connection_id, "connectedAt": now_ts()})
    log("on_connect OK", connectionId=connection_id)
    return {"statusCode": 200}

def on_disconnect(event):
    connection_id = event["requestContext"]["connectionId"]
    connections_table.delete_item(Key={"connectionId": connection_id})
    log("on_disconnect OK", connectionId=connection_id)
    return {"statusCode": 200}

def start_timer(event, body):
    chamado = int(body["chamado"])
    timer = body["timer"]

    duration = 20*60 if timer == "primeiroAcionado" else 10*60
    timer_start = now_ts()
    timer_end = timer_start + duration

    update_expr = f"SET {timer} = :val"
    chamados_table.update_item(
        Key={"chamado": chamado},
        UpdateExpression=update_expr,
        ExpressionAttributeValues={
            ":val": {"timerStart": timer_start, "timerEnd": timer_end, "observacao": body.get("observacao", "")}
        }
    )

    item = chamados_table.get_item(Key={"chamado": chamado}).get("Item", {})
    message = {"action": "timerStarted", "chamado": chamado, "serverTime": now_ts(), "duration": duration, **item}
    return broadcast(event, message)

def update_operador(event, body):
    chamado = int(body["chamado"])
    operador = body["operador"]

    chamados_table.update_item(
        Key={"chamado": chamado},
        UpdateExpression="SET operador = :o",
        ExpressionAttributeValues={":o": operador},
    )
    message = {"action": "operadorUpdated", "chamado": chamado, "operador": operador}
    return broadcast(event, message)

def update_observacao(event, body):
    chamado = int(body["chamado"])
    timer = body["timer"]
    observacao = body["observacao"]

    update_expr = f"SET {timer}.observacao = :obs"
    chamados_table.update_item(
        Key={"chamado": chamado},
        UpdateExpression=update_expr,
        ExpressionAttributeValues={":obs": observacao},
    )
    message = {"action": "observacaoUpdated", "chamado": chamado, "timer": timer, "observacao": observacao}
    return broadcast(event, message)

def update_status_final(event, body):
    chamado = int(body["chamado"])
    status_final = body["statusFinal"]

    chamados_table.update_item(
        Key={"chamado": chamado},
        UpdateExpression="SET statusFinal = :s",
        ExpressionAttributeValues={":s": status_final},
    )
    message = {"action": "statusFinalUpdated", "chamado": chamado, "statusFinal": status_final}
    return broadcast(event, message)

def update_status(event, body):
    chamado = int(body["chamado"])
    status = str(body["status"])

    chamados_table.update_item(
        Key={"chamado": chamado},
        UpdateExpression="SET #s = :s",
        ExpressionAttributeNames={"#s": "status"},
        ExpressionAttributeValues={":s": status},
    )
    message = {"action": "statusUpdated", "chamado": chamado, "status": status}
    return broadcast(event, message)

def get_state(event, body):
    chamado = int(body["chamado"])
    connection_id = event["requestContext"]["connectionId"]

    item = chamados_table.get_item(Key={"chamado": chamado}).get("Item", {})
    message = {"action": "currentState", "chamado": chamado, "serverTime": now_ts(), **item}

    if DISABLE_APIGW_POST:
        log("get_state SKIPPED", connectionId=connection_id)
        return {"statusCode": 200}

    apigw = get_apigw_client(event)
    send_to_connection(apigw, connection_id, message)
    return {"statusCode": 200}

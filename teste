import React, { useState, useEffect, useCallback } from 'react';
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Play, Clock, Check, CheckCircle, FastForward, RotateCcw, X } from "lucide-react";

// Tipos para a estrutura da API
interface EscalationLevel {
  level: number;
  status: string;
  observations: string;
  eventTimestamp: string;
}

interface EscalationData {
  escalations: EscalationLevel[];
  obsChat: string;
  chamado: number;
  confirmChat: string;
  sendChat: string;
  ttl: number;
  alertOpenTime: string;
}

interface AlertData {
  chamado: number;
  // Adicione outros campos necessários do seu AlertData
}

interface EscalationState {
  status: 'pending' | 'confirmed' | 'escalating' | 'completed';
  currentLevel: number;
  timeRemaining: number;
  timerActive: boolean;
  observations: string;
  isAttended: boolean;
}

interface PendingStatusChange {
  status: string;
  observations: string;
}

// URL da API
const API_URL = 'https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/acompanhamento';

const EscalationColumn: React.FC<{ alert: AlertData }> = ({ alert }) => {
  // Estados para gerenciar dados da API
  const [escalationData, setEscalationData] = useState<EscalationData | null>(null);
  const [escalationStates, setEscalationStates] = useState<Record<number, EscalationState>>({});
  const [confirmationObservations, setConfirmationObservations] = useState<Record<number, string>>({});
  const [showStatusConfirmation, setShowStatusConfirmation] = useState<Record<number, boolean>>({});
  const [pendingStatusChange, setPendingStatusChange] = useState<Record<number, PendingStatusChange>>({});
  const [loading, setLoading] = useState(false);

  // Buscar dados da API
  const fetchEscalationData = useCallback(async (chamado: number) => {
    try {
      const response = await fetch(`${API_URL}?chamado=${chamado}`);
      if (response.ok) {
        const data: EscalationData[] = await response.json();
        if (data.length > 0) {
          const escalationInfo = data[0];
          setEscalationData(escalationInfo);
          
          // Converter dados da API para estado local
          const state = convertApiDataToState(escalationInfo);
          setEscalationStates(prev => ({
            ...prev,
            [chamado]: state
          }));
          
          // Definir observações de confirmação
          if (escalationInfo.confirmChat) {
            setConfirmationObservations(prev => ({
              ...prev,
              [chamado]: escalationInfo.confirmChat
            }));
          }
        }
      }
    } catch (error) {
      console.error('Erro ao buscar dados de escalação:', error);
    }
  }, []);

  // Atualizar dados na API
  const updateEscalationData = useCallback(async (chamado: number, updates: Partial<EscalationData>) => {
    try {
      setLoading(true);
      const response = await fetch(API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          chamado,
          ...updates,
        }),
      });
      
      if (response.ok) {
        // Atualizar dados locais após sucesso
        await fetchEscalationData(chamado);
      }
    } catch (error) {
      console.error('Erro ao atualizar dados de escalação:', error);
    } finally {
      setLoading(false);
    }
  }, [fetchEscalationData]);

  // Converter dados da API para estado local
  const convertApiDataToState = (data: EscalationData): EscalationState => {
    const currentEscalation = data.escalations.find(e => e.status === 'active') || data.escalations[0];
    
    // Calcular tempo restante baseado no timestamp
    let timeRemaining = 0;
    let timerActive = false;
    
    if (currentEscalation.eventTimestamp && currentEscalation.status === 'active') {
      const eventTime = new Date(currentEscalation.eventTimestamp).getTime();
      const now = Date.now();
      const elapsed = (now - eventTime) / 1000;
      const timeLimit = 1800; // 30 minutos
      timeRemaining = Math.max(0, timeLimit - elapsed);
      timerActive = timeRemaining > 0;
    }

    // Determinar status baseado nos dados
    let status: EscalationState['status'] = 'pending';
    if (data.confirmChat && !data.escalations.some(e => e.status === 'active')) {
      status = 'confirmed';
    } else if (data.escalations.some(e => e.status === 'completed')) {
      status = 'completed';
    } else if (data.escalations.some(e => e.status === 'active' || e.status === 'escalated')) {
      status = 'escalating';
    }

    return {
      status,
      currentLevel: currentEscalation.level,
      timeRemaining,
      timerActive,
      observations: data.confirmChat || data.obsChat || '',
      isAttended: data.escalations.some(e => e.status === 'attended')
    };
  };

  // Carregar dados quando o componente monta
  useEffect(() => {
    fetchEscalationData(alert.chamado);
    
    // Polling para manter dados atualizados
    const interval = setInterval(() => {
      fetchEscalationData(alert.chamado);
    }, 5000); // Atualiza a cada 5 segundos

    return () => clearInterval(interval);
  }, [alert.chamado, fetchEscalationData]);

  // Timer para contagem regressiva
  useEffect(() => {
    const timer = setInterval(() => {
      setEscalationStates(prev => {
        const newStates = { ...prev };
        Object.keys(newStates).forEach(chamadoKey => {
          const chamado = parseInt(chamadoKey);
          const state = newStates[chamado];
          if (state?.timerActive && state.timeRemaining > 0) {
            newStates[chamado] = {
              ...state,
              timeRemaining: state.timeRemaining - 1
            };
            
            // Se o tempo acabou, avançar escalação automaticamente
            if (newStates[chamado].timeRemaining <= 0) {
              newStates[chamado].timerActive = false;
              // Lógica para avançar escalação pode ser implementada aqui
            }
          }
        });
        return newStates;
      });
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  // Função para formatar tempo
  const formatTime = (seconds: number): string => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  // Função para iniciar confirmação
  const startConfirmation = async (chamado: number) => {
    const newEscalationData: Partial<EscalationData> = {
      alertOpenTime: new Date().toISOString(),
      sendChat: new Date().toISOString(),
      escalations: [
        { level: 1, status: 'pending', observations: '', eventTimestamp: new Date().toISOString() },
        { level: 2, status: '', observations: '', eventTimestamp: '' },
        { level: 3, status: '', observations: '', eventTimestamp: '' },
        { level: 4, status: '', observations: '', eventTimestamp: '' }
      ]
    };
    
    await updateEscalationData(chamado, newEscalationData);
  };

  // Função para confirmar recebimento
  const confirmReceived = async (chamado: number) => {
    const observation = confirmationObservations[chamado];
    if (!observation?.trim()) return;

    const updates: Partial<EscalationData> = {
      confirmChat: observation,
      escalations: escalationData?.escalations.map(e => 
        e.level === 1 ? { ...e, status: 'confirmed', observations: observation } : e
      ) || []
    };

    await updateEscalationData(chamado, updates);
  };

  // Função para iniciar escalação
  const startEscalation = async (chamado: number, level: 1 | 2 | 3 | 4) => {
    const updates: Partial<EscalationData> = {
      escalations: escalationData?.escalations.map(e => 
        e.level === level ? { 
          ...e, 
          status: 'active', 
          eventTimestamp: new Date().toISOString() 
        } : e.level < level ? {
          ...e,
          status: 'escalated'
        } : e
      ) || []
    };

    await updateEscalationData(chamado, updates);
  };

  // Função para voltar escalação
  const goBackEscalation = async (chamado: number) => {
    const currentLevel = escalationStates[chamado]?.currentLevel || 1;
    const previousLevel = Math.max(1, currentLevel - 1);
    
    const updates: Partial<EscalationData> = {
      escalations: escalationData?.escalations.map(e => 
        e.level === previousLevel ? { 
          ...e, 
          status: 'active', 
          eventTimestamp: new Date().toISOString() 
        } : e.level > previousLevel ? {
          ...e,
          status: '',
          eventTimestamp: ''
        } : e
      ) || []
    };

    await updateEscalationData(chamado, updates);
  };

  // Função para preparar mudança de status
  const prepareStatusChange = (chamado: number, status: string) => {
    setShowStatusConfirmation(prev => ({ ...prev, [chamado]: true }));
    setPendingStatusChange(prev => ({
      ...prev,
      [chamado]: { status, observations: '' }
    }));
  };

  // Função para confirmar mudança de status
  const confirmStatusChange = async (chamado: number) => {
    const pending = pendingStatusChange[chamado];
    if (!pending?.observations?.trim()) return;

    const currentLevel = escalationStates[chamado]?.currentLevel || 1;
    const finalStatus = pending.status === 'attended' ? 'attended' : 'completed';
    
    const updates: Partial<EscalationData> = {
      obsChat: pending.observations,
      escalations: escalationData?.escalations.map(e => 
        e.level === currentLevel ? { 
          ...e, 
          status: finalStatus, 
          observations: pending.observations 
        } : e
      ) || []
    };

    await updateEscalationData(chamado, updates);
    
    // Limpar estados locais
    setShowStatusConfirmation(prev => ({ ...prev, [chamado]: false }));
    setPendingStatusChange(prev => {
      const newState = { ...prev };
      delete newState[chamado];
      return newState;
    });
  };

  // Função para cancelar mudança de status
  const cancelStatusChange = (chamado: number) => {
    setShowStatusConfirmation(prev => ({ ...prev, [chamado]: false }));
    setPendingStatusChange(prev => {
      const newState = { ...prev };
      delete newState[chamado];
      return newState;
    });
  };

  // Função para lidar com mudança de observação de confirmação
  const handleConfirmationObservationChange = (chamado: number, value: string) => {
    setConfirmationObservations(prev => ({ ...prev, [chamado]: value }));
  };

  // Função para lidar com mudança de observação pendente
  const handlePendingObservationChange = (chamado: number, value: string) => {
    setPendingStatusChange(prev => ({
      ...prev,
      [chamado]: { ...prev[chamado], observations: value }
    }));
  };

  // Renderizar coluna de confirmação
  const renderConfirmationColumn = (alert: AlertData) => {
    const state = escalationStates[alert.chamado];
    const currentObservation = confirmationObservations[alert.chamado] || '';
    const showConfirmation = showStatusConfirmation[alert.chamado];
    const pendingChange = pendingStatusChange[alert.chamado];
    
    // Debug: log do estado atual
    console.log(`Renderizando coluna confirmação para chamado ${alert.chamado}:`, {
      state,
      currentObservation,
      showConfirmation,
      pendingChange
    });
    
    if (loading) {
      return (
        <div className="text-center">
          <div className="animate-spin h-4 w-4 border-2 border-primary border-t-transparent rounded-full mx-auto"></div>
        </div>
      );
    }
    
    if (!state) {
      return (
        <div className="text-center">
          <Button
            size="sm"
            variant="outline"
            onClick={() => startConfirmation(alert.chamado)}
            className="h-8 px-3 text-xs"
          >
            <Play className="h-3 w-3 mr-1" />
            Iniciar
          </Button>
        </div>
      );
    }

    switch (state.status) {
      case 'pending':
        return (
          <div className="text-center space-y-3">
            <div className="flex items-center justify-center gap-2">
              <Clock className="h-4 w-4 text-warning" />
              <span className="text-sm font-mono">{formatTime(state.timeRemaining)}</span>
            </div>
            
            <div className="space-y-2">
               <div className="space-y-1">
                 <Label className="text-xs">
                   Observações <span className="text-destructive">*</span>
                 </Label>
                 <Textarea
                   key={`confirmation-textarea-${alert.chamado}`}
                   placeholder="Observações são obrigatórias para confirmação"
                   value={currentObservation}
                   onChange={(e) => handleConfirmationObservationChange(alert.chamado, e.target.value)}
                   className="text-xs min-h-[60px] resize-none"
                   required
                 />
                 {!currentObservation.trim() && (
                   <p className="text-xs text-destructive">
                     Observações são obrigatórias
                   </p>
                 )}
               </div>
              
              <div className="flex gap-1">
                <Button
                  size="sm"
                  variant="default"
                  onClick={() => confirmReceived(alert.chamado)}
                  disabled={!currentObservation.trim()}
                  className="h-8 px-3 text-xs flex-1 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Check className="h-3 w-3 mr-1" />
                  Confirmar
                </Button>
                <Button
                  size="sm"
                  variant="secondary"
                  onClick={() => startEscalation(alert.chamado, 1)}
                  disabled={!currentObservation.trim()}
                  className="h-8 px-3 text-xs flex-1 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <FastForward className="h-3 w-3 mr-1" />
                  Próxima Etapa
                </Button>
              </div>
            </div>
          </div>
        );

      case 'confirmed':
        return (
          <div className="text-center space-y-2">
            <div className="flex gap-1 justify-center">
              <Badge variant="default" className="bg-green-600 text-white">
                <CheckCircle className="h-3 w-3 mr-1" />
                Confirmado
              </Badge>
              <Button
                size="sm"
                variant="outline"
                onClick={() => startEscalation(alert.chamado, 1)}
                className="h-6 px-2 text-xs"
              >
                <FastForward className="h-3 w-3 mr-1" />
                Próxima
              </Button>
            </div>
            {state.observations && (
              <div className="text-xs text-muted-foreground p-2 bg-muted rounded text-left">
                <strong>Observações:</strong><br />
                {state.observations}
              </div>
            )}
          </div>
        );

      case 'escalating':
        const levelNames = { 1: '1ª', 2: '2ª', 3: '3ª', 4: '4ª' };
        
        return (
          <div className="space-y-2">
            {state.currentLevel > 0 && (
              <div className="text-center">
                <Badge variant="destructive" className="text-xs">
                  {levelNames[state.currentLevel as keyof typeof levelNames]} Escalação
                </Badge>
                {state.timerActive && (
                  <div className="flex items-center justify-center gap-1 mt-1">
                    <Clock className="h-3 w-3 text-warning" />
                    <span className="text-xs font-mono">{formatTime(state.timeRemaining)}</span>
                  </div>
                )}
              </div>
            )}

            {!state.isAttended && (
              <>
                {/* Campo de observações sempre visível quando em escalação */}
                {state.currentLevel === 0 || (!state.timerActive && state.currentLevel < 4) ? (
                  <div className="space-y-1">
                    <div className="flex gap-1">
                      {/* Botão Voltar - só aparece se não estiver no nível 0 */}
                      {state.currentLevel > 0 && (
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => goBackEscalation(alert.chamado)}
                          className="h-6 px-2 text-xs flex-1"
                        >
                          <RotateCcw className="h-3 w-3 mr-1" />
                          Voltar
                        </Button>
                      )}
                      
                       {/* Próxima escalação */}
                       {state.currentLevel < 4 && (
                         <Button
                           size="sm"
                           variant="outline"
                           onClick={() => startEscalation(alert.chamado, (state.currentLevel + 1) as 1 | 2 | 3 | 4)}
                           className="h-6 px-2 text-xs flex-1"
                         >
                           Iniciar {levelNames[(state.currentLevel + 1) as keyof typeof levelNames]} Escalação
                         </Button>
                       )}
                    </div>
                  </div>
                ) : (
                  <div className="space-y-2">
                    {/* Mostrar confirmação de status quando pendente */}
                    {showConfirmation ? (
                      <div className="space-y-2 p-2 border rounded bg-background">
                        <div className="text-xs font-medium">
                          Confirmar: {pendingChange?.status === 'attended' ? 'Atendida' : 'Não Atendida'}
                        </div>
                        
                         <div className="space-y-1">
                           <Label className="text-xs">
                             Observações <span className="text-destructive">*</span>
                           </Label>
                           <Textarea
                             key={`pending-textarea-${alert.chamado}`}
                             placeholder="Observações obrigatórias..."
                             value={pendingChange?.observations || ''}
                             onChange={(e) => handlePendingObservationChange(alert.chamado, e.target.value)}
                             className="text-xs min-h-[60px] resize-none"
                             required
                           />
                           {!pendingChange?.observations?.trim() && (
                             <p className="text-xs text-destructive">
                               Observações são obrigatórias
                             </p>
                           )}
                         </div>
                        
                        <div className="flex gap-1">
                          <Button
                            size="sm"
                            variant="default"
                            onClick={() => confirmStatusChange(alert.chamado)}
                            disabled={!pendingChange?.observations?.trim()}
                            className="h-6 px-2 text-xs flex-1"
                          >
                            <Check className="h-3 w-3 mr-1" />
                            Confirmar
                          </Button>
                          <Button
                            size="sm"
                            variant="outline"
                            onClick={() => cancelStatusChange(alert.chamado)}
                            className="h-6 px-2 text-xs flex-1"
                          >
                            <X className="h-3 w-3 mr-1" />
                            Cancelar
                          </Button>
                        </div>
                      </div>
                    ) : (
                      <>
                        <div className="flex gap-1">
                          {/* Botão Voltar */}
                          <Button
                            size="sm"
                            variant="outline"
                            onClick={() => goBackEscalation(alert.chamado)}
                            className="h-6 px-2 text-xs flex-1"
                          >
                            <RotateCcw className="h-3 w-3 mr-1" />
                            Voltar
                          </Button>
                          
                          {/* Botão Avançar Escalação sempre visível quando há observações */}
                        </div>

                        <Select
                          value=""
                          onValueChange={(value) => prepareStatusChange(alert.chamado, value)}
                        >
                          <SelectTrigger className="h-6 text-xs">
                            <SelectValue placeholder="Selecionar Status" />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="attended">Atendida</SelectItem>
                            <SelectItem value="not-attended">Não Atendida</SelectItem>
                          </SelectContent>
                        </Select>
                      </>
                    )}
                  </div>
                )}
              </>
            )}
          </div>
        );

      case 'completed':
        return (
          <div className="text-center space-y-2">
            <div className="flex gap-1 justify-center">
              <Badge variant="default" className="bg-green-600 text-white">
                <CheckCircle className="h-3 w-3 mr-1" />
                Finalizado
              </Badge>
            </div>
            {state.observations && (
              <div className="text-xs text-muted-foreground p-2 bg-muted rounded text-left">
                <strong>Observações:</strong><br />
                {state.observations}
              </div>
            )}
          </div>
        );

      default:
        return null;
    }
  };

  return renderConfirmationColumn(alert);
};

export default EscalationColumn;

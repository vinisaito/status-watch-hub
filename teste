import os
import pyodbc
import json
import time
import boto3
from datetime import datetime
from botocore.exceptions import ClientError, BotoCoreError

def lambda_handler(event, context):
    start_total = time.time()
    print("[INÍCIO] Execução da Lambda")
    print("Evento recebido:", json.dumps(event))

    results = []
    errors = []

    try:
        # ---------- Variáveis de ambiente ----------
        server = os.environ['DB_SERVER']
        username = os.environ['DB_USER']
        password = os.environ['DB_PASSWORD']
        port = os.environ.get('DB_PORT', '1433')
        database = 'mdb'
        api_endpoint = os.environ['WEBSOCKET_API_ENDPOINT']  # ex: https://xxxxx.execute-api.us-east-1.amazonaws.com/prod

        # ---------- Dados do evento ----------
        connection_id = event["requestContext"]["connectionId"]
        route_key = event["requestContext"]["routeKey"]

        print(f"[WS] routeKey={route_key}, connectionId={connection_id}")

        if route_key != "getAlerts":
            return {
                "statusCode": 400,
                "body": json.dumps({"error": f"Rota {route_key} não suportada"})
            }

        # ---------- Conexão com o banco ----------
        try:
            connection_string = (
                f'DRIVER={{ODBC Driver 18 for SQL Server}};'
                f'SERVER={server},{port};'
                f'DATABASE={database};'
                f'UID={username};'
                f'PWD={password};'
                f'Encrypt=no;TrustServerCertificate=yes;'
                f'CHARSET=UTF8;'
            )
            start_conn = time.time()
            conn = pyodbc.connect(connection_string, timeout=5)
            cursor = conn.cursor()
            print(f"[DB] Conectado em {time.time() - start_conn:.2f}s")
        except Exception as db_err:
            raise RuntimeError(f"Erro ao conectar ao banco: {db_err}")

        # ---------- Query ----------
        query = """
            SELECT [chamado]
                  ,[tipo_chamado]
                  ,[status_chamado]
                  ,[abertura_chamado]
                  ,[resumo_chamado]
                  ,[grupo_chamado]
                  ,[severidade_chamado]
                  ,[acionado]
            FROM [mdb].[dbo].[view_ciops_acionamento]
            WHERE TRY_CONVERT(DATETIME, abertura_chamado, 103) >= DATEADD(HOUR, -10, GETDATE());
        """
        try:
            start_query = time.time()
            cursor.execute(query)
            rows = cursor.fetchall()
            print(f"[DB] Query executada em {time.time() - start_query:.2f}s, total {len(rows)} linhas")
        except Exception as q_err:
            raise RuntimeError(f"Erro ao executar query: {q_err}")

        # ---------- Processamento ----------
        try:
            start_proc = time.time()
            columns = [column[0] for column in cursor.description]
            for row in rows:
                row_dict = dict(zip(columns, row))
                if isinstance(row_dict.get("abertura_chamado"), datetime):
                    row_dict["abertura_chamado"] = row_dict["abertura_chamado"].strftime("%Y-%m-%dT%H:%M:%S")
                results.append(row_dict)
            print(f"[PROC] Processado em {time.time() - start_proc:.2f}s, total {len(results)} registros")
        except Exception as proc_err:
            raise RuntimeError(f"Erro ao processar resultados: {proc_err}")
        finally:
            try:
                cursor.close()
                conn.close()
            except Exception as close_err:
                print(f"[WARN] Falha ao fechar conexão DB: {close_err}")

        # ---------- Resposta via WebSocket ----------
        try:
            apigw = boto3.client("apigatewaymanagementapi", endpoint_url=api_endpoint)
            apigw.post_to_connection(
                ConnectionId=connection_id,
                Data=json.dumps(results, ensure_ascii=False).encode("utf-8")
            )
            print(f"[WS] Enviado {len(results)} registros para {connection_id}")
        except ClientError as e:
            err_msg = f"Erro AWS ao enviar para {connection_id}: {e}"
            print(f"[ERRO] {err_msg}")
            errors.append(err_msg)
        except (BotoCoreError, Exception) as ws_err:
            err_msg = f"Erro inesperado ao enviar para {connection_id}: {ws_err}"
            print(f"[ERRO] {err_msg}")
            errors.append(err_msg)

        tempo_total = time.time() - start_total
        print(f"[TOTAL] Lambda finalizada em {tempo_total:.2f}s")

        return {
            "statusCode": 200 if not errors else 207,
            "body": json.dumps({
                "message": "Execução concluída",
                "totalRegistros": len(results),
                "falhasEnvio": len(errors),
                "erros": errors
            }, ensure_ascii=False)
        }

    except Exception as e:
        print("[FATAL]", str(e))
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)}, ensure_ascii=False)
        }

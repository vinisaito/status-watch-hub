import React, { useEffect, useState, useRef } from "react";

interface TimerProps {
  chamadoId: number;
}

// URLs definidas diretamente aqui
const WS_URL = "wss://seu-endpoint-wss.execute-api.us-east-1.amazonaws.com/prod";
const API_BASE_URL = "https://seu-endpoint-rest.execute-api.us-east-1.amazonaws.com/prod";

const Timer: React.FC<TimerProps> = ({ chamadoId }) => {
  const [timeRemaining, setTimeRemaining] = useState<number>(0);
  const [timerActive, setTimerActive] = useState<boolean>(false);
  const [startedAt, setStartedAt] = useState<string | null>(null);

  const wsRef = useRef<WebSocket | null>(null);
  const intervalRef = useRef<NodeJS.Timer | null>(null);

  // FunÃ§Ã£o para buscar estado atual da API
  const fetchState = async () => {
    try {
      const resp = await fetch(`${API_BASE_URL}/dados/${chamadoId}`);
      const data = await resp.json();
      console.log("ðŸ“¡ Estado inicial:", data);

      setTimerActive(data.timerActive);
      setStartedAt(data.startedAt || null);
      setTimeRemaining(data.timeRemaining || 0);
    } catch (err) {
      console.error("âŒ Erro ao buscar estado:", err);
    }
  };

  // FunÃ§Ã£o para enviar aÃ§Ã£o via WS
  const sendAction = (action: string) => {
    const ws = wsRef.current;
    if (ws && ws.readyState === WebSocket.OPEN) {
      console.log(`ðŸ“¤ Enviando aÃ§Ã£o: ${action}`);
      ws.send(JSON.stringify({ action, chamado: chamadoId }));
    } else {
      console.log("â³ WebSocket ainda conectando...");
    }
  };

  // Conectar WebSocket
  useEffect(() => {
    console.log("ðŸ”Œ Conectando WebSocket...");
    const ws = new WebSocket(WS_URL);
    wsRef.current = ws;

    ws.onopen = () => {
      console.log("âœ… WebSocket conectado!");
    };

    ws.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      console.log("ðŸ“© Mensagem recebida:", msg);

      if (msg.type === "TIMER_UPDATED" && msg.chamado === chamadoId) {
        setTimerActive(msg.timerActive);
        setStartedAt(msg.startedAt || null);
        setTimeRemaining(msg.timeRemaining || 0);
      }
    };

    ws.onerror = (err) => console.error("âŒ WebSocket error:", err);
    ws.onclose = () => console.log("âŒ WebSocket fechado");

    fetchState(); // pega estado inicial

    return () => {
      ws.close();
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [chamadoId]);

  // CronÃ´metro interno
  useEffect(() => {
    if (intervalRef.current) clearInterval(intervalRef.current);

    if (timerActive && timeRemaining > 0) {
      intervalRef.current = setInterval(() => {
        setTimeRemaining((prev) => Math.max(prev - 1, 0));
      }, 1000);
    }

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [timerActive, timeRemaining]);

  // Formatar tempo em mm:ss
  const formatTime = (seconds: number) => {
    const m = Math.floor(seconds / 60)
      .toString()
      .padStart(2, "0");
    const s = (seconds % 60).toString().padStart(2, "0");
    return `${m}:${s}`;
  };

  return (
    <div>
      <h2>Chamado {chamadoId}</h2>
      <p>Status: {timerActive ? "Ativo" : "Pausado"}</p>
      <p>Tempo restante: {formatTime(timeRemaining)}</p>
      <button onClick={() => sendAction("startTimer")}>Iniciar</button>
      <button onClick={() => sendAction("pauseTimer")}>Pausar</button>
    </div>
  );
};

export default Timer;

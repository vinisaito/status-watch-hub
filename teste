import { create } from "zustand";

export interface EscalationState {
  status: "pending" | "confirmed" | "escalating" | "completed";
  currentLevel: 0 | 1 | 2 | 3 | 4;
  timeRemaining: number;
  timerActive: boolean;
  isAttended: boolean;
  observations: string;
  pendingStatus?: string;
  pendingObservations?: string;
  startedAt?: string;
  durationMinutes?: number;
}

interface ChamadoStore {
  chamados: Record<string, EscalationState>;
  socket: WebSocket | null;
  initWebSocket: () => void;
  initChamado: (chamado: string) => void;
  updateChamado: (chamado: string, updates: Partial<EscalationState>) => void;
}

export const useChamadoStore = create<ChamadoStore>((set, get) => ({
  chamados: {},
  socket: null,

  initWebSocket: () => {
    const { socket } = get();
    if (socket) return;

    // ðŸ”— coloque aqui o endpoint gerado pelo API Gateway (wss://...)
    const ws = new WebSocket("wss://SEU-ENDPOINT.execute-api.us-east-1.amazonaws.com/production");

    ws.onopen = () => {
      console.log("âœ… WebSocket conectado");
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === "update") {
          set((state) => ({
            chamados: {
              ...state.chamados,
              [data.chamado]: {
                ...state.chamados[data.chamado],
                ...data.payload,
              },
            },
          }));
        }
      } catch (err) {
        console.error("Erro ao parsear mensagem WS:", err);
      }
    };

    ws.onclose = () => {
      console.log("âŒ WebSocket desconectado");
      set({ socket: null });
      setTimeout(() => get().initWebSocket(), 2000); // tenta reconectar
    };

    set({ socket: ws });
  },

  initChamado: (chamado) => {
    set((state) => ({
      chamados: {
        ...state.chamados,
        [chamado]: {
          status: "pending",
          currentLevel: 0,
          timeRemaining: 20 * 60, // 20 minutos
          timerActive: true,
          isAttended: false,
          observations: "",
        },
      },
    }));
    get().sendUpdate(chamado);
  },

  updateChamado: (chamado, updates) => {
    set((state) => ({
      chamados: {
        ...state.chamados,
        [chamado]: { ...state.chamados[chamado], ...updates },
      },
    }));
    get().sendUpdate(chamado);
  },

  sendUpdate: (chamado) => {
    const { socket, chamados } = get();
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(
        JSON.stringify({
          action: "sendMessage",
          chamado,
          payload: chamados[chamado],
        })
      );
    }
  },
}));

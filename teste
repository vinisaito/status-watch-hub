import React, { useState, useEffect, useRef } from "react";

// URL do seu WebSocket (substitua pela sua)
const WS_URL = "wss://SEU_ENDPOINT_WS/prod";

interface TimerData {
  chamado: number;
  timerActive: boolean;
  startedAt?: string;
  durationMinutes: number;
  timeRemaining: number;
}

const Timer: React.FC<{ chamado: number }> = ({ chamado }) => {
  const [timerData, setTimerData] = useState<TimerData>({
    chamado,
    timerActive: false,
    durationMinutes: 15,
    timeRemaining: 15 * 60,
  });
  const wsRef = useRef<WebSocket | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  // Conecta ao WebSocket
  useEffect(() => {
    console.log("üîå Conectando ao WebSocket...");
    const ws = new WebSocket(WS_URL);
    wsRef.current = ws;

    ws.onopen = () => {
      console.log("‚úÖ WebSocket conectado");
      // Pega o estado atual do timer
      ws.send(JSON.stringify({ action: "getState", chamado }));
    };

    ws.onmessage = (event) => {
      console.log("üì© Mensagem recebida:", event.data);
      try {
        const data = JSON.parse(event.data);
        if (data.type === "TIMER_UPDATED" || data.chamado === chamado) {
          setTimerData((prev) => ({
            ...prev,
            ...data,
          }));
        }
      } catch (err) {
        console.error("‚ùå Erro ao processar mensagem WS:", err);
      }
    };

    ws.onerror = (err) => {
      console.error("‚ö†Ô∏è Erro no WebSocket:", err);
    };

    ws.onclose = () => {
      console.log("‚ö†Ô∏è WebSocket fechado");
    };

    return () => {
      ws.close();
    };
  }, [chamado]);

  // Atualiza contador a cada segundo
  useEffect(() => {
    if (intervalRef.current) clearInterval(intervalRef.current);

    if (timerData.timerActive) {
      intervalRef.current = setInterval(() => {
        setTimerData((prev) => {
          const newTime = prev.timeRemaining - 1;
          return { ...prev, timeRemaining: newTime >= 0 ? newTime : 0 };
        });
      }, 1000);
    }

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [timerData.timerActive]);

  // Formata segundos em mm:ss
  const formatTime = (seconds: number) => {
    const m = Math.floor(seconds / 60)
      .toString()
      .padStart(2, "0");
    const s = Math.floor(seconds % 60)
      .toString()
      .padStart(2, "0");
    return `${m}:${s}`;
  };

  const handleAction = (action: "startTimer" | "pauseTimer") => {
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
      console.log("‚ö†Ô∏è WebSocket n√£o est√° pronto. Aguarde...");
      return;
    }
    console.log(`üì§ Enviando a√ß√£o: ${action}`);
    wsRef.current.send(JSON.stringify({ action, chamado }));
  };

  return (
    <div style={{ padding: "20px", border: "1px solid #ccc", width: "250px" }}>
      <h3>Chamado: {chamado}</h3>
      <p>Tempo restante: {formatTime(timerData.timeRemaining)}</p>
      <p>Status: {timerData.timerActive ? "‚è± Ativo" : "‚è∏ Pausado"}</p>
      <button onClick={() => handleAction("startTimer")}>Iniciar</button>
      <button onClick={() => handleAction("pauseTimer")}>Pausar</button>
    </div>
  );
};

export default Timer;

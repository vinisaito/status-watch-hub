import json
import boto3
import os
import decimal
import uuid
from datetime import datetime, timedelta

# ---------- Config ----------
dynamodb = boto3.resource("dynamodb", region_name="us-east-1")
connections_table = dynamodb.Table(os.environ["CONNECTIONS_TABLE"])  # PK: connectionId (String)
chamados_table = dynamodb.Table(os.environ["CHAMADOS_TABLE"])        # PK: chamado (Number)

# ---------- Utils ----------
class DecimalEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, decimal.Decimal):
            return int(o) if o % 1 == 0 else float(o)
        return super(DecimalEncoder, self).default(o)

def to_json(data):
    return json.dumps(data, cls=DecimalEncoder)

TRACE_ID = None
def log(msg, **kwargs):
    # log estruturado com trace_id
    global TRACE_ID
    if not TRACE_ID:
        TRACE_ID = str(uuid.uuid4())[:8]
    payload = {"trace": TRACE_ID, "msg": msg}
    payload.update(kwargs)
    print(json.dumps(payload, default=str))

def now_ts():
    return int(datetime.utcnow().timestamp())

def get_apigw_client(event):
    rc = event["requestContext"]
    endpoint_url = f"https://{rc['domainName']}/{rc['stage']}"
    # IMPORTANTE: usar endpoint com stage
    return boto3.client("apigatewaymanagementapi", endpoint_url=endpoint_url)

def send_to_connection(apigw, connection_id, message: dict):
    try:
        apigw.post_to_connection(Data=to_json(message), ConnectionId=connection_id)
        log("post_to_connection OK", connectionId=connection_id, action=message.get("action"))
        return True
    except apigw.exceptions.GoneException:
        log("post_to_connection GoneException - removendo conexão", connectionId=connection_id)
        try:
            connections_table.delete_item(Key={"connectionId": connection_id})
        except Exception as e:
            log("erro ao remover conexão Gone", error=str(e), type=str(type(e)))
        return False
    except Exception as e:
        log("post_to_connection ERROR",
            connectionId=connection_id,
            error=str(e),
            type=str(type(e)),
            message=message)
        return False

def clone_event_with_route(event, new_route):
    # handler para $default: reusa o mesmo event, trocando routeKey
    new_event = dict(event)
    new_event["requestContext"] = dict(event["requestContext"])
    new_event["requestContext"]["routeKey"] = new_route
    return new_event

# ---------- Handler ----------
def lambda_handler(event, context):
    global TRACE_ID
    TRACE_ID = str(uuid.uuid4())[:8]  # novo trace por invocação

    # logs iniciais
    route = event["requestContext"]["routeKey"]
    rc = event["requestContext"]
    log("invoke",
        routeKey=route,
        stage=rc.get("stage"),
        domain=rc.get("domainName"),
        connectionId=rc.get("connectionId"),
        isBase64=event.get("isBase64Encoded"),
        bodyRaw=event.get("body"))

    if route == "$connect":
        return on_connect(event)
    elif route == "$disconnect":
        return on_disconnect(event)
    elif route == "startTimer":
        return start_timer(event)
    elif route == "updateStatus":
        return update_status(event)
    elif route == "getState":
        return get_state(event)
    elif route == "$default":
        # Se o Route Selection Expression NÃO estiver como $request.body.action
        # tudo cai aqui. Tentamos roteá-lo manualmente lendo o body.action.
        try:
            body = json.loads(event.get("body") or "{}")
        except Exception as e:
            log("default_parse_body_error", error=str(e))
            body = {}
        action = body.get("action")
        log("$default recebido", parsedAction=action, body=body)
        if action in ("getState", "startTimer", "updateStatus"):
            # roteia internamente
            return lambda_handler(clone_event_with_route(event, action), context)
        # caso contrário, apenas loga e responde
        return {"statusCode": 200, "body": "No-op $default"}
    else:
        return {"statusCode": 400, "body": "Rota inválida"}

# ---------- Rotas ----------
def on_connect(event):
    connection_id = event["requestContext"]["connectionId"]
    connections_table.put_item(
        Item={"connectionId": connection_id, "connectedAt": now_ts()}
    )
    log("on_connect OK", connectionId=connection_id)
    # não enviamos estado aqui (fluxo é via getState)
    return {"statusCode": 200, "body": "Connected"}

def on_disconnect(event):
    connection_id = event["requestContext"]["connectionId"]
    try:
        connections_table.delete_item(Key={"connectionId": connection_id})
        log("on_disconnect OK", connectionId=connection_id)
    except Exception as e:
        log("on_disconnect ERROR", connectionId=connection_id, error=str(e))
    return {"statusCode": 200, "body": "Disconnected"}

def start_timer(event):
    # inicia 20 min para o chamado
    body = json.loads(event.get("body") or "{}")
    try:
        chamado = int(body["chamado"])
    except Exception as e:
        log("start_timer chamado inválido", body=body, error=str(e))
        return {"statusCode": 400, "body": "chamado inválido"}

    timer_start = now_ts()
    timer_end = timer_start + 20 * 60

    item = {
        "chamado": chamado,           # Number
        "timerStart": timer_start,
        "timerEnd": timer_end,
        "duration": 20 * 60,
        "status": "pendente",
    }
    chamados_table.put_item(Item=item)
    log("start_timer salvo", item=item)

    message = {
        "action": "timerStarted",
        "chamado": chamado,
        "timerStart": timer_start,
        "timerEnd": timer_end,
        "duration": 20 * 60,
        "serverTime": now_ts(),
    }
    return broadcast(event, message)

def update_status(event):
    body = json.loads(event.get("body") or "{}")
    try:
        chamado = int(body["chamado"])
        status = str(body["status"])
    except Exception as e:
        log("update_status inválido", body=body, error=str(e))
        return {"statusCode": 400, "body": "payload inválido"}

    try:
        chamados_table.update_item(
            Key={"chamado": chamado},
            UpdateExpression="SET #s = :s",
            ExpressionAttributeNames={"#s": "status"},
            ExpressionAttributeValues={":s": status},
        )
        log("update_status OK", chamado=chamado, status=status)
    except Exception as e:
        log("update_status ERROR", error=str(e), chamado=chamado)
        return {"statusCode": 500, "body": "erro ao atualizar status"}

    message = {
        "action": "statusUpdated",
        "chamado": chamado,
        "status": status,
        "serverTime": now_ts(),
    }
    return broadcast(event, message)

def get_state(event):
    # chamado obrigatório
    try:
        body = json.loads(event.get("body") or "{}")
    except Exception as e:
        log("get_state parse body error", error=str(e), bodyRaw=event.get("body"))
        body = {}

    chamado_raw = body.get("chamado")
    connection_id = event["requestContext"]["connectionId"]
    apigw = get_apigw_client(event)
    log("get_state begin", chamadoRaw=chamado_raw, connectionId=connection_id)

    try:
        chamado = int(chamado_raw)
    except Exception as e:
        log("get_state chamado inválido", error=str(e), body=body)
        # responde explicitamente erro para a própria conexão
        return send_error_to_sender(apigw, connection_id, "chamado inválido")

    try:
        resp = chamados_table.get_item(Key={"chamado": chamado})
        log("dynamo get_item", key=chamado, found=("Item" in resp))
    except Exception as e:
        log("dynamo get_item ERROR", error=str(e), key=chamado)
        return send_error_to_sender(apigw, connection_id, "erro ao ler estado")

    if "Item" not in resp:
        message = {
            "action": "currentState",
            "chamado": chamado,
            "status": "pendente",
            "timerStart": None,
            "timerEnd": None,
            "duration": None,
            "serverTime": now_ts(),
        }
        log("get_state not found -> enviando estado vazio", message=message)
        send_to_connection(apigw, connection_id, message)
        return {"statusCode": 200, "body": "estado vazio enviado"}

    item = resp["Item"]
    message = {
        "action": "currentState",
        "chamado": int(item["chamado"]),
        "status": item.get("status", "pendente"),
        "timerStart": int(item.get("timerStart", 0)) if item.get("timerStart") is not None else None,
        "timerEnd": int(item.get("timerEnd", 0)) if item.get("timerEnd") is not None else None,
        "duration": int(item.get("duration", 0)) if item.get("duration") is not None else None,
        "serverTime": now_ts(),
    }
    log("get_state found -> enviando", message=message)
    send_to_connection(apigw, connection_id, message)
    return {"statusCode": 200, "body": "estado enviado"}

def send_error_to_sender(apigw, connection_id, error_msg):
    payload = {
        "action": "error",
        "message": error_msg,
        "serverTime": now_ts(),
    }
    send_to_connection(apigw, connection_id, payload)
    return {"statusCode": 400, "body": error_msg}

def broadcast(event, message):
    apigw = get_apigw_client(event)
    try:
        scan = connections_table.scan()
        connections = scan.get("Items", [])
    except Exception as e:
        log("broadcast scan connections ERROR", error=str(e))
        return {"statusCode": 500, "body": "erro ao listar conexões"}

    log("broadcast begin", total=len(connections), message=message)
    sent = 0
    for conn in connections:
        ok = send_to_connection(apigw, conn["connectionId"], message)
        if ok:
            sent += 1
    log("broadcast end", sent=sent, total=len(connections))
    return {"statusCode": 200, "body": f"Mensagem enviada para {sent}/{len(connections)} conexões"}

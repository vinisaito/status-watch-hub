import boto3
import json
from datetime import datetime, timezone
from decimal import Decimal

# DynamoDB
DDB = boto3.resource("dynamodb", region_name="us-east-1")
ACOMP_TABLE = DDB.Table("painelmonitoracao_acompanhamento")  # tabela de alertas
CONN_TABLE = DDB.Table("painelmonitoracao_connections")       # tabela de conexões WebSocket

# API Gateway Management API
APIGW_ENDPOINT = "https://SEU_ENDPOINT.execute-api.us-east-1.amazonaws.com/dev"  # substituir
apigw = boto3.client("apigatewaymanagementapi", endpoint_url=APIGW_ENDPOINT)


def lambda_handler(event, context):
    route = event.get("requestContext", {}).get("routeKey")
    connection_id = event.get("requestContext", {}).get("connectionId")

    if route == "$connect":
        CONN_TABLE.put_item(Item={"connectionId": connection_id})
        return {"statusCode": 200}

    elif route == "$disconnect":
        CONN_TABLE.delete_item(Key={"connectionId": connection_id})
        return {"statusCode": 200}

    elif route == "sendMessage":
        body = json.loads(event.get("body", "{}"))
        action = body.get("action")
        chamado = body.get("chamado")

        if not chamado or not action:
            return {"statusCode": 400, "body": "Chamado ou ação ausente"}

        try:
            item = ACOMP_TABLE.get_item(Key={"chamado": int(chamado)}).get("Item")
            if not item:
                return {"statusCode": 404, "body": "Chamado não encontrado"}

            # Iniciar ou pausar cronômetro
            if action == "startTimer":
                started_at = datetime.utcnow().replace(tzinfo=timezone.utc).isoformat()
                ACOMP_TABLE.update_item(
                    Key={"chamado": int(chamado)},
                    UpdateExpression="SET timerActive = :t, startedAt = :s",
                    ExpressionAttributeValues={":t": True, ":s": started_at}
                )
                item["timerActive"] = True
                item["startedAt"] = started_at

            elif action == "pauseTimer":
                started_at = item.get("startedAt")
                duration = item.get("durationMinutes", 15)
                if started_at:
                    elapsed = (datetime.utcnow().replace(tzinfo=timezone.utc) - datetime.fromisoformat(started_at)).total_seconds()
                    remaining = max(0, duration*60 - elapsed)
                else:
                    remaining = duration * 60
                ACOMP_TABLE.update_item(
                    Key={"chamado": int(chamado)},
                    UpdateExpression="SET timerActive = :t, timeRemaining = :r",
                    ExpressionAttributeValues={":t": False, ":r": Decimal(str(remaining))}
                )
                item["timerActive"] = False
                item["timeRemaining"] = remaining

            # Broadcast para todos clientes
            connections = CONN_TABLE.scan().get("Items", [])
            for conn in connections:
                try:
                    apigw.post_to_connection(
                        Data=json.dumps({
                            "type": "TIMER_UPDATED",
                            "chamado": item["chamado"],
                            "timerActive": item.get("timerActive", False),
                            "startedAt": item.get("startedAt"),
                            "durationMinutes": item.get("durationMinutes", 15),
                            "timeRemaining": float(item.get("timeRemaining", 0))
                        }),
                        ConnectionId=conn["connectionId"]
                    )
                except apigw.exceptions.GoneException:
                    CONN_TABLE.delete_item(Key={"connectionId": conn["connectionId"]})

            return {"statusCode": 200, "body": json.dumps({"message": "ok"})}

        except Exception as e:
            return {"statusCode": 500, "body": str(e)}

    else:
        return {"statusCode": 400, "body": "Rota não suportada"}

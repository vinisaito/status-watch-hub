export { ActionTable } from './ActionTable';
export { EscalacaoDialog } from './EscalacaoDialog';
export { ObservacaoDialog } from './ObservacaoDialog';
export { ChamadoModal } from './ChamadoModal';


import { useState } from 'react';

export const useChatAcionados = () => {
  const [acionadosSet, setAcionadosSet] = useState<Set<string>>(new Set());
  
  const isAcionado = (chamado: string) => acionadosSet.has(chamado);
  
  const addAcionado = (chamado: string) => {
    setAcionadosSet(prev => new Set([...prev, chamado]));
  };
  
  return { acionadosSet, isAcionado, addAcionado };
};

export const useChatAcionadosTimestamps = () => {
  const [timestamps] = useState<Map<string, string>>(new Map());
  
  const getTimestampForChamado = (chamado: string) => timestamps.get(chamado);
  const hasTimestamp = (chamado: string) => timestamps.has(chamado);
  const fetchTimestamps = () => Promise.resolve();
  
  return { getTimestampForChamado, hasTimestamp, fetchTimestamps };
};







import { useState, useEffect, useCallback } from 'react';
import { toast } from '@/hooks/use-toast';

interface EscalacaoData {
  chamado: string;
  etapa: number;
  timerStart: number;
  timerDuration: number;
  isActive: boolean;
  observacoes: Array<{
    etapa: number;
    observacao: string;
    operador: string;
    timestamp: string;
  }>;
}

export const useEscalacao = () => {
  const [escalacaoData, setEscalacaoData] = useState<Map<string, EscalacaoData>>(new Map());
  const [currentTimer, setCurrentTimer] = useState<number>(0);
  const [isTimerActive, setIsTimerActive] = useState<boolean>(false);
  const [currentEtapa, setCurrentEtapa] = useState<number>(1);

  // Timer effect
  useEffect(() => {
    let interval: NodeJS.Timeout;
    
    if (isTimerActive && currentTimer > 0) {
      interval = setInterval(() => {
        setCurrentTimer(prev => {
          if (prev <= 1) {
            setIsTimerActive(false);
            toast({
              title: 'Timer finalizado!',
              description: `Tempo esgotado para etapa ${currentEtapa}. Adicione uma observação para continuar.`,
              variant: 'destructive',
            });
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    }

    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isTimerActive, currentTimer, currentEtapa]);

  const formatTime = useCallback((seconds: number) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  }, []);

  const iniciarEscalacao = useCallback((chamado: string) => {
    const newEscalacao: EscalacaoData = {
      chamado,
      etapa: 1,
      timerStart: Date.now(),
      timerDuration: 20 * 60,
      isActive: true,
      observacoes: []
    };

    setEscalacaoData(prev => new Map(prev.set(chamado, newEscalacao)));
    setCurrentEtapa(1);
    setCurrentTimer(20 * 60);
    setIsTimerActive(true);

    toast({
      title: 'Escalação iniciada',
      description: `Timer de 20 minutos iniciado para etapa 1 do chamado ${chamado}`,
    });
  }, []);

  const avancarEtapa = useCallback((chamado: string, observacao: string, operador: string) => {
    if (!observacao.trim()) {
      toast({
        title: 'Observação obrigatória',
        description: 'É necessário adicionar uma observação para avançar na etapa.',
        variant: 'destructive',
      });
      return false;
    }

    const escalacao = escalacaoData.get(chamado);
    if (!escalacao) return false;

    const novaObservacao = {
      etapa: currentEtapa,
      observacao: observacao.trim(),
      operador,
      timestamp: new Date().toLocaleString('pt-BR')
    };

    const updatedEscalacao: EscalacaoData = {
      ...escalacao,
      etapa: Math.min(currentEtapa + 1, 4),
      observacoes: [...escalacao.observacoes, novaObservacao]
    };

    setEscalacaoData(prev => new Map(prev.set(chamado, updatedEscalacao)));
    
    if (currentEtapa < 4) {
      setCurrentEtapa(prev => prev + 1);
      setCurrentTimer(20 * 60);
      setIsTimerActive(true);
      
      toast({
        title: `Etapa ${currentEtapa} finalizada`,
        description: `Avançando para etapa ${currentEtapa + 1}. Timer resetado.`,
      });
    } else {
      setIsTimerActive(false);
      
      toast({
        title: 'Escalação finalizada',
        description: 'Todas as etapas foram concluídas.',
      });
    }

    return true;
  }, [escalacaoData, currentEtapa]);

  const voltarEtapa = useCallback((chamado: string, observacao: string, operador: string) => {
    if (!observacao.trim()) {
      toast({
        title: 'Observação obrigatória',
        description: 'É necessário adicionar uma observação para voltar na etapa.',
        variant: 'destructive',
      });
      return false;
    }

    const escalacao = escalacaoData.get(chamado);
    if (!escalacao || currentEtapa <= 1) return false;

    const novaObservacao = {
      etapa: currentEtapa,
      observacao: `[VOLTA ETAPA] ${observacao.trim()}`,
      operador,
      timestamp: new Date().toLocaleString('pt-BR')
    };

    const updatedEscalacao: EscalacaoData = {
      ...escalacao,
      etapa: currentEtapa - 1,
      observacoes: [...escalacao.observacoes, novaObservacao]
    };

    setEscalacaoData(prev => new Map(prev.set(chamado, updatedEscalacao)));
    setCurrentEtapa(prev => prev - 1);
    setCurrentTimer(20 * 60);
    setIsTimerActive(true);

    toast({
      title: `Voltou para etapa ${currentEtapa - 1}`,
      description: 'Timer resetado para a etapa anterior.',
    });

    return true;
  }, [escalacaoData, currentEtapa]);

  const finalizarEscalacao = useCallback((chamado: string, observacao: string, operador: string) => {
    if (!observacao.trim()) {
      toast({
        title: 'Observação obrigatória',
        description: 'É necessário adicionar uma observação para finalizar.',
        variant: 'destructive',
      });
      return false;
    }

    const escalacao = escalacaoData.get(chamado);
    if (!escalacao) return false;

    const novaObservacao = {
      etapa: currentEtapa,
      observacao: `[FINALIZADO] ${observacao.trim()}`,
      operador,
      timestamp: new Date().toLocaleString('pt-BR')
    };

    const updatedEscalacao: EscalacaoData = {
      ...escalacao,
      isActive: false,
      observacoes: [...escalacao.observacoes, novaObservacao]
    };

    setEscalacaoData(prev => new Map(prev.set(chamado, updatedEscalacao)));
    setIsTimerActive(false);

    toast({
      title: 'Escalação finalizada',
      description: 'Processo de escalação concluído com sucesso.',
    });

    return true;
  }, [escalacaoData, currentEtapa]);

  return {
    escalacaoData,
    currentTimer,
    isTimerActive,
    currentEtapa,
    setCurrentEtapa,
    formatTime,
    iniciarEscalacao,
    avancarEtapa,
    voltarEtapa,
    finalizarEscalacao
  };
};







import { useState, useEffect, useCallback } from 'react';
import { toast } from '@/hooks/use-toast';

interface ObservacaoData {
  chamado: number;
  observacao: string;
  status: string;
  operador: string;
  CreatedAt?: string;
}

export const useObservacoes = () => {
  const [observacoesData, setObservacoesData] = useState<Map<string, ObservacaoData>>(new Map());
  const [loading, setLoading] = useState(false);

  const fetchObservacoes = useCallback(async (retryCount = 0) => {
    try {
      setLoading(true);
      const response = await fetch('https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/obs', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
      });

      if (response.ok) {
        const data: ObservacaoData[] = await response.json();
        const observacoesMap = new Map<string, ObservacaoData>();
        data.forEach(obs => {
          observacoesMap.set(obs.chamado.toString(), obs);
        });
        setObservacoesData(observacoesMap);
      } else if (response.status === 404) {
        setObservacoesData(new Map());
      } else {
        throw new Error(`API retornou status: ${response.status}`);
      }
    } catch (error) {
      console.error('Erro ao buscar observações:', error);

      if (retryCount < 3) {
        setTimeout(() => fetchObservacoes(retryCount + 1), 2000 * (retryCount + 1));
      } else {
        toast({
          title: 'Erro ao carregar observações',
          description: 'Não foi possível carregar dados salvos.',
          variant: 'destructive',
        });
      }
    } finally {
      setLoading(false);
    }
  }, []);

  const saveObservacao = useCallback(async (chamado: string, observacao: string, operador: string) => {
    try {
      const payload: ObservacaoData = {
        chamado: parseInt(chamado),
        observacao: observacao.trim(),
        status: 'acionado',
        operador,
      };

      const response = await fetch('https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/obs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`Erro na API: ${response.status}`);
      }

      const updatedObsData = new Map(observacoesData);
      updatedObsData.set(chamado, payload);
      setObservacoesData(updatedObsData);

      toast({
        title: 'Observação salva',
        description: 'A observação foi salva com sucesso',
      });

      fetchObservacoes();
      return true;
    } catch (error) {
      console.error('Erro ao salvar observação:', error);
      toast({
        title: 'Erro ao salvar',
        description: 'Não foi possível salvar a observação',
        variant: 'destructive',
      });
      return false;
    }
  }, [observacoesData, fetchObservacoes]);

  // Auto-refresh a cada 5 minutos
  useEffect(() => {
    fetchObservacoes();
    const interval = setInterval(fetchObservacoes, 5 * 60 * 1000);
    return () => clearInterval(interval);
  }, [fetchObservacoes]);

  return {
    observacoesData,
    loading,
    fetchObservacoes,
    saveObservacao
  };
};





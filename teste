import create from "zustand";
import { persist } from "zustand/middleware";
import { ws } from "@/services/websocket"; // seu websocket.ts

export type ChamadoState = {
  status: "idle" | "pending" | "confirmed" | "escalating" | "completed";
  timeRemaining: number;
  timerActive: boolean;
  observations: string;
  currentLevel: number;
  isAttended: boolean;
};

type ChamadosStore = {
  chamados: Record<string, ChamadoState>;
  startConfirmation: (alertId: string) => void;
  confirmReceived: (alertId: string, obs?: string) => void;
  startEscalation: (alertId: string, level: 1 | 2 | 3 | 4, obs?: string) => void;
  updateObservation: (alertId: string, obs: string) => void;
  completeChamado: (alertId: string, obs?: string) => void;
  setFromServer: (alertId: string, data: Partial<ChamadoState>) => void;
  tick: () => void;
};

export const useChamadoStore = create<ChamadosStore>()(
  persist(
    (set, get) => ({
      chamados: {},

      // quando clica em "Iniciar"
      startConfirmation: (alertId) => {
        set((state) => ({
          chamados: {
            ...state.chamados,
            [alertId]: {
              status: "pending",
              timeRemaining: 300, // 5 minutos por exemplo
              timerActive: true,
              observations: "",
              currentLevel: 0,
              isAttended: false,
            },
          },
        }));

        ws.send({
          action: "startConfirmation",
          chamado: alertId,
        });
      },

      // confirmar chamado
      confirmReceived: (alertId, obs = "") => {
        set((state) => {
          const atual = state.chamados[alertId];
          if (!atual) return state;
          return {
            chamados: {
              ...state.chamados,
              [alertId]: {
                ...atual,
                status: "confirmed",
                timerActive: false,
                observations: obs || atual.observations,
              },
            },
          };
        });

        ws.send({
          action: "confirmReceived",
          chamado: alertId,
          observations: obs,
        });
      },

      // iniciar escalonamento
      startEscalation: (alertId, level, obs = "") => {
        set((state) => {
          const atual = state.chamados[alertId];
          if (!atual) return state;
          return {
            chamados: {
              ...state.chamados,
              [alertId]: {
                ...atual,
                status: "escalating",
                currentLevel: level,
                timeRemaining: 300,
                timerActive: true,
                observations: obs || atual.observations,
              },
            },
          };
        });

        ws.send({
          action: "startEscalation",
          chamado: alertId,
          level,
          observations: obs,
        });
      },

      // atualizar observação local
      updateObservation: (alertId, obs) => {
        set((state) => {
          const atual = state.chamados[alertId];
          if (!atual) return state;
          return {
            chamados: {
              ...state.chamados,
              [alertId]: {
                ...atual,
                observations: obs,
              },
            },
          };
        });
      },

      // finalizar chamado
      completeChamado: (alertId, obs = "") => {
        set((state) => {
          const atual = state.chamados[alertId];
          if (!atual) return state;
          return {
            chamados: {
              ...state.chamados,
              [alertId]: {
                ...atual,
                status: "completed",
                timerActive: false,
                timeRemaining: 0,
                observations: obs || atual.observations,
              },
            },
          };
        });

        ws.send({
          action: "completeChamado",
          chamado: alertId,
          observations: obs,
        });
      },

      // quando vem update do servidor
      setFromServer: (alertId, data) => {
        set((state) => {
          const atual = state.chamados[alertId] || {
            status: "idle",
            timeRemaining: 0,
            timerActive: false,
            observations: "",
            currentLevel: 0,
            isAttended: false,
          };
          return {
            chamados: {
              ...state.chamados,
              [alertId]: { ...atual, ...data },
            },
          };
        });
      },

      // decrementa os timers ativos
      tick: () => {
        set((state) => {
          const novos: Record<string, ChamadoState> = {};
          for (const [id, chamado] of Object.entries(state.chamados)) {
            if (chamado.timerActive && chamado.timeRemaining > 0) {
              novos[id] = {
                ...chamado,
                timeRemaining: chamado.timeRemaining - 1,
              };
            } else if (chamado.timerActive && chamado.timeRemaining <= 0) {
              novos[id] = {
                ...chamado,
                timerActive: false,
                timeRemaining: 0,
              };
            } else {
              novos[id] = chamado;
            }
          }
          return { chamados: novos };
        });
      },
    }),
    { name: "chamados-store" }
  )
);

// dispara o tick a cada segundo
setInterval(() => {
  useChamadoStore.getState().tick();
}, 1000);

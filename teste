import boto3
import json
from datetime import datetime, timezone
from decimal import Decimal

# -------------------------------
# Configurações DynamoDB
# -------------------------------
DDB = boto3.resource("dynamodb", region_name="us-east-1")
ACOMP_TABLE = DDB.Table("painelmonitoracao_acompanhamento")  # tabela de alertas
CONN_TABLE = DDB.Table("painelmonitoracao_connections")       # tabela de conexões WebSocket

# -------------------------------
# API Gateway Management API
# -------------------------------
APIGW_ENDPOINT = "https://SEU_ENDPOINT.execute-api.us-east-1.amazonaws.com/dev"  # substituir
apigw = boto3.client("apigatewaymanagementapi", endpoint_url=APIGW_ENDPOINT)

# -------------------------------
# Função serialização Decimal
# -------------------------------
def json_serial(obj):
    if isinstance(obj, Decimal):
        return int(obj) if obj % 1 == 0 else float(obj)
    raise TypeError

# -------------------------------
# Lambda Handler
# -------------------------------
def lambda_handler(event, context):
    route = event.get("requestContext", {}).get("routeKey")
    connection_id = event.get("requestContext", {}).get("connectionId")

    # --------------------------
    # Cliente conecta
    # --------------------------
    if route == "$connect":
        print(f"✅ Conexão estabelecida: {connection_id}")
        # Salva conexão
        CONN_TABLE.put_item(Item={"connectionId": connection_id})

        # Envia estado atual de todos os cronômetros para o novo cliente
        response = ACOMP_TABLE.scan()
        alerts = response.get("Items", [])

        for alert in alerts:
            try:
                apigw.post_to_connection(
                    ConnectionId=connection_id,
                    Data=json.dumps({
                        "type": "TIMER_UPDATED",
                        "chamado": alert["chamado"],
                        "startedAt": alert.get("startedAt"),
                        "durationMinutes": alert.get("durationMinutes", 15),
                        "timerActive": alert.get("timerActive", False)
                    }, default=json_serial)
                )
            except apigw.exceptions.GoneException:
                print(f"❌ Conexão ausente ao enviar estado inicial: {connection_id}")
                CONN_TABLE.delete_item(Key={"connectionId": connection_id})

        return {"statusCode": 200}

    # --------------------------
    # Cliente desconecta
    # --------------------------
    elif route == "$disconnect":
        print(f"❌ Conexão desconectada: {connection_id}")
        CONN_TABLE.delete_item(Key={"connectionId": connection_id})
        return {"statusCode": 200}

    # --------------------------
    # Recebe mensagem do cliente
    # --------------------------
    elif route == "sendMessage":
        body = json.loads(event.get("body", "{}"))
        action = body.get("action")          # "startTimer" ou "pauseTimer"
        chamado = body.get("chamado")        # id do chamado

        if not chamado or not action:
            return {"statusCode": 400, "body": "Chamado ou ação ausente"}

        startedAt = None

        try:
            # Atualiza o cronômetro no DynamoDB
            if action == "startTimer":
                startedAt = datetime.utcnow().replace(tzinfo=timezone.utc).isoformat()
                ACOMP_TABLE.update_item(
                    Key={"chamado": chamado},
                    UpdateExpression="SET timerActive = :t, startedAt = :s",
                    ExpressionAttributeValues={":t": True, ":s": startedAt}
                )
                print(f"⏱ Timer iniciado: {chamado} às {startedAt}")

            elif action == "pauseTimer":
                ACOMP_TABLE.update_item(
                    Key={"chamado": chamado},
                    UpdateExpression="SET timerActive = :t",
                    ExpressionAttributeValues={":t": False}
                )
                print(f"⏸ Timer pausado: {chamado}")

            else:
                return {"statusCode": 400, "body": "Ação inválida"}

            # --------------------------
            # Broadcast para todos os clientes conectados
            # --------------------------
            connections = CONN_TABLE.scan().get("Items", [])
            for conn in connections:
                try:
                    apigw.post_to_connection(
                        ConnectionId=conn["connectionId"],
                        Data=json.dumps({
                            "type": "TIMER_UPDATED",
                            "chamado": chamado,
                            "startedAt": startedAt if action == "startTimer" else None,
                            "durationMinutes": 15,
                            "timerActive": action == "startTimer"
                        }, default=json_serial)
                    )
                except apigw.exceptions.GoneException:
                    print(f"❌ Conexão ausente: {conn['connectionId']}")
                    CONN_TABLE.delete_item(Key={"connectionId": conn["connectionId"]})

            return {"statusCode": 200, "body": json.dumps({"message": "ok"})}

        except Exception as e:
            print("❌ Erro ao processar mensagem:", e)
            return {"statusCode": 500, "body": str(e)}

    # --------------------------
    # Rota não suportada
    # --------------------------
    else:
        print(f"Rota não suportada: {route}")
        return {"statusCode": 400, "body": "Rota não suportada"}

import boto3
import json
from datetime import datetime, timezone
from decimal import Decimal

# Conexão DynamoDB
DDB = boto3.resource("dynamodb", region_name="us-east-1")
ACOMP_TABLE = DDB.Table("painelmonitoracao_acompanhamento")  # Tabela de alertas
CONN_TABLE = DDB.Table("painelmonitoracao_connections")       # Tabela de conexões WebSocket

# API Gateway Management API (WebSocket)
APIGW_ENDPOINT = "https://tgwtw1v4rg.execute-api.us-east-1.amazonaws.com/dev"  # Substitua pelo seu endpoint
apigw = boto3.client("apigatewaymanagementapi", endpoint_url=APIGW_ENDPOINT)

# Serialização Decimal
def json_serial(obj):
    if isinstance(obj, Decimal):
        return int(obj) if obj % 1 == 0 else float(obj)
    raise TypeError

# Função Lambda
def lambda_handler(event, context):
    route = event.get("requestContext", {}).get("routeKey")
    connection_id = event.get("requestContext", {}).get("connectionId")

    # ---------------- Connect
    if route == "$connect":
        CONN_TABLE.put_item(Item={"connectionId": connection_id})
        return {"statusCode": 200}

    # ---------------- Disconnect
    elif route == "$disconnect":
        CONN_TABLE.delete_item(Key={"connectionId": connection_id})
        return {"statusCode": 200}

    # ---------------- Receber mensagem
    elif route == "sendMessage":
        body = json.loads(event.get("body", "{}"))
        action = body.get("action")          # "startTimer" ou "pauseTimer"
        chamado = body.get("chamado")        # id do chamado

        if not chamado or not action:
            return {"statusCode": 400, "body": "Chamado ou ação ausente"}

        # Pega o alerta atual
        alerta_resp = ACOMP_TABLE.get_item(Key={"chamado": int(chamado)})
        alerta = alerta_resp.get("Item")

        if not alerta:
            return {"statusCode": 404, "body": "Chamado não encontrado"}

        now_iso = datetime.utcnow().replace(tzinfo=timezone.utc).isoformat()

        update_expr = ""
        expr_values = {}

        if action == "startTimer":
            update_expr = "SET timerActive = :t, startedAt = :s"
            expr_values = {":t": True, ":s": now_iso}
        elif action == "pauseTimer":
            update_expr = "SET timerActive = :t"
            expr_values = {":t": False}
        else:
            return {"statusCode": 400, "body": "Ação inválida"}

        # Atualiza DynamoDB
        ACOMP_TABLE.update_item(
            Key={"chamado": int(chamado)},
            UpdateExpression=update_expr,
            ExpressionAttributeValues=expr_values
        )

        # Busca estado atualizado
        alerta_resp = ACOMP_TABLE.get_item(Key={"chamado": int(chamado)})
        alerta = alerta_resp.get("Item")

        # Broadcast para todos os clientes conectados
        connections = CONN_TABLE.scan().get("Items", [])
        for conn in connections:
            try:
                apigw.post_to_connection(
                    ConnectionId=conn["connectionId"],
                    Data=json.dumps({
                        "type": "TIMER_UPDATED",
                        "chamado": alerta["chamado"],
                        "timerActive": alerta.get("timerActive", False),
                        "startedAt": alerta.get("startedAt"),
                        "durationMinutes": alerta.get("durationMinutes", 15)
                    }, default=json_serial)
                )
            except apigw.exceptions.GoneException:
                CONN_TABLE.delete_item(Key={"connectionId": conn["connectionId"]})

        return {"statusCode": 200, "body": json.dumps({"message": "ok"})}

    # ---------------- GET estado atual (nova sessão)
    elif route == "getState":
        chamado = event.get("queryStringParameters", {}).get("chamado")
        if not chamado:
            return {"statusCode": 400, "body": "Chamado ausente"}

        alerta_resp = ACOMP_TABLE.get_item(Key={"chamado": int(chamado)})
        alerta = alerta_resp.get("Item")
        if not alerta:
            return {"statusCode": 404, "body": "Chamado não encontrado"}

        return {"statusCode": 200, "body": json.dumps(alerta, default=json_serial)}

    else:
        return {"statusCode": 400, "body": "Rota não suportada"}

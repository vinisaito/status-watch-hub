import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Play, Pause, Clock, AlertTriangle, CheckCircle } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';

interface TimerData {
  chamado: string | number;
  status?: string;
  operador?: string;
  startedAt?: string;
  durationMinutes?: number;
  timeRemaining?: number;
  timerActive?: boolean;
  currentLevel?: number;
  isAttended?: boolean;
  observations?: string;
  updatedAt?: string;
  alertOpenTime?: string;
  sendChat?: string;
  confirmChat?: string;
  obsChat?: string;
  escalations?: Array<{
    level: number;
    operador?: string;
    status?: string;
    observations?: string;
    eventTimestamp?: string;
  }>;
}

export const TimerTable = () => {
  const [timers, setTimers] = useState<TimerData[]>([]);
  const [loading, setLoading] = useState(false);
  const { toast } = useToast();

  // Função para buscar dados da API
  const fetchTimers = async () => {
    try {
      const response = await fetch('https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/acompanhamento');
      if (!response.ok) throw new Error('Falha ao buscar dados');
      
      const data = await response.json();
      setTimers(Array.isArray(data) ? data : [data]);
    } catch (error) {
      console.error('Erro ao buscar timers:', error);
      toast({
        title: "Erro de Conexão",
        description: "Não foi possível sincronizar com o servidor",
        variant: "destructive",
      });
    }
  };

  // Polling para manter sincronização - atualiza a cada 2 segundos
  useEffect(() => {
    fetchTimers(); // Busca inicial
    
    const interval = setInterval(() => {
      fetchTimers();
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  // Função para iniciar um novo timer
  const startTimer = async () => {
    setLoading(true);
    try {
      // Aqui você implementaria a chamada POST para iniciar o timer
      // Por enquanto, vou simular com um timer local
      const newTimer: TimerData = {
        chamado: `CALL-${Date.now()}`,
        status: 'Em andamento',
        operador: 'Sistema',
        startedAt: new Date().toISOString(),
        durationMinutes: 20,
        timeRemaining: 20 * 60, // 20 minutos em segundos
        timerActive: true,
        currentLevel: 1,
        isAttended: false,
        observations: 'Timer iniciado via interface',
        updatedAt: new Date().toISOString()
      };
      
      setTimers(prev => [newTimer, ...prev]);
      
      toast({
        title: "Timer Iniciado",
        description: "Cronômetro de 20 minutos foi iniciado com sucesso",
      });
    } catch (error) {
      toast({
        title: "Erro",
        description: "Não foi possível iniciar o timer",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  // Função para formatar tempo em MM:SS
  const formatTime = (seconds: number) => {
    const mins = Math.floor(Math.abs(seconds) / 60);
    const secs = Math.abs(seconds) % 60;
    const sign = seconds < 0 ? '-' : '';
    return `${sign}${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // Função para determinar cor do timer baseado no tempo restante
  const getTimerColor = (timeRemaining?: number, durationMinutes?: number) => {
    if (!timeRemaining || !durationMinutes) return 'text-muted-foreground';
    
    const totalSeconds = durationMinutes * 60;
    const percentage = (timeRemaining / totalSeconds) * 100;
    
    if (percentage > 50) return 'text-timer-active';
    if (percentage > 20) return 'text-timer-warning';
    return 'text-timer-danger';
  };

  // Função para determinar status visual
  const getStatusBadge = (status?: string, isAttended?: boolean) => {
    if (isAttended) {
      return <Badge variant="secondary" className="bg-timer-active/20 text-timer-active border-timer-active/30">
        <CheckCircle className="w-3 h-3 mr-1" />
        Atendido
      </Badge>;
    }
    
    if (!status) {
      return <Badge variant="outline" className="text-muted-foreground">
        Aguardando
      </Badge>;
    }
    
    switch (status.toLowerCase()) {
      case 'pending':
        return <Badge variant="outline" className="bg-muted/20 text-muted-foreground border-muted">
          <Clock className="w-3 h-3 mr-1" />
          Pendente
        </Badge>;
      case 'em andamento':
        return <Badge variant="secondary" className="bg-timer-warning/20 text-timer-warning border-timer-warning/30">
          <Clock className="w-3 h-3 mr-1" />
          Em Andamento
        </Badge>;
      case 'escalonado':
        return <Badge variant="destructive" className="bg-timer-danger/20 text-timer-danger border-timer-danger/30">
          <AlertTriangle className="w-3 h-3 mr-1" />
          Escalonado
        </Badge>;
      default:
        return <Badge variant="outline">{status}</Badge>;
    }
  };

  return (
    <div className="min-h-screen bg-background p-6">
      <div className="max-w-7xl mx-auto space-y-6">
        {/* Header */}
        <div className="flex justify-between items-center">
          <div>
            <h1 className="text-3xl font-bold">Cronômetros Sincronizados</h1>
            <p className="text-muted-foreground mt-1">
              Sistema de cronometragem com sincronização em tempo real
            </p>
          </div>
          <Button 
            onClick={startTimer} 
            disabled={loading}
            className="bg-gradient-to-r from-timer-active to-timer-active/90 hover:from-timer-active/90 hover:to-timer-active text-primary-foreground shadow-lg"
          >
            <Play className="w-4 h-4 mr-2" />
            {loading ? 'Iniciando...' : 'Iniciar Timer 20min'}
          </Button>
        </div>

        {/* Status Cards */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <Card className="card-gradient border-border/50">
            <CardContent className="p-4">
              <div className="flex items-center space-x-2">
                <Clock className="w-5 h-5 text-timer-active" />
                <div>
                  <p className="text-sm font-medium">Timers Ativos</p>
                  <p className="text-2xl font-bold text-timer-active">
                    {timers.filter(t => t.timerActive === true).length}
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="card-gradient border-border/50">
            <CardContent className="p-4">
              <div className="flex items-center space-x-2">
                <CheckCircle className="w-5 h-5 text-timer-active" />
                <div>
                  <p className="text-sm font-medium">Atendidos</p>
                  <p className="text-2xl font-bold">
                    {timers.filter(t => t.isAttended === true).length}
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="card-gradient border-border/50">
            <CardContent className="p-4">
              <div className="flex items-center space-x-2">
                <AlertTriangle className="w-5 h-5 text-timer-warning" />
                <div>
                  <p className="text-sm font-medium">Pendentes</p>
                  <p className="text-2xl font-bold text-timer-warning">
                    {timers.filter(t => t.status === 'pending').length}
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="card-gradient border-border/50">
            <CardContent className="p-4">
              <div className="flex items-center space-x-2">
                <Clock className="w-5 h-5 text-muted-foreground" />
                <div>
                  <p className="text-sm font-medium">Total</p>
                  <p className="text-2xl font-bold">{timers.length}</p>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Timer Table */}
        <Card className="card-gradient border-border/50">
          <CardHeader>
            <CardTitle className="flex items-center space-x-2">
              <Clock className="w-5 h-5" />
              <span>Cronômetros Ativos</span>
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead>
                  <tr className="border-b border-border">
                    <th className="text-left p-4 font-semibold">Chamado</th>
                    <th className="text-left p-4 font-semibold">Status</th>
                    <th className="text-left p-4 font-semibold">Operador</th>
                    <th className="text-center p-4 font-semibold">Cronômetro</th>
                    <th className="text-center p-4 font-semibold">Nível</th>
                    <th className="text-left p-4 font-semibold">Observações</th>
                  </tr>
                </thead>
                <tbody>
                  {timers.length === 0 ? (
                    <tr>
                      <td colSpan={6} className="text-center p-8 text-muted-foreground">
                        Nenhum timer ativo. Clique em "Iniciar Timer" para começar.
                      </td>
                    </tr>
                  ) : (
                    timers.map((timer) => (
                      <tr key={timer.chamado} className="border-b border-border/30 hover:bg-muted/30 transition-colors">
                        <td className="p-4">
                          <div className="font-mono text-sm font-medium">
                            {timer.chamado}
                          </div>
                        </td>
                        <td className="p-4">
                          {getStatusBadge(timer.status, timer.isAttended)}
                        </td>
                        <td className="p-4">
                          <div className="text-sm">{timer.operador || 'N/A'}</div>
                        </td>
                        <td className="p-4 text-center">
                          {timer.timerActive ? (
                            <div className="flex flex-col items-center space-y-1">
                              <div className={`text-2xl font-bold timer-digits ${getTimerColor(timer.timeRemaining, timer.durationMinutes)} ${(timer.timeRemaining || 0) <= 60 ? 'pulse-animation' : ''}`}>
                                {formatTime(timer.timeRemaining || 0)}
                              </div>
                              <div className="text-xs text-muted-foreground">
                                {timer.durationMinutes || 20} min total
                              </div>
                            </div>
                          ) : (
                            <div className="text-muted-foreground">
                              <Pause className="w-4 h-4 mx-auto" />
                              <div className="text-xs mt-1">Inativo</div>
                            </div>
                          )}
                        </td>
                        <td className="p-4 text-center">
                          <Badge variant="outline" className="text-xs">
                            Nível {timer.currentLevel || 0}
                          </Badge>
                        </td>
                        <td className="p-4">
                          <div className="text-sm text-muted-foreground max-w-xs truncate">
                            {timer.observations || timer.obsChat || 'Sem observações'}
                          </div>
                        </td>
                      </tr>
                    ))
                  )}
                </tbody>
              </table>
            </div>
          </CardContent>
        </Card>

        {/* Footer Info */}
        <div className="text-center text-sm text-muted-foreground">
          <p>🔄 Sincronização automática a cada 2 segundos • Última atualização: {new Date().toLocaleTimeString()}</p>
        </div>
      </div>
    </div>
  );
};

import { useMemo } from 'react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@/components/ui/accordion';
import {
  Calendar,
  Clock,
  User,
  AlertTriangle,
  Tag,
  FileText,
  Users,
  History,
  CheckCircle2,
  XCircle,
  Phone,
  MessageSquare
} from 'lucide-react';
import { cn } from '@/lib/utils';

// importa seu hook de timers
import { useWebsocketTimers } from '@/hooks/useWebsocketTimers';

interface AlertData {
  id: string;
  chamado: string;
  tipo_chamado: string;
  grupo_chamado: string;
  status_chamado: string;
  abertura_chamado: string;
  resumo_chamado: string;
  severidade_chamado: string;
  acionado: string;
  chat: boolean;
}

interface ChamadoDetailsModalProps {
  isOpen: boolean;
  onClose: () => void;
  alertData: AlertData | null;
}

const LEVEL_INFO = {
  1: { title: "Primeiro Acionamento" },
  2: { title: "1ª Escalação" },
  3: { title: "2ª Escalação" },
  4: { title: "3ª Escalação" },
  5: { title: "4ª Escalação" },
};

const LEVEL_COLORS = {
  1: { bg: "bg-blue-500/10", border: "border-blue-500/30", text: "text-blue-700 dark:text-blue-400" },
  2: { bg: "bg-yellow-500/10", border: "border-yellow-500/30", text: "text-yellow-700 dark:text-yellow-400" },
  3: { bg: "bg-orange-500/10", border: "border-orange-500/30", text: "text-orange-700 dark:text-orange-400" },
  4: { bg: "bg-red-500/10", border: "border-red-500/30", text: "text-red-700 dark:text-red-400" },
  5: { bg: "bg-purple-600/10", border: "border-purple-600/30", text: "text-purple-700 dark:text-purple-400" },
};

export const ChamadoDetailsModal = ({ isOpen, onClose, alertData }: ChamadoDetailsModalProps) => {
  const { timers } = useWebsocketTimers();

  if (!alertData) return null;

  const formatDate = (dateString: string) => {
    if (!dateString || dateString === '' || dateString === 'null' || dateString === 'undefined') {
      return '-';
    }
    try {
      let date: Date;
      const cleanString = String(dateString).trim();

      if (/^\d{13}$/.test(cleanString)) {
        date = new Date(parseInt(cleanString));
      } else if (/^\d{10}$/.test(cleanString)) {
        date = new Date(parseInt(cleanString) * 1000);
      } else if (/^\d{2}\/\d{2}\/\d{4}/.test(cleanString)) {
        const parts = cleanString.split(' ');
        const datePart = parts[0];
        const timePart = parts[1] || '00:00:00';
        const [day, month, year] = datePart.split('/');
        const [hour, minute, second] = timePart.split(':');

        date = new Date(
          parseInt(year),
          parseInt(month) - 1,
          parseInt(day),
          parseInt(hour || '0'),
          parseInt(minute || '0'),
          parseInt(second || '0')
        );
      } else {
        date = new Date(cleanString);
      }

      if (isNaN(date.getTime())) return cleanString;

      return date.toLocaleString('pt-BR', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
      });
    } catch {
      return String(dateString);
    }
  };

  // gera histórico dinamicamente a partir dos timers
  const historicoAcionamentos = useMemo(() => {
    const timerState = timers.get(parseInt(alertData.chamado));
    if (!timerState) return [];

    const historico = [];
    for (let nivel = 1; nivel <= 5; nivel++) {
      const operador = timerState[`level${nivel}_operador`] || '';
      const pessoaAcionada = timerState[`level${nivel}_pessoaAcionada`] || '';
      const status = timerState[`level${nivel}_statusAcionamento`] || '';
      const observacao = timerState[`level${nivel}_observacao`] || '';
      const dataHora = timerState[`level${nivel}_dataHora`] || '';
      const updatedAt = timerState[`level${nivel}_updatedAt`] || '';

      if (operador || pessoaAcionada || status || observacao || dataHora) {
        historico.push({
          operador,
          pessoaAcionada,
          status,
          observacao,
          dataHora,
          updatedAt: formatDate(updatedAt),
          nivel,
        });
      }
    }
    return historico;
  }, [alertData.chamado, timers]);

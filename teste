import { useState, useEffect, useMemo, useCallback } from 'react';
import { Check, AlertTriangle, ExternalLink, Zap, Group, Calendar, Info, XCircle, Flame, ChevronLeft, ChevronRight, ArrowUpDown, ArrowUp, ArrowDown, User, FileText, Save, Edit3, CheckCircle, X, RefreshCw, Clock, Search, Play, Pause, SkipForward, RotateCcw } from 'lucide-react';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { toast } from '@/hooks/use-toast';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { useChatAcionados } from '@/hooks/use-chat-acionados';
import { useChatAcionadosTimestamps } from '@/hooks/use-chat-acionados-timestamps';

interface AlertData {
  id: string;
  chamado: string;
  tipo_chamado: string;
  grupo_chamado: string;
  status_chamado: string;
  abertura_chamado: string;
  resumo_chamado: string;
  severidade_chamado: string;
  acionado: string;
  chat: boolean;
}

interface ObservacaoData {
  chamado: number;
  observacao: string;
  status: string;
  operador: string;
  CreatedAt?: string;
}

interface AcionamentoData {
  chamado: string;
  etapa: 'primeiro_acionamento' | 'escalacao_1' | 'escalacao_2' | 'escalacao_3' | 'escalacao_4';
  status: 'em_andamento' | 'finalizado';
  observacoes: string;
  operador: string;
  iniciadoEm: number;
  finalizadoEm?: number;
  cronometroAtivo: boolean;
  tempoRestante: number; // em segundos (20 minutos = 1200 segundos)
}

interface ActionTableProps {
  alertData: AlertData[];
  onUpdateAcknowledgment: (alertId: string, acknowledged: boolean) => void;
  loading: boolean;
}

interface Obsstatus {
  status: string;
}

const Obsstatus: React.FC<Obsstatus> = ({ status }) => {
  if (status === "finalizado") {
    return null; // não renderiza nada
  }
}

type SortField = 'chamado' | 'tipo_chamado' | 'grupo_chamado' | 'status_chamado' | 'abertura_chamado' | 'resumo_chamado' | 'severidade_chamado' | 'acionado';
type SortDirection = 'asc' | 'desc' | null;

export const ActionTable = ({ alertData, onUpdateAcknowledgment, loading }: ActionTableProps) => {
  const [selectedIncident, setSelectedIncident] = useState<AlertData | null>(null);
  const [crisisDialogOpen, setCrisisDialogOpen] = useState(false);
  const [expandedRows, setExpandedRows] = useState<Set<string>>(new Set());
  const [currentPage, setCurrentPage] = useState(1);
  const [searchTerm, setSearchTerm] = useState('');
  const [itemsPerPage, setItemsPerPage] = useState<number>(() => {
    const saved = sessionStorage.getItem("itemsPerPage");
    return saved ? parseInt(saved, 10) : 5;
  });

  // Estados para ordenação
  const [sortField, setSortField] = useState<SortField>('chamado');
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc');

  // Usando o hook personalizado para chat acionados
  const { acionadosSet, isAcionado, addAcionado } = useChatAcionados();

  // Estados para observações
  const [observacoesData, setObservacoesData] = useState<Map<string, ObservacaoData>>(new Map());
  const [observacaoDialogOpen, setObservacaoDialogOpen] = useState(false);
  const [selectedChamadoForEdit, setSelectedChamadoForEdit] = useState<string>('');
  const [tempOperador, setTempOperador] = useState<string>('');
  const [tempObservacao, setTempObservacao] = useState<string>('');

  // Estados para acionamento/escalação
  const [acionamentosData, setAcionamentosData] = useState<Map<string, AcionamentoData>>(new Map());
  const [acionamentoDialogOpen, setAcionamentoDialogOpen] = useState(false);
  const [selectedChamadoAcionamento, setSelectedChamadoAcionamento] = useState<string>('');
  const [tempAcionamentoOperador, setTempAcionamentoOperador] = useState<string>('');
  const [tempAcionamentoObservacao, setTempAcionamentoObservacao] = useState<string>('');

  const { getTimestampForChamado, hasTimestamp, fetchTimestamps } = useChatAcionadosTimestamps();

  // Modal para detalhes do chamado
  const [chamadoModalOpen, setChamadoModalOpen] = useState(false);

  // Lista de operadores
  const operadores = [
    'ALBERTO LAGES',
    'ALEXANDRE LIMA SILVA',
    'ANSELMO ALVES PESSOA',
    'BRUNO MAZZO FEITOSA',
    'CAIO CESAR ALVES DA LUZ',
    'CLAUDIA ZORZAN DE CAMARGO',
    'JEFFERSON DA SILVA SOUZA',
    'JULIANA BEATRIZ DE ANGELO',
    'MARIA LUIZA DOS SANTOS COIADO',
    'RAFAEL NUNES PACHECO',
    'SERGIO ANTONIO DA SILVA',
    'VICTOR HUGO ALMEIDA FERNANDES',
    'VINICIUS RHYU VITURINO SAITO'
  ];

  // Cronômetro para acionamentos
  useEffect(() => {
    const interval = setInterval(() => {
      setAcionamentosData(prev => {
        const newData = new Map(prev);
        let hasChanges = false;

        for (const [chamado, acionamento] of newData.entries()) {
          if (acionamento.cronometroAtivo && acionamento.tempoRestante > 0) {
            acionamento.tempoRestante -= 1;
            hasChanges = true;

            // Se o tempo acabou, pausa o cronômetro
            if (acionamento.tempoRestante === 0) {
              acionamento.cronometroAtivo = false;
              toast({
                title: 'Tempo esgotado!',
                description: `O cronômetro do chamado ${chamado} chegou ao fim`,
                variant: 'destructive',
              });
            }
          }
        }

        return hasChanges ? newData : prev;
      });
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  // Funções para acionamento
  const iniciarAcionamento = (chamado: string) => {
    const novoAcionamento: AcionamentoData = {
      chamado,
      etapa: 'primeiro_acionamento',
      status: 'em_andamento',
      observacoes: '',
      operador: '',
      iniciadoEm: Date.now(),
      cronometroAtivo: true,
      tempoRestante: 1200, // 20 minutos em segundos
    };

    setAcionamentosData(prev => new Map(prev.set(chamado, novoAcionamento)));
    
    toast({
      title: 'Acionamento iniciado',
      description: `Primeiro acionamento do chamado ${chamado} iniciado`,
    });
  };

  const pausarCronometro = (chamado: string) => {
    setAcionamentosData(prev => {
      const newData = new Map(prev);
      const acionamento = newData.get(chamado);
      if (acionamento) {
        acionamento.cronometroAtivo = false;
        newData.set(chamado, acionamento);
      }
      return newData;
    });
  };

  const retomarCronometro = (chamado: string) => {
    setAcionamentosData(prev => {
      const newData = new Map(prev);
      const acionamento = newData.get(chamado);
      if (acionamento && acionamento.tempoRestante > 0) {
        acionamento.cronometroAtivo = true;
        newData.set(chamado, acionamento);
      }
      return newData;
    });
  };

  const proximaEtapa = (chamado: string) => {
    setAcionamentosData(prev => {
      const newData = new Map(prev);
      const acionamento = newData.get(chamado);
      if (acionamento) {
        const etapas: AcionamentoData['etapa'][] = [
          'primeiro_acionamento',
          'escalacao_1',
          'escalacao_2',
          'escalacao_3',
          'escalacao_4'
        ];
        
        const currentIndex = etapas.indexOf(acionamento.etapa);
        if (currentIndex < etapas.length - 1) {
          acionamento.etapa = etapas[currentIndex + 1];
          acionamento.tempoRestante = 1200; // Reset para 20 minutos
          acionamento.cronometroAtivo = true;
          acionamento.observacoes = '';
          
          toast({
            title: 'Próxima etapa',
            description: `Avançado para ${acionamento.etapa.replace('_', ' ')}`,
          });
        }
        newData.set(chamado, acionamento);
      }
      return newData;
    });
  };

  const voltarEtapa = (chamado: string) => {
    setAcionamentosData(prev => {
      const newData = new Map(prev);
      const acionamento = newData.get(chamado);
      if (acionamento) {
        const etapas: AcionamentoData['etapa'][] = [
          'primeiro_acionamento',
          'escalacao_1',
          'escalacao_2',
          'escalacao_3',
          'escalacao_4'
        ];
        
        const currentIndex = etapas.indexOf(acionamento.etapa);
        if (currentIndex > 0) {
          acionamento.etapa = etapas[currentIndex - 1];
          acionamento.tempoRestante = 1200; // Reset para 20 minutos
          acionamento.cronometroAtivo = true;
          acionamento.observacoes = '';
          
          toast({
            title: 'Etapa anterior',
            description: `Voltado para ${acionamento.etapa.replace('_', ' ')}`,
          });
        }
        newData.set(chamado, acionamento);
      }
      return newData;
    });
  };

  const finalizarAcionamento = (chamado: string) => {
    setAcionamentosData(prev => {
      const newData = new Map(prev);
      const acionamento = newData.get(chamado);
      if (acionamento) {
        acionamento.status = 'finalizado';
        acionamento.cronometroAtivo = false;
        acionamento.finalizadoEm = Date.now();
        
        toast({
          title: 'Acionamento finalizado',
          description: `Chamado ${chamado} foi finalizado`,
        });
      }
      newData.set(chamado, acionamento);
      return newData;
    });
  };

  const handleOpenAcionamento = (chamado: string) => {
    setSelectedChamadoAcionamento(chamado);
    const acionamento = acionamentosData.get(chamado);
    if (acionamento) {
      setTempAcionamentoOperador(acionamento.operador);
      setTempAcionamentoObservacao(acionamento.observacoes);
    } else {
      setTempAcionamentoOperador('');
      setTempAcionamentoObservacao('');
    }
    setAcionamentoDialogOpen(true);
  };

  const handleSaveAcionamento = () => {
    if (!tempAcionamentoOperador || !tempAcionamentoObservacao.trim()) {
      toast({
        title: 'Campos obrigatórios',
        description: 'Preencha o operador e a observação',
        variant: 'destructive',
      });
      return;
    }

    setAcionamentosData(prev => {
      const newData = new Map(prev);
      const acionamento = newData.get(selectedChamadoAcionamento);
      if (acionamento) {
        acionamento.operador = tempAcionamentoOperador;
        acionamento.observacoes = tempAcionamentoObservacao;
        newData.set(selectedChamadoAcionamento, acionamento);
      }
      return newData;
    });

    toast({
      title: 'Observação salva',
      description: 'A observação do acionamento foi salva com sucesso',
    });

    handleCancelAcionamento();
  };

  const handleCancelAcionamento = () => {
    setAcionamentoDialogOpen(false);
    setSelectedChamadoAcionamento('');
    setTempAcionamentoOperador('');
    setTempAcionamentoObservacao('');
  };

  // Função para formatar tempo restante
  const formatarTempo = (segundos: number) => {
    const minutos = Math.floor(segundos / 60);
    const segs = segundos % 60;
    return `${minutos.toString().padStart(2, '0')}:${segs.toString().padStart(2, '0')}`;
  };

  // Função para buscar observações da API com retry
  const fetchObservacoes = useCallback(async (retryCount = 0) => {
    try {
      const response = await fetch('https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/obs', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (response.ok) {
        const data: ObservacaoData[] = await response.json();
        const observacoesMap = new Map<string, ObservacaoData>();
        data.forEach(obs => {
          observacoesMap.set(obs.chamado.toString(), obs);
        });
        setObservacoesData(observacoesMap);
        console.log(`Observações carregadas: ${data.length} registros`);
      } else if (response.status === 404) {
        console.log('Nenhuma observação encontrada na API');
        setObservacoesData(new Map());
      } else {
        throw new Error(`API retornou status: ${response.status}`);
      }
    } catch (error) {
      console.error('Erro ao buscar observações:', error);

      if (retryCount < 3) {
        console.log(`Tentando novamente... (${retryCount + 1}/3)`);
        setTimeout(() => fetchObservacoes(retryCount + 1), 2000 * (retryCount + 1));
      } else {
        toast({
          title: 'Erro ao carregar observações',
          description: 'Não foi possível carregar dados salvos. As novas alterações funcionarão normalmente.',
          variant: 'destructive',
        });
      }
    }
  }, []);

  // Carrega observações ao montar o componente
  useEffect(() => {
    fetchObservacoes();
    fetchTimestamps();
  }, [fetchObservacoes, fetchTimestamps]);

  // Auto-refresh a cada 5 minutos
  useEffect(() => {
    const interval = setInterval(() => {
      fetchObservacoes();
      fetchTimestamps();
    }, 5 * 60 * 1000); // 5 minutos

    return () => clearInterval(interval);
  }, [fetchObservacoes, fetchTimestamps]);

  // Funções para manipular observações
  const handleOpenObservacao = (chamado: string) => {
    setSelectedChamadoForEdit(chamado);
    const existingObs = observacoesData.get(chamado);
    if (existingObs) {
      setTempOperador(existingObs.operador);
      setTempObservacao(existingObs.observacao);
    } else {
      setTempOperador('');
      setTempObservacao('');
    }
    setObservacaoDialogOpen(true);
  };

  const handleSaveObservacao = async () => {
    if (!tempOperador || !tempObservacao.trim() || !selectedChamadoForEdit) {
      toast({
        title: 'Campos obrigatórios',
        description: 'Preencha o operador e a observação',
        variant: 'destructive',
      });
      return;
    }

    try {
      const payload: ObservacaoData = {
        chamado: parseInt(selectedChamadoForEdit),
        observacao: tempObservacao.trim(),
        status: 'acionado',
        operador: tempOperador,
      };

      const response = await fetch('https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/obs', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`Erro na API: ${response.status}`);
      }

      const updatedObsData = new Map(observacoesData);
      updatedObsData.set(selectedChamadoForEdit, payload);
      setObservacoesData(updatedObsData);

      toast({
        title: 'Observação salva',
        description: 'A observação foi salva com sucesso',
      });

      fetchObservacoes();
      handleCancelObservacao();
    } catch (error) {
      console.error('Erro ao salvar observação:', error);
      toast({
        title: 'Erro ao salvar',
        description: 'Não foi possível salvar a observação',
        variant: 'destructive',
      });
    }
  };

  const handleCancelObservacao = () => {
    setObservacaoDialogOpen(false);
    setSelectedChamadoForEdit('');
    setTempOperador('');
    setTempObservacao('');
  };

  const handleAcknowledgment = async (alert: AlertData) => {
    try {
      const response = await fetch(
        "https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/webhook"
      );
      const data = await response.json();

      const grupoEntry = data.grupos.find(
        (g: any) => g.grupo_chamado === alert.grupo_chamado
      );

      if (!grupoEntry || !grupoEntry.webhooks.length) {
        toast({
          title: "Webhook não configurado",
          description: `Configure o webhook para o Grupo: ${alert.grupo_chamado}`,
          variant: "destructive",
        });
        return;
      }

      const activeWebhook = grupoEntry.webhooks.find((w: any) => w.ativo);
      if (!activeWebhook) {
        toast({
          title: "Nenhum webhook ativo",
          description: `O grupo ${alert.grupo_chamado} não possui webhooks ativos`,
          variant: "destructive",
        });
        return;
      }

      const webhookUrl = activeWebhook.url;

      const message = {
        cards: [
          {
            header: {
              title: "<b>🚨 O CIOPs precisa da sua atenção! <b>"
            },
            sections: [
              {
                widgets: [
                  {
                    textParagraph: {
                      text: `É necessário confirmação de recebimento e ciência pelo grupo responsável.`
                    }
                  }
                ]
              },
              {
                widgets: [
                  {
                    textParagraph: {
                      text:
                        "<b>Detalhes do Evento:</b><br><br>" +
                        "<b>📌 Chamado: </b>" + alert.chamado + "<br><br>" +
                        "<b>⚠️ Severidade: </b>" + alert.severidade_chamado + "<br><br>" +
                        "<b>📰 Título: </b>" + alert.resumo_chamado + "<br><br>" +
                        "<b>📅 Abertura: </b>" + alert.abertura_chamado + "<br><br>" +
                        "<b>👥 Grupo: </b>" + alert.grupo_chamado
                    }
                  }
                ],
              },
              {
                widgets: [
                  {
                    textParagraph: {
                      text: `<b>⚠️ Atenção: </b> Na ausência de confirmação, o CIOPs dará início ao processo de escalonamento, conforme procedimento padrão.`
                    }
                  }
                ]
              },
            ],
          },
        ],
      };

      await fetch(webhookUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(message),
      });

      const res = await fetch(
        "https://f6ffk8e9fe.execute-api.us-east-1.amazonaws.com/prod/chatacionados",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ chamado: alert.chamado.toString() }),
        }
      );

      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message || "Erro ao marcar como acionado");
      }

      addAcionado(alert.chamado.toString());
      onUpdateAcknowledgment(alert.id, true);

      toast({
        title: "Alerta acionado com sucesso",
        description: `Mensagem enviada para o Grupo: ${alert.grupo_chamado}`,
      });

    } catch (error: any) {
      toast({
        title: "Erro ao acionar alerta",
        description: error.message || "Não foi possível concluir o acionamento",
        variant: "destructive",
      });
    }
  };

  // Funções de ordenação, formatação, etc.

  const handleSort = (field: SortField) => {
    if (sortField === field) {
      if (sortDirection === 'asc') {
        setSortDirection('desc');
      } else if (sortDirection === 'desc') {
        setSortDirection(null);
        setSortField('chamado');
      } else {
        setSortDirection('asc');
      }
    } else {
      setSortField(field);
      setSortDirection('asc');
    }
  };

  const getSortIcon = (field: SortField) => {
    if (sortField !== field) {
      return <ArrowUpDown className="h-4 w-4 ml-1 opacity-50" />;
    }
    if (sortDirection === 'asc') {
      return <ArrowUp className="h-4 w-4 ml-1" />;
    }
    if (sortDirection === 'desc') {
      return <ArrowDown className="h-4 w-4 ml-1" />;
    }
    return <ArrowUpDown className="h-4 w-4 ml-1 opacity-50" />;
  };

  const formatDate = (dateString: string) => {
    if (!dateString || dateString === '' || dateString === 'null' || dateString === 'undefined') {
      return '-';
    }

    try {
      let date: Date;
      const cleanString = String(dateString).trim();

      if (/^\d{13}$/.test(cleanString)) {
        date = new Date(parseInt(cleanString));
      } else if (/^\d{10}$/.test(cleanString)) {
        date = new Date(parseInt(cleanString) * 1000);
      } else if (/^\d{2}\/\d{2}\/\d{4}/.test(cleanString)) {
        const parts = cleanString.split(' ');
        const datePart = parts[0];
        const timePart = parts[1] || '00:00:00';

        const [day, month, year] = datePart.split('/');
        const [hour, minute, second] = timePart.split(':');

        date = new Date(
          parseInt(year),
          parseInt(month) - 1,
          parseInt(day),
          parseInt(hour || '0'),
          parseInt(minute || '0'),
          parseInt(second || '0')
        );
      } else {
        date = new Date(cleanString);
      }

      if (isNaN(date.getTime())) {
        return cleanString;
      }

      const year = date.getFullYear();
      if (year < 1900 || year > 2100) {
        return cleanString;
      }

      return date.toLocaleString('pt-BR', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
      });
    } catch (error) {
      return String(dateString);
    }
  };

  const formatAcionadoStatus = (acionado: string) => {
    if (!acionado) return { text: '-', isOk: false };

    const upperAcionado = acionado.toUpperCase();
    if (upperAcionado === 'OK') {
      return { text: 'ACIONADO', isOk: true };
    } else if (upperAcionado === 'NOK') {
      return { text: 'NÃO ACIONADO', isOk: false };
    }

    return { text: acionado, isOk: false };
  };

  const filteredData = useMemo(() => {
    if (!searchTerm.trim()) {
      return alertData;
    }

    const searchLower = searchTerm.toLowerCase().trim();
    return alertData.filter(alert =>
      alert.chamado.toLowerCase().includes(searchLower) ||
      alert.tipo_chamado.toLowerCase().includes(searchLower) ||
      alert.grupo_chamado.toLowerCase().includes(searchLower) ||
      alert.status_chamado.toLowerCase().includes(searchLower) ||
      alert.resumo_chamado.toLowerCase().includes(searchLower) ||
      alert.severidade_chamado.toLowerCase().includes(searchLower) ||
      alert.acionado.toLowerCase().includes(searchLower)
    );
  }, [alertData, searchTerm]);

  const { sortedAndPaginatedData, totalPages } = useMemo(() => {
    let sortedData = [...filteredData];

    if (sortField && sortDirection) {
      sortedData.sort((a, b) => {
        let aValue: any = a[sortField];
        let bValue: any = b[sortField];

        if (sortField === 'chamado') {
          aValue = parseInt(a.chamado) || 0;
          bValue = parseInt(b.chamado) || 0;
        } else if (sortField === 'abertura_chamado') {
          aValue = new Date(a.abertura_chamado).getTime() || 0;
          bValue = new Date(b.abertura_chamado).getTime() || 0;
        } else {
          aValue = String(aValue).toLowerCase();
          bValue = String(bValue).toLowerCase();
        }

        if (aValue < bValue) {
          return sortDirection === 'asc' ? -1 : 1;
        }
        if (aValue > bValue) {
          return sortDirection === 'asc' ? 1 : -1;
        }
        return 0;
      });
    } else {
      sortedData.sort((a, b) => {
        const chamadoA = parseInt(a.chamado) || 0;
        const chamadoB = parseInt(b.chamado) || 0;
        return chamadoB - chamadoA;
      });
    }

    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const paginatedData = sortedData.slice(startIndex, endIndex);
    const totalPages = Math.ceil(sortedData.length / itemsPerPage);

    return {
      sortedAndPaginatedData: paginatedData,
      totalPages
    };
  }, [filteredData, currentPage, itemsPerPage, sortField, sortDirection]);

  useEffect(() => {
    setCurrentPage(1);
  }, [filteredData, itemsPerPage]);

  const handleItemsPerPageChange = (value: string) => {
    const num = parseInt(value, 10);
    setItemsPerPage(num);
    sessionStorage.setItem("itemsPerPage", num.toString());
  };

  const truncateText = (text: string, maxLength: number) => {
    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
  };

  const handleIncidentClick = (alert: AlertData) => {
    if (alert.tipo_chamado.toLowerCase().includes('incidente')) {
      setSelectedIncident(alert);
      setCrisisDialogOpen(true);
    }
  };

  const getSeverityColor = (severity: string) => {
    return severity.includes('4')
      ? 'bg-destructive text-destructive-foreground'
      : 'bg-yellow-500 text-yellow-950';
  };

  const handleChamadoClick = (alert: AlertData) => {
    setSelectedIncident(alert);
    setChamadoModalOpen(true);
  };

  const getStatusBadgeClass = (chat: boolean) =>
    chat
      ? 'bg-green-500/90 text-white border-green-500/50 shadow-md'
      : 'bg-red-500/90 text-white border-red-500/50 shadow-md';

  const getStatusIcon = (chat: boolean) =>
    chat ? <Check className="h-4 w-4" /> : <XCircle className="h-4 w-4" />;

  const getStatusText = (chat: boolean) => {
    return chat ? 'ACIONADO VIA CHAT' : 'NÃO ACIONADO VIA CHAT';
  };

  const handlePageChange = (page: number) => {
    setCurrentPage(page);
  };

  return (
    <TooltipProvider>
      <Card className="bg-card border-border">
        <CardHeader>
          {/* Campo de Pesquisa */}
          <div className="relative mb-4">
            <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              placeholder="Pesquisar por chamado, tipo, grupo, status, título..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="pl-10"
            />
          </div>

          <div className="flex items-center justify-between flex-wrap gap-4 mb-4">
            {searchTerm && (
              <div className="text-sm text-muted-foreground">
                {filteredData.length === 0 ? (
                  <span>Nenhum resultado encontrado para "{searchTerm}"</span>
                ) : (
                  <span>
                    {filteredData.length} resultado{filteredData.length !== 1 ? 's' : ''}
                    {filteredData.length !== alertData.length && ` de ${alertData.length} `}
                    para "{searchTerm}"
                  </span>
                )}
              </div>
            )}
          </div>
        </CardHeader>

        <CardContent>
          {/* Layout para Desktop */}
          <div className="overflow-x-auto">
            <Table className="min-w-[1200px]">
              <TableHeader>
                <TableRow className="border-border hover:bg-accent">
                  <TableHead className="text-muted-foreground w-20">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('chamado')}
                    >
                      Chamado
                      {getSortIcon('chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground w-24">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('tipo_chamado')}
                    >
                      Classificação
                      {getSortIcon('tipo_chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground w-20">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('grupo_chamado')}
                    >
                      Grupo
                      {getSortIcon('grupo_chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground w-20">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('status_chamado')}
                    >
                      Status
                      {getSortIcon('status_chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground w-28">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('abertura_chamado')}
                    >
                      Abertura
                      {getSortIcon('abertura_chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground flex-1 min-w-40">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('resumo_chamado')}
                    >
                      Título
                      {getSortIcon('resumo_chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground w-20">
                    <Button
                      variant="ghost"
                      className="h-auto p-0 font-medium text-muted-foreground hover:text-foreground text-xs"
                      onClick={() => handleSort('severidade_chamado')}
                    >
                      Severidade
                      {getSortIcon('severidade_chamado')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-muted-foreground w-16 text-center">Chat</TableHead>
                  <TableHead className="text-muted-foreground w-32 text-center">Observação</TableHead>
                  <TableHead className="text-muted-foreground w-40 text-center">Acionamento</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {loading ? (
                  <TableRow>
                    <TableCell colSpan={11} className="text-center py-8">
                      Carregando dados...
                    </TableCell>
                  </TableRow>
                ) : sortedAndPaginatedData.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={11} className="text-center py-8 text-muted-foreground">
                      {searchTerm ? 'Nenhum resultado encontrado' : 'Nenhum dado disponível'}
                    </TableCell>
                  </TableRow>
                ) : (
                  sortedAndPaginatedData.map((alert) => {
                    const isChat = acionadosSet.has(alert.chamado.toString());
                    const observacao = observacoesData.get(alert.chamado);
                    const acionamento = acionamentosData.get(alert.chamado);
                    
                    return (
                      <TableRow
                        key={alert.id}
                        className="border-border hover:bg-accent transition-colors"
                      >
                        <TableCell className="font-medium">
                          <Button
                            variant="link"
                            size="sm"
                            className="p-0 text-foreground hover:underline text-xs"
                            onClick={() => handleChamadoClick(alert)}
                          >
                            {alert.chamado}
                          </Button>
                        </TableCell>
                        <TableCell>
                          <Tooltip>
                            <TooltipTrigger asChild>
                              <span className="truncate block max-w-[80px] text-xs">
                                {alert.tipo_chamado}
                              </span>
                            </TooltipTrigger>
                            <TooltipContent>
                              <p className="max-w-xs">{alert.tipo_chamado}</p>
                            </TooltipContent>
                          </Tooltip>
                        </TableCell>
                        <TableCell className="text-xs">{alert.grupo_chamado}</TableCell>
                        <TableCell className="text-xs">{alert.status_chamado}</TableCell>
                        <TableCell className="text-xs">
                          {formatDate(alert.abertura_chamado)}
                        </TableCell>
                        <TableCell>
                          <div className="flex items-center gap-2">
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className="truncate block max-w-[120px] text-xs">
                                  {alert.resumo_chamado}
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <p className="max-w-md">{alert.resumo_chamado}</p>
                              </TooltipContent>
                            </Tooltip>
                          </div>
                        </TableCell>
                        <TableCell>
                          <Badge className={`${getSeverityColor(alert.severidade_chamado)} text-xs`}>
                            {alert.severidade_chamado}
                          </Badge>
                        </TableCell>
                        <TableCell>
                          <Button
                            variant={isChat ? "default" : "outline"}
                            size="sm"
                            onClick={() => !isChat && handleAcknowledgment(alert)}
                            disabled={isChat}
                            className={`${isChat
                              ? 'bg-green-600 text-white hover:bg-green-700'
                              : 'border-border hover:bg-accent'
                              } h-7 w-7 p-0`}
                          >
                            {isChat ? (
                              <Check className="h-3 w-3" />
                            ) : (
                              <AlertTriangle className="h-3 w-3" />
                            )}
                          </Button>
                        </TableCell>
                        <TableCell>
                          <Button
                            variant={observacao ? "default" : "outline"}
                            size="sm"
                            onClick={() => handleOpenObservacao(alert.chamado)}
                            className={`${observacao
                              ? 'bg-green-600 text-white hover:bg-green-700'
                              : 'border-border hover:bg-accent'
                              } h-7 w-7 p-0`}
                          >
                            {observacao ? (
                              <CheckCircle className="h-3 w-3" />
                            ) : (
                              <Edit3 className="h-3 w-3" />
                            )}
                          </Button>
                        </TableCell>
                        <TableCell>
                          <div className="flex items-center gap-1">
                            {!acionamento ? (
                              <Button
                                variant="outline"
                                size="sm"
                                onClick={() => iniciarAcionamento(alert.chamado)}
                                className="h-7 px-2 text-xs"
                              >
                                <Play className="h-3 w-3 mr-1" />
                                Iniciar
                              </Button>
                            ) : acionamento.status === 'finalizado' ? (
                              <Badge variant="default" className="text-xs bg-green-600 text-white">
                                Finalizado
                              </Badge>
                            ) : (
                              <div className="flex items-center gap-1">
                                <div className="text-xs text-center">
                                  <div className="font-mono font-bold text-primary">
                                    {formatarTempo(acionamento.tempoRestante)}
                                  </div>
                                  <div className="text-[10px] text-muted-foreground">
                                    {acionamento.etapa.replace('_', ' ')}
                                  </div>
                                </div>
                                <div className="flex flex-col gap-1">
                                  <Button
                                    variant="outline"
                                    size="sm"
                                    onClick={() => handleOpenAcionamento(alert.chamado)}
                                    className="h-6 w-6 p-0"
                                  >
                                    <Edit3 className="h-3 w-3" />
                                  </Button>
                                  {acionamento.cronometroAtivo ? (
                                    <Button
                                      variant="outline"
                                      size="sm"
                                      onClick={() => pausarCronometro(alert.chamado)}
                                      className="h-6 w-6 p-0"
                                    >
                                      <Pause className="h-3 w-3" />
                                    </Button>
                                  ) : (
                                    <Button
                                      variant="outline"
                                      size="sm"
                                      onClick={() => retomarCronometro(alert.chamado)}
                                      className="h-6 w-6 p-0"
                                      disabled={acionamento.tempoRestante === 0}
                                    >
                                      <Play className="h-3 w-3" />
                                    </Button>
                                  )}
                                </div>
                              </div>
                            )}
                          </div>
                        </TableCell>
                      </TableRow>
                    );
                  })
                )}
              </TableBody>
            </Table>
          </div>

          {/* Paginação */}
          {!loading && sortedAndPaginatedData.length > 0 && totalPages > 1 && (
            <div className="flex items-center justify-between mt-4 pt-4 border-t border-border">
              <div className="text-sm text-muted-foreground">
                Mostrando {((currentPage - 1) * itemsPerPage) + 1} a {Math.min(currentPage * itemsPerPage, filteredData.length)} de {filteredData.length} registros
                {searchTerm && filteredData.length !== alertData.length && ` (filtrados de ${alertData.length})`}
              </div>
              
              <div className="flex items-center gap-2">
                <Label htmlFor="itemsPerPage" className="text-sm font-medium whitespace-nowrap">
                  Por Página:
                </Label>
                <Select value={itemsPerPage.toString()} onValueChange={handleItemsPerPageChange}>
                  <SelectTrigger className="w-20">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="5">5</SelectItem>
                    <SelectItem value="10">10</SelectItem>
                    <SelectItem value="15">15</SelectItem>
                    <SelectItem value="20">20</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handlePageChange(currentPage - 1)}
                  disabled={currentPage === 1}
                  className="h-8 px-3"
                >
                  <ChevronLeft className="h-4 w-4 mr-1" />
                  Anterior
                </Button>

                <div className="flex items-center gap-1">
                  {[...Array(Math.min(totalPages, 5))].map((_, index) => {
                    let page;
                    if (totalPages <= 5) {
                      page = index + 1;
                    } else if (currentPage <= 3) {
                      page = index + 1;
                    } else if (currentPage >= totalPages - 2) {
                      page = totalPages - 4 + index;
                    } else {
                      page = currentPage - 2 + index;
                    }

                    return (
                      <Button
                        key={page}
                        variant={currentPage === page ? "default" : "outline"}
                        size="sm"
                        onClick={() => handlePageChange(page)}
                        className="h-8 w-8 p-0"
                      >
                        {page}
                      </Button>
                    );
                  })}
                </div>

                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handlePageChange(currentPage + 1)}
                  disabled={currentPage === totalPages}
                  className="h-8 px-3"
                >
                  Próximo
                  <ChevronRight className="h-4 w-4 ml-1" />
                </Button>
              </div>
            </div>
          )}

          {/* Dialog para Acionamento */}
          <Dialog open={acionamentoDialogOpen} onOpenChange={setAcionamentoDialogOpen}>
            <DialogContent className="max-w-md border-border shadow-2xl">
              <DialogHeader className="pb-4 border-b border-border">
                <DialogTitle className="text-left flex items-center gap-2">
                  <div className="p-2 rounded-lg bg-primary/10">
                    <Clock className="h-5 w-5 text-primary" />
                  </div>
                  <div>
                    <h3 className="text-lg font-semibold">Acionamento/Escalação</h3>
                    <p className="text-sm text-muted-foreground">
                      Chamado: {selectedChamadoAcionamento}
                      {acionamentosData.get(selectedChamadoAcionamento) && (
                        <span className="ml-2 text-primary font-medium">
                          {acionamentosData.get(selectedChamadoAcionamento)?.etapa.replace('_', ' ')}
                        </span>
                      )}
                    </p>
                  </div>
                </DialogTitle>
              </DialogHeader>

              {acionamentosData.get(selectedChamadoAcionamento) && (
                <div className="space-y-4 pt-4">
                  {/* Cronômetro */}
                  <div className="p-4 rounded-lg bg-accent/50 border border-border">
                    <div className="flex items-center justify-between">
                      <div>
                        <p className="text-sm font-medium">Tempo Restante</p>
                        <p className="text-2xl font-mono font-bold text-primary">
                          {formatarTempo(acionamentosData.get(selectedChamadoAcionamento)?.tempoRestante || 0)}
                        </p>
                      </div>
                      <div className="flex items-center gap-2">
                        {acionamentosData.get(selectedChamadoAcionamento)?.cronometroAtivo ? (
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => pausarCronometro(selectedChamadoAcionamento)}
                          >
                            <Pause className="h-4 w-4" />
                          </Button>
                        ) : (
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => retomarCronometro(selectedChamadoAcionamento)}
                            disabled={acionamentosData.get(selectedChamadoAcionamento)?.tempoRestante === 0}
                          >
                            <Play className="h-4 w-4" />
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* Controles de Etapa */}
                  <div className="flex items-center gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => voltarEtapa(selectedChamadoAcionamento)}
                      disabled={acionamentosData.get(selectedChamadoAcionamento)?.etapa === 'primeiro_acionamento'}
                      className="flex-1"
                    >
                      <RotateCcw className="h-4 w-4 mr-2" />
                      Voltar Etapa
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => proximaEtapa(selectedChamadoAcionamento)}
                      disabled={acionamentosData.get(selectedChamadoAcionamento)?.etapa === 'escalacao_4'}
                      className="flex-1"
                    >
                      <SkipForward className="h-4 w-4 mr-2" />
                      Próxima Etapa
                    </Button>
                  </div>

                  {/* Campo Operador */}
                  <div className="space-y-2">
                    <Label htmlFor="acionamento-operador" className="text-sm font-medium flex items-center gap-2">
                      <User className="h-4 w-4" />
                      Operador *
                    </Label>
                    <Select
                      value={tempAcionamentoOperador}
                      onValueChange={setTempAcionamentoOperador}
                    >
                      <SelectTrigger className="w-full">
                        <SelectValue placeholder="Selecione um operador" />
                      </SelectTrigger>
                      <SelectContent className="bg-popover border-border z-50">
                        {operadores.map((operador) => (
                          <SelectItem key={operador} value={operador}>
                            {operador}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>

                  {/* Campo Observação */}
                  <div className="space-y-2">
                    <Label htmlFor="acionamento-observacao" className="text-sm font-medium flex items-center gap-2">
                      <FileText className="h-4 w-4" />
                      Observações desta Etapa
                    </Label>
                    <Textarea
                      id="acionamento-observacao"
                      placeholder="Digite as observações desta etapa..."
                      value={tempAcionamentoObservacao}
                      onChange={(e) => setTempAcionamentoObservacao(e.target.value)}
                      className="min-h-[100px] resize-none"
                      rows={4}
                    />
                  </div>

                  {/* Ações */}
                  <div className="flex items-center gap-2 pt-6 border-t border-border">
                    <Button
                      variant="outline"
                      onClick={handleCancelAcionamento}
                      className="flex-1"
                    >
                      <X className="h-4 w-4 mr-2" />
                      Cancelar
                    </Button>
                    <Button
                      onClick={handleSaveAcionamento}
                      disabled={!tempAcionamentoOperador}
                      className="flex-1"
                    >
                      <Save className="h-4 w-4 mr-2" />
                      Salvar
                    </Button>
                    <Button
                      variant="destructive"
                      onClick={() => {
                        finalizarAcionamento(selectedChamadoAcionamento);
                        handleCancelAcionamento();
                      }}
                      className="flex-1"
                    >
                      <CheckCircle className="h-4 w-4 mr-2" />
                      Finalizar
                    </Button>
                  </div>
                </div>
              )}
            </DialogContent>
          </Dialog>

          {/* Dialog do Modal de Chamado - mantendo código original */}
          <Dialog open={chamadoModalOpen} onOpenChange={setChamadoModalOpen}>
            <DialogContent className="max-w-3xl max-h-[80vh] border-border shadow-2xl overflow-y-auto">
              <DialogHeader className="pb-6 border-b border-border">
                <DialogTitle className="text-left">
                  <div className="relative overflow-hidden rounded-2xl p-6 mb-4 bg-gradient-to-r from-primary to-primary/80">
                    <div className="relative z-10 flex items-start gap-4">
                      <div className="p-3 rounded-xl bg-white/20 backdrop-blur-sm border border-white/30 shadow-lg">
                        {selectedIncident?.tipo_chamado === "Solicitação" ? (
                          <Zap className="h-6 w-6 text-white drop-shadow-sm" />
                        ) : selectedIncident?.tipo_chamado === "Incidente" ? (
                          <AlertTriangle className="h-6 w-6 text-white drop-shadow-sm" />
                        ) : (
                          <Zap className="h-6 w-6 text-white drop-shadow-sm" />
                        )}
                      </div>

                      <div className="flex-1">
                        <div className="flex items-center gap-3 mb-2">
                          <span className="text-2xl font-bold text-white drop-shadow-sm">
                            {selectedIncident?.chamado}
                          </span>
                          <div className="h-1 flex-1 bg-white/20 rounded-full">
                            <div className="h-full w-3/4 bg-white/40 rounded-full"></div>
                          </div>
                        </div>

                        <h2 className="text-lg font-medium text-white/95 leading-relaxed drop-shadow-sm">
                          {selectedIncident?.resumo_chamado}
                        </h2>
                      </div>
                    </div>

                    {selectedIncident && (
                      <div className="relative z-10 flex flex-wrap items-center gap-3 mt-6">
                        <div className="animate-fade-in">
                          <div className={`${getStatusBadgeClass(selectedIncident.chat)} flex items-center gap-2 px-4 py-2 rounded-xl 
                              backdrop-blur-sm border border-white/20 shadow-lg`}>
                            {getStatusIcon(selectedIncident.chat)}
                            <span className="font-medium text-sm">
                              {getStatusText(selectedIncident.chat)}
                            </span>
                          </div>
                        </div>

                        <div className="animate-fade-in">
                          <div className="bg-white/20 text-white flex items-center gap-2 px-4 py-2 rounded-xl 
                              backdrop-blur-sm border border-white/30 shadow-lg">
                            <span className="font-medium text-sm">{selectedIncident.tipo_chamado}</span>
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                </DialogTitle>
              </DialogHeader>

              {selectedIncident && (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
                  <div className="space-y-4">
                    <div className="group relative overflow-hidden rounded-xl bg-card border border-border p-5 
                        shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1">
                      <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-primary to-blue-500"></div>
                      <div className="flex items-start gap-4">
                        <div className="p-2 rounded-lg bg-primary/10 group-hover:bg-primary/20 transition-colors duration-300">
                          <Group className="h-5 w-5 text-primary" />
                        </div>
                        <div className="flex-1">
                          <p className="text-sm text-muted-foreground font-medium mb-1">Grupo</p>
                          <p className="font-bold text-foreground text-lg">{selectedIncident.grupo_chamado}</p>
                        </div>
                      </div>
                    </div>

                    <div className="group relative overflow-hidden rounded-xl bg-card border border-border p-5 
                        shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1">
                      <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-green-500 to-emerald-500"></div>
                      <div className="flex items-start gap-4">
                        <div className="p-2 rounded-lg bg-green-500/10 group-hover:bg-green-500/20 transition-colors duration-300">
                          <Calendar className="h-5 w-5 text-green-600" />
                        </div>
                        <div className="flex-1">
                          <p className="text-sm text-muted-foreground font-medium mb-1">Data de Abertura</p>
                          <p className="font-bold text-foreground text-lg">{formatDate(selectedIncident.abertura_chamado)}</p>
                        </div>
                      </div>
                    </div>

                    {(() => {
                      const obsData = selectedIncident ? observacoesData.get(selectedIncident.chamado) : null;
                      return obsData?.CreatedAt && (
                        <div className="group relative overflow-hidden rounded-xl bg-card border border-border p-5 
                            shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1">
                          <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-purple-500 to-pink-500"></div>
                          <div className="flex items-start gap-4">
                            <div className="p-2 rounded-lg bg-purple-500/10 group-hover:bg-purple-500/20 transition-colors duration-300">
                              <Calendar className="h-5 w-5 text-purple-600" />
                            </div>
                            <div className="flex-1">
                              <p className="text-sm text-muted-foreground font-medium mb-1">Data da Confirmação</p>
                              <p className="font-bold text-foreground text-lg">{formatDate(obsData.CreatedAt)}</p>
                            </div>
                          </div>
                        </div>
                      );
                    })()}
                  </div>

                  <div className="space-y-4">
                    <div className="group relative overflow-hidden rounded-xl bg-card border border-border p-5 
                        shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1">
                      <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-blue-500 to-cyan-500"></div>
                      <div className="flex items-start gap-4">
                        <div className="p-2 rounded-lg bg-blue-500/10 group-hover:bg-blue-500/20 transition-colors duration-300">
                          <Info className="h-5 w-5 text-blue-600" />
                        </div>
                        <div className="flex-1">
                          <p className="text-sm text-muted-foreground font-medium mb-1">Status</p>
                          <p className="font-bold text-foreground text-lg">{selectedIncident.status_chamado}</p>
                        </div>
                      </div>
                    </div>

                    <div className="group relative overflow-hidden rounded-xl bg-card border border-border p-5 
                        shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1">
                      <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-red-500 to-orange-500"></div>
                      <div className="flex items-start gap-4">
                        <div className="p-2 rounded-lg bg-red-500/10 group-hover:bg-red-500/20 transition-colors duration-300">
                          <Flame className="h-5 w-5 text-red-600" />
                        </div>
                        <div className="flex-1">
                          <p className="text-sm text-muted-foreground font-medium mb-1">Severidade</p>
                          <p className="font-bold text-foreground text-lg">{selectedIncident.severidade_chamado}</p>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </DialogContent>
          </Dialog>

          {/* Dialog para editar observação - mantendo código original */}
          <Dialog open={observacaoDialogOpen} onOpenChange={setObservacaoDialogOpen}>
            <DialogContent className="max-w-md border-border shadow-2xl">
              <DialogHeader className="pb-4 border-b border-border">
                <DialogTitle className="text-left flex items-center gap-2">
                  <div className="p-2 rounded-lg bg-primary/10">
                    <FileText className="h-5 w-5 text-primary" />
                  </div>
                  <div>
                    <h3 className="text-lg font-semibold">Registro de Acionamento</h3>
                    <p className="text-sm text-muted-foreground">Chamado: {selectedChamadoForEdit}</p>
                  </div>
                </DialogTitle>
              </DialogHeader>

              <div className="space-y-4 pt-4">
                <div className="space-y-2">
                  <Label htmlFor="operador" className="text-sm font-medium flex items-center gap-2">
                    <User className="h-4 w-4" />
                    Operador *
                  </Label>
                  <Select
                    value={tempOperador}
                    onValueChange={setTempOperador}
                  >
                    <SelectTrigger className="w-full">
                      <SelectValue placeholder="Selecione um operador" />
                    </SelectTrigger>
                    <SelectContent className="bg-popover border-border z-50">
                      {operadores.map((operador) => (
                        <SelectItem key={operador} value={operador}>
                          {operador}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                <div className="space-y-2">
                  {selectedChamadoForEdit && hasTimestamp(selectedChamadoForEdit) && (
                    <div className="p-3 rounded-lg bg-blue-50 border border-blue-200 dark:bg-blue-950/20 dark:border-blue-800">
                      <div className="flex items-center gap-2 text-blue-700 dark:text-blue-300">
                        <Clock className="h-4 w-4" />
                        <span className="text-sm font-medium">Acionado no chat em:</span>
                      </div>
                      <p className="text-sm font-mono text-blue-800 dark:text-blue-200 mt-1">
                        {getTimestampForChamado(selectedChamadoForEdit)}
                      </p>
                    </div>
                  )}
                  <div className="flex items-center justify-between">
                    <Label htmlFor="observacao" className="text-sm font-medium flex items-center gap-2">
                      <FileText className="h-4 w-4" />
                      Observações
                    </Label>
                    {tempOperador && selectedChamadoForEdit && (
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => {
                          const grupo = alertData.find(a => a.chamado === selectedChamadoForEdit)?.grupo_chamado || 'XXXX';
                          const timestamp = getTimestampForChamado(selectedChamadoForEdit);
                          const baseText = `Informado no chat do grupo ${grupo}`;
                          const fullText = timestamp ? `${baseText} em ${timestamp}` : baseText;
                          setTempObservacao(fullText);
                        }}
                        className="text-xs h-7 px-2"
                      >
                        Modelo de Texto
                      </Button>
                    )}
                  </div>
                  <Textarea
                    id="observacao"
                    placeholder={!tempOperador ? "Selecione um operador primeiro..." : "Digite suas observações aqui..."}
                    value={tempObservacao}
                    onChange={(e) => setTempObservacao(e.target.value)}
                    disabled={!tempOperador}
                    className="min-h-[100px] resize-none"
                    rows={4}
                  />
                  {!tempOperador && (
                    <p className="text-xs text-muted-foreground">
                      O campo de observação só pode ser preenchido após selecionar um operador.
                    </p>
                  )}
                </div>

                {tempOperador && tempObservacao && (
                  <div className="p-3 rounded-lg bg-success/10 border border-success/20">
                    <div className="flex items-center gap-2 text-success">
                      <CheckCircle className="h-4 w-4" />
                      <span className="text-sm font-medium">
                        Após salvar, este item será marcado como FINALIZADO
                      </span>
                    </div>
                  </div>
                )}
              </div>

              <div className="flex items-center gap-2 pt-6 border-t border-border">
                <Button
                  variant="outline"
                  onClick={handleCancelObservacao}
                  className="flex-1"
                >
                  <X className="h-4 w-4 mr-2" />
                  Cancelar
                </Button>
                <Button
                  onClick={handleSaveObservacao}
                  disabled={!tempOperador}
                  className="flex-1"
                >
                  <Save className="h-4 w-4 mr-2" />
                  Salvar
                </Button>
              </div>
            </DialogContent>
          </Dialog>
        </CardContent>
      </Card>
    </TooltipProvider>
  );
};

export default Obsstatus;

import os
import pyodbc
import json
import time
import boto3
from datetime import datetime
from botocore.exceptions import ClientError

def lambda_handler(event, context):
    start_total = time.time()
    print("[INÍCIO] Execução da Lambda")

    # ---------- VARIÁVEIS DE AMBIENTE ----------
    server = os.environ['DB_SERVER']
    username = os.environ['DB_USER']
    password = os.environ['DB_PASSWORD']
    port = os.environ.get('DB_PORT', '1433')
    database = 'mdb'

    connections_table_name = os.environ['CONNECTIONS_TABLE']
    state_table_name = os.environ['STATE_TABLE']  # nova tabela DynamoDB
    ws_api_endpoint = os.environ['WS_API_ENDPOINT']

    dynamodb = boto3.resource('dynamodb')
    connections_table = dynamodb.Table(connections_table_name)
    state_table = dynamodb.Table(state_table_name)

    apigw = boto3.client('apigatewaymanagementapi', endpoint_url=ws_api_endpoint)

    try:
        # ---------- CONEXÃO COM SQL ----------
        start_conexao = time.time()
        connection_string = (
            f'DRIVER={{ODBC Driver 18 for SQL Server}};'
            f'SERVER={server},{port};'
            f'DATABASE={database};'
            f'UID={username};'
            f'PWD={password};'
            f'Encrypt=no;TrustServerCertificate=yes;CHARSET=UTF8;'
        )
        conn = pyodbc.connect(connection_string, timeout=5)
        cursor = conn.cursor()
        print(f"[TEMPO] Conexão: {time.time() - start_conexao:.2f}s")

        # ---------- QUERY ----------
        query = """
            SELECT [chamado]
                  ,[tipo_chamado]
                  ,[status_chamado]
                  ,[abertura_chamado]
                  ,[resumo_chamado]
                  ,[grupo_chamado]
                  ,[severidade_chamado]
                  ,[acionado]
                  ,[link_chamado]
            FROM [mdb].[dbo].[view_ciops_acionamento]
            WHERE TRY_CONVERT(DATETIME, abertura_chamado, 103) >= DATEADD(HOUR, -10, GETDATE());
        """
        cursor.execute(query)
        rows = cursor.fetchall()

        # ---------- PROCESSA RESULTADOS ----------
        columns = [column[0] for column in cursor.description]
        current_records = []
        for row in rows:
            row_dict = dict(zip(columns, row))
            if isinstance(row_dict.get("abertura_chamado"), datetime):
                row_dict["abertura_chamado"] = row_dict["abertura_chamado"].strftime("%Y-%m-%dT%H:%M:%S")
            current_records.append(row_dict)

        cursor.close()
        conn.close()

        current_ids = {r["chamado"] for r in current_records}

        # ---------- CARREGA ÚLTIMO ESTADO ----------
        try:
            last_state = state_table.get_item(Key={"id": "last_state"}).get("Item", {})
            previous_ids = set(last_state.get("chamados", []))
        except Exception:
            previous_ids = set()

        # ---------- COMPARA DIFERENÇAS ----------
        new_ids = current_ids - previous_ids
        removed_ids = previous_ids - current_ids

        added_records = [r for r in current_records if r["chamado"] in new_ids]
        removed_records = list(removed_ids)

        print(f"[INFO] Novos: {len(added_records)}, Removidos: {len(removed_records)}")

        # ---------- SALVA NOVO ESTADO ----------
        state_table.put_item(Item={
            "id": "last_state",
            "timestamp": datetime.utcnow().isoformat(),
            "chamados": list(current_ids)
        })

        # ---------- SE NÃO HOUVER MUDANÇAS, ENCERRA ----------
        if not added_records and not removed_records:
            print("[INFO] Nenhuma alteração detectada")
            return {"statusCode": 200, "body": json.dumps({"message": "Sem alterações"})}

        # ---------- MONTA MENSAGEM ----------
        message = {
            "action": "getChamados",
            "added": added_records,
            "removed": removed_records
        }

        # ---------- ENVIA AOS CLIENTES ----------
        connections = connections_table.scan().get("Items", [])
        print(f"[INFO] Enviando atualização para {len(connections)} conexões")

        for conn_item in connections:
            connection_id = conn_item.get("connectionId")
            try:
                apigw.post_to_connection(
                    ConnectionId=connection_id,
                    Data=json.dumps(message, ensure_ascii=False).encode('utf-8')
                )
            except ClientError as e:
                if e.response['Error']['Code'] == 'GoneException':
                    print(f"[REMOVENDO] Conexão expirada: {connection_id}")
                    connections_table.delete_item(Key={'connectionId': connection_id})
                else:
                    print(f"[ERRO envio] {connection_id}: {e}")

        print(f"[TOTAL] Tempo total: {time.time() - start_total:.2f}s")

        return {
            "statusCode": 200,
            "body": json.dumps({"message": "Atualizações enviadas"})
        }

    except Exception as e:
        print("[ERRO]", str(e))
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)}, ensure_ascii=False)
        }

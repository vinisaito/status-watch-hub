import json
import boto3
from datetime import datetime, timezone

# ðŸ”¹ DEFINA SEUS VALORES AQUI:
CONNECTIONS_TABLE = "ConnectionsTableName"  # Nome da tabela de conexÃµes
CHAMADOS_TABLE = "ChamadosTableName"       # Nome da tabela de chamados
WEBSOCKET_API_ENDPOINT = "https://xxxxxx.execute-api.REGION.amazonaws.com/dev"  # Endpoint da API WebSocket

# ðŸ”¹ InicializaÃ§Ã£o de recursos AWS
dynamodb = boto3.resource("dynamodb")
connections_table = dynamodb.Table(CONNECTIONS_TABLE)
chamados_table = dynamodb.Table(CHAMADOS_TABLE)
apigw = boto3.client("apigatewaymanagementapi", endpoint_url=WEBSOCKET_API_ENDPOINT)


# ðŸ”¹ FunÃ§Ã£o para enviar mensagens a uma conexÃ£o WebSocket
def send_to_connection(connection_id, payload):
    try:
        apigw.post_to_connection(
            ConnectionId=connection_id,
            Data=json.dumps(payload).encode("utf-8")
        )
    except apigw.exceptions.GoneException:
        connections_table.delete_item(Key={"connectionId": connection_id})


# ðŸ”¹ Broadcast: envia mensagem para todas as conexÃµes
def broadcast(payload):
    resp = connections_table.scan()
    for conn in resp.get("Items", []):
        send_to_connection(conn["connectionId"], payload)


# ðŸ”¹ Buscar um chamado
def get_chamado(chamado_id):
    res = chamados_table.get_item(Key={"chamado": int(chamado_id)})
    return res.get("Item")


# ðŸ”¹ Atualizar um chamado
def update_chamado(chamado_id, updates: dict):
    update_expr = "SET " + ", ".join(f"{k} = :{k}" for k in updates)
    expr_vals = {f":{k}": v for k, v in updates.items()}
    chamados_table.update_item(
        Key={"chamado": int(chamado_id)},
        UpdateExpression=update_expr,
        ExpressionAttributeValues=expr_vals
    )


# ðŸ”¹ Calcular tempo restante do chamado
def calc_remaining(item):
    total = (item.get("durationMinutes", 15)) * 60
    if not item.get("timerActive"):
        return item.get("timeRemaining", total)

    started_at = datetime.fromisoformat(item["startedAt"].replace("Z", "+00:00"))
    elapsed = int((datetime.now(timezone.utc) - started_at).total_seconds())
    return max(0, total - elapsed)


# ðŸ”¹ Handler principal da Lambda
def lambda_handler(event, context):
    print("Evento recebido:", json.dumps(event))

    connection_id = event.get("requestContext", {}).get("connectionId")
    route_key = event.get("requestContext", {}).get("routeKey")

    # ðŸ”¹ ConexÃ£o inicial
    if route_key == "$connect":
        connections_table.put_item(Item={"connectionId": connection_id})
        return {"statusCode": 200, "body": "Connected"}

    # ðŸ”¹ DesconexÃ£o
    if route_key == "$disconnect":
        connections_table.delete_item(Key={"connectionId": connection_id})
        return {"statusCode": 200, "body": "Disconnected"}

    # ðŸ”¹ Mensagens WebSocket
    if route_key == "$default":
        body = json.loads(event.get("body", "{}"))
        action = body.get("action")

        if action == "startTimer":
            chamado = body["chamado"]
            now = datetime.now(timezone.utc).isoformat()
            update_chamado(chamado, {
                "startedAt": now,
                "timerActive": True,
                "timeRemaining": None
            })
            item = get_chamado(chamado)
            broadcast({
                "type": "TIMER_UPDATED",
                "chamado": chamado,
                "startedAt": item["startedAt"],
                "durationMinutes": item.get("durationMinutes", 15),
                "timerActive": True
            })
            return {"statusCode": 200, "body": "Timer started"}

        elif action == "pauseTimer":
            chamado = body["chamado"]
            item = get_chamado(chamado)
            remaining = calc_remaining(item)
            update_chamado(chamado, {
                "timerActive": False,
                "timeRemaining": remaining
            })
            updated = get_chamado(chamado)
            broadcast({
                "type": "TIMER_UPDATED",
                "chamado": chamado,
                "startedAt": updated.get("startedAt"),
                "durationMinutes": updated.get("durationMinutes", 15),
                "timerActive": False,
                "timeRemaining": updated.get("timeRemaining")
            })
            return {"statusCode": 200, "body": "Timer paused"}

        elif action == "getAll":
            resp = chamados_table.scan()
            items = resp.get("Items", [])
            for c in items:
                c["timeRemaining"] = calc_remaining(c)
            send_to_connection(connection_id, {"type": "ALL_CHAMADOS", "data": items})
            return {"statusCode": 200, "body": "All chamados sent"}

        return {"statusCode": 400, "body": "Unknown action"}

    # ðŸ”¹ Endpoint REST (para sessÃµes novas ou refresh)
    if event.get("httpMethod") == "GET":
        resp = chamados_table.scan()
        items = resp.get("Items", [])
        for c in items:
            c["timeRemaining"] = calc_remaining(c)
        return {"statusCode": 200, "body": json.dumps(items)}

    return {"statusCode": 400, "body": "Invalid request"}

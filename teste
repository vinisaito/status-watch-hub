import boto3
import json
from datetime import datetime
from decimal import Decimal

# Conecta no DynamoDB
dynamodb = boto3.resource("dynamodb", region_name="us-east-1")
table = dynamodb.Table("painelmonitoracao_acompanhamento")

# Função para serializar Decimal
def json_serial(obj):
    if isinstance(obj, Decimal):
        if obj % 1 == 0:
            return int(obj)
        else:
            return float(obj)
    raise TypeError

# Função helper de response
def response(status_code, body):
    return {
        "statusCode": status_code,
        "headers": {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "OPTIONS,POST,GET,PATCH",
            "Access-Control-Allow-Headers": "Content-Type"
        },
        "body": json.dumps(body, default=json_serial)
    }

def lambda_handler(event, context):
    method = event.get("httpMethod")
    path = event.get("path")
    body = {}

    # Se vier corpo no request, tenta decodificar
    if event.get("body"):
        try:
            body = json.loads(event["body"])
        except:
            body = {}

    try:
        # Criar novo alerta
        if method == "POST" and path == "/acompanhamento":
            return create_alert(body)

        # Atualizar campos principais do alerta (status, cronômetro, etc)
        if method == "PATCH" and path.startswith("/acompanhamento/") and "/escalation/" not in path:
            alert_id = int(path.split("/")[2])
            return update_alert(alert_id, body)

        # Atualizar escalonamento específico
        if method == "PATCH" and "/escalation/" in path:
            parts = path.strip("/").split("/")
            alert_id = int(parts[1])
            level = int(parts[3])
            return update_escalation(alert_id, level, body)

        # Buscar um alerta específico
        if method == "GET" and path.startswith("/acompanhamento/") and path != "/acompanhamento":
            alert_id = int(path.split("/")[2])
            return get_alert(alert_id)

        # Listar alertas
        if method == "GET" and path == "/acompanhamento":
            return list_alerts()

        return response(400, {"error": "Rota não suportada"})

    except Exception as e:
        print("Erro:", str(e))
        return response(500, {"error": str(e)})

# -------------------------------
# Criar alerta
# -------------------------------
def create_alert(data):
    chamado_raw = data.get("chamado")
    if chamado_raw is None:
        return response(400, {"error": "Campo 'chamado' é obrigatório"})

    try:
        chamado = int(chamado_raw)
    except ValueError:
        return response(400, {"error": "Campo 'chamado' deve ser numérico"})

    now = datetime.utcnow().isoformat()

    alert = {
        "chamado": chamado,
        "alertOpenTime": data.get("alertOpenTime", now),
        "sendChat": data.get("sendChat", ""),
        "confirmChat": data.get("confirmChat", ""),
        "obsChat": data.get("obsChat", ""),
        "operador": data.get("operador", ""),
        # Campos de persistência do cronômetro e escalação
        "status": data.get("status", "pending"),
        "timeRemaining": data.get("timeRemaining", 0),
        "timerActive": data.get("timerActive", False),
        "observations": data.get("observations", ""),
        "pendingChange": data.get("pendingChange", {}),
        "currentLevel": data.get("currentLevel", 0),
        "isAttended": data.get("isAttended", False),
        "startedAt": data.get("startedAt", now),
        "updatedAt": now,
        "escalations": [
            {"level": i, "status": "", "observations": "", "eventTimestamp": "", "operador": ""}
            for i in range(1, 5)
        ],
        "ttl": int(datetime.utcnow().timestamp()) + 60 * 60 * 24 * 180  # 6 meses
    }

    table.put_item(Item=alert)
    return response(201, alert)

# -------------------------------
# Atualizar alerta (status geral)
# -------------------------------
def update_alert(alert_id, data):
    timestamp = datetime.utcnow().isoformat()

    update_expression = "SET "
    expr_names = {}
    expr_values = {}

    allowed_fields = [
        "status", "timeRemaining", "timerActive",
        "observations", "pendingChange", "currentLevel",
        "isAttended", "operador"
    ]

    for i, field in enumerate(allowed_fields):
        if field in data:
            if len(expr_values) > 0:
                update_expression += ", "
            update_expression += f"#{field} = :{field}"
            expr_names[f"#{field}"] = field
            expr_values[f":{field}"] = data[field]

    # Sempre atualiza o updatedAt
    update_expression += ", updatedAt = :updatedAt"
    expr_values[":updatedAt"] = timestamp

    result = table.update_item(
        Key={"chamado": alert_id},
        UpdateExpression=update_expression,
        ExpressionAttributeNames=expr_names,
        ExpressionAttributeValues=expr_values,
        ReturnValues="ALL_NEW"
    )

    return response(200, result["Attributes"])

# -------------------------------
# Atualizar escalonamento específico
# -------------------------------
def update_escalation(alert_id, level, data):
    timestamp = datetime.utcnow().isoformat()
    idx = level - 1

    update_expression = (
        f"SET escalations[{idx}].#s = :status, "
        f"escalations[{idx}].observations = :obs, "
        f"escalations[{idx}].eventTimestamp = :ts, "
        f"escalations[{idx}].operador = :op"
    )
    expression_attr_names = {"#s": "status"}
    expression_attr_values = {
        ":status": data.get("status", ""),
        ":obs": data.get("observations", ""),
        ":ts": timestamp,
        ":op": data.get("operador", "")
    }

    result = table.update_item(
        Key={"chamado": alert_id},
        UpdateExpression=update_expression,
        ExpressionAttributeNames=expression_attr_names,
        ExpressionAttributeValues=expression_attr_values,
        ReturnValues="ALL_NEW"
    )

    return response(200, result["Attributes"])

# -------------------------------
# Buscar alerta específico
# -------------------------------
def get_alert(alert_id):
    result = table.get_item(Key={"chamado": alert_id})
    item = result.get("Item", {})
    return response(200, item)

# -------------------------------
# Listar alertas
# -------------------------------
def list_alerts():
    result = table.scan(Limit=50)
    return response(200, result.get("Items", []))

import React, { useEffect, useRef, useState } from "react";

interface TimerData {
  chamado: number;
  timerActive: boolean;
  startedAt: string | null;
  durationMinutes: number;
  timeRemaining: number;
}

const WEBSOCKET_URL = "wss://SEU_ENDPOINT_WS"; // Defina aqui
const GETSTATE_URL = "https://SEU_ENDPOINT_API/getState"; // Para fetch inicial se necess√°rio

const Timer: React.FC<{ chamado: number }> = ({ chamado }) => {
  const [timerData, setTimerData] = useState<TimerData>({
    chamado,
    timerActive: false,
    startedAt: null,
    durationMinutes: 15,
    timeRemaining: 15 * 60,
  });

  const wsRef = useRef<WebSocket | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  // Conectar WebSocket
  useEffect(() => {
    console.log("üåê Conectando WebSocket...");
    const ws = new WebSocket(WEBSOCKET_URL);
    wsRef.current = ws;

    ws.onopen = () => {
      console.log("‚úÖ WebSocket conectado");
      // Opcional: solicitar estado inicial
      ws.send(JSON.stringify({ action: "getState", chamado }));
      console.log("üì® Solicitando estado inicial com getState");
    };

    ws.onmessage = (event) => {
      console.log("üì© Mensagem recebida do WS:", event.data);
      try {
        const data = JSON.parse(event.data);
        if (data.type === "TIMER_UPDATED") {
          console.log("‚è± Atualizando state com TIMER_UPDATED:", data);
          setTimerData({
            chamado: data.chamado,
            timerActive: data.timerActive,
            startedAt: data.startedAt,
            durationMinutes: data.durationMinutes,
            timeRemaining: data.timeRemaining,
          });
        }
      } catch (e) {
        console.error("‚ùå Erro ao processar mensagem WS:", e);
      }
    };

    ws.onerror = (err) => console.error("‚ùå WS erro:", err);
    ws.onclose = () => console.log("‚ö†Ô∏è WebSocket fechado");

    return () => {
      if (wsRef.current) {
        wsRef.current.close();
      }
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [chamado]);

  // Intervalo para decrementar tempo restante
  useEffect(() => {
    if (intervalRef.current) clearInterval(intervalRef.current);

    intervalRef.current = setInterval(() => {
      setTimerData((prev) => {
        if (!prev.timerActive || prev.timeRemaining <= 0) return prev;
        const newRemaining = prev.timeRemaining - 1;
        console.log(`‚è≥ Tempo restante atualizado: ${newRemaining}s`);
        return { ...prev, timeRemaining: newRemaining };
      });
    }, 1000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [timerData.timerActive]);

  const sendAction = (action: string) => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      console.log(`üì§ Enviando a√ß√£o: ${action}`);
      wsRef.current.send(JSON.stringify({ action, chamado }));
    } else {
      console.warn("‚ö†Ô∏è WebSocket n√£o conectado ainda ou fechado");
    }
  };

  const formatTime = (seconds: number) => {
    const min = Math.floor(seconds / 60)
      .toString()
      .padStart(2, "0");
    const sec = (seconds % 60).toString().padStart(2, "0");
    return `${min}:${sec}`;
  };

  return (
    <div style={{ border: "1px solid #ccc", padding: "1rem", width: "250px" }}>
      <h3>Chamado: {timerData.chamado}</h3>
      <p>Status: {timerData.timerActive ? "Ativo" : "Pausado"}</p>
      <p>Tempo restante: {formatTime(timerData.timeRemaining)}</p>
      <button onClick={() => sendAction("startTimer")}>Iniciar</button>
      <button onClick={() => sendAction("pauseTimer")}>Pausar</button>
    </div>
  );
};

export default Timer;

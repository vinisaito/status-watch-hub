// Lambda handler para WebSocket + API Gateway + DynamoDB
const AWS = require("aws-sdk");
const dynamo = new AWS.DynamoDB.DocumentClient();
const api = new AWS.ApiGatewayManagementApi({
  endpoint: process.env.WEBSOCKET_API_ENDPOINT
});

const CONNECTIONS_TABLE = process.env.CONNECTIONS_TABLE;
const CHAMADOS_TABLE = process.env.CHAMADOS_TABLE;

// Função auxiliar para enviar mensagens pelo WS
async function sendToConnection(connectionId, payload) {
  try {
    await api
      .postToConnection({
        ConnectionId: connectionId,
        Data: JSON.stringify(payload)
      })
      .promise();
  } catch (err) {
    if (err.statusCode === 410) {
      // Conexão morta, remover
      await dynamo
        .delete({
          TableName: CONNECTIONS_TABLE,
          Key: { connectionId }
        })
        .promise();
    } else {
      console.error("Erro ao enviar WS:", err);
    }
  }
}

// Broadcast para todas as conexões
async function broadcast(payload) {
  const connections = await dynamo.scan({ TableName: CONNECTIONS_TABLE }).promise();
  await Promise.all(
    connections.Items.map((c) => sendToConnection(c.connectionId, payload))
  );
}

// Recuperar um chamado
async function getChamado(chamado) {
  const res = await dynamo
    .get({
      TableName: CHAMADOS_TABLE,
      Key: { chamado: Number(chamado) }
    })
    .promise();
  return res.Item;
}

// Atualizar DynamoDB
async function updateChamado(chamado, updates) {
  const keys = Object.keys(updates);
  const expr = keys.map((k) => `${k} = :${k}`).join(", ");
  const values = {};
  keys.forEach((k) => (values[`:${k}`] = updates[k]));

  await dynamo
    .update({
      TableName: CHAMADOS_TABLE,
      Key: { chamado: Number(chamado) },
      UpdateExpression: `SET ${expr}`,
      ExpressionAttributeValues: values
    })
    .promise();
}

// Calcular tempo restante
function calcRemaining(item) {
  const total = (item.durationMinutes || 15) * 60;
  if (!item.timerActive) return item.timeRemaining ?? total;
  const elapsed = Math.floor((Date.now() - new Date(item.startedAt).getTime()) / 1000);
  return Math.max(0, total - elapsed);
}

exports.handler = async (event) => {
  console.log("Evento recebido:", JSON.stringify(event, null, 2));

  // Conexão WebSocket
  const connectionId = event.requestContext?.connectionId;
  const routeKey = event.requestContext?.routeKey;

  // Conectar
  if (routeKey === "$connect") {
    await dynamo
      .put({
        TableName: CONNECTIONS_TABLE,
        Item: { connectionId }
      })
      .promise();
    return { statusCode: 200, body: "Connected." };
  }

  // Desconectar
  if (routeKey === "$disconnect") {
    await dynamo
      .delete({
        TableName: CONNECTIONS_TABLE,
        Key: { connectionId }
      })
      .promise();
    return { statusCode: 200, body: "Disconnected." };
  }

  // Mensagens WebSocket
  if (routeKey === "$default") {
    const body = JSON.parse(event.body || "{}");
    const action = body.action;

    if (!action) return { statusCode: 400, body: "No action provided" };

    if (action === "startTimer") {
      const chamado = body.chamado;
      await updateChamado(chamado, {
        startedAt: new Date().toISOString(),
        timerActive: true,
        timeRemaining: null
      });
      const item = await getChamado(chamado);
      await broadcast({
        type: "TIMER_UPDATED",
        chamado,
        startedAt: item.startedAt,
        durationMinutes: item.durationMinutes,
        timerActive: true
      });
      return { statusCode: 200, body: "Timer started" };
    }

    if (action === "pauseTimer") {
      const chamado = body.chamado;
      const item = await getChamado(chamado);
      const remaining = calcRemaining(item);
      await updateChamado(chamado, {
        timerActive: false,
        timeRemaining: remaining
      });
      const updated = await getChamado(chamado);
      await broadcast({
        type: "TIMER_UPDATED",
        chamado,
        startedAt: updated.startedAt,
        durationMinutes: updated.durationMinutes,
        timerActive: false,
        timeRemaining: updated.timeRemaining
      });
      return { statusCode: 200, body: "Timer paused" };
    }

    if (action === "getAll") {
      const chamados = await dynamo.scan({ TableName: CHAMADOS_TABLE }).promise();
      const list = chamados.Items.map((c) => ({
        ...c,
        timeRemaining: calcRemaining(c)
      }));
      await sendToConnection(connectionId, { type: "ALL_CHAMADOS", data: list });
      return { statusCode: 200, body: "Sent all chamados" };
    }

    return { statusCode: 400, body: "Unknown action" };
  }

  // Requisição REST para obter dados (para novas sessões)
  if (event.httpMethod === "GET") {
    const chamados = await dynamo.scan({ TableName: CHAMADOS_TABLE }).promise();
    const list = chamados.Items.map((c) => ({
      ...c,
      timeRemaining: calcRemaining(c)
    }));
    return {
      statusCode: 200,
      body: JSON.stringify(list)
    };
  }

  return { statusCode: 400, body: "Invalid request" };
};

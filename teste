// src/store/useChamadoStore.ts
import { create } from "zustand";

export interface ChamadoState {
  status: "pending" | "confirmed" | "escalating" | "completed";
  currentLevel: number;
  timeRemaining: number;
  timerActive: boolean;
  observations: string;
  isAttended: boolean;
  // 👇 opcional: para guardar qualquer dado extra vindo do WS
  rawWSData?: Record<string, any>;
}

interface ChamadoStore {
  chamados: Record<string, ChamadoState>;
  initChamado: (id: string) => void;
  startChamado: (id: string, duration?: number) => void;
  updateChamado: (id: string, data: Partial<ChamadoState>) => void;
  confirmChamado: (id: string, observations: string) => void;
  escalateChamado: (id: string, level: number) => void;
  completeChamado: (id: string, observations: string) => void;
  tick: () => void;
  setFromWS: (id: string, data: any) => void;
  reset: () => void;
}

export const useChamadoStore = create<ChamadoStore>((set) => ({
  chamados: {},

  initChamado: (id: string) =>
    set((state) => {
      if (state.chamados[id]) return state;
      return {
        chamados: {
          ...state.chamados,
          [id]: {
            status: "pending",
            currentLevel: 0,
            timeRemaining: 300,
            timerActive: true,
            observations: "",
            isAttended: false,
          },
        },
      };
    }),

  startChamado: (id: string, duration: number = 300) =>
    set((state) => ({
      chamados: {
        ...state.chamados,
        [id]: {
          status: "pending",
          currentLevel: 0,
          timeRemaining: duration,
          timerActive: true,
          observations: "",
          isAttended: false,
        },
      },
    })),

  updateChamado: (id: string, data: Partial<ChamadoState>) =>
    set((state) => ({
      chamados: {
        ...state.chamados,
        [id]: {
          ...state.chamados[id],
          ...data,
        },
      },
    })),

  confirmChamado: (id: string, observations: string) =>
    set((state) => ({
      chamados: {
        ...state.chamados,
        [id]: {
          ...state.chamados[id],
          status: "confirmed",
          timerActive: false,
          observations,
        },
      },
    })),

  escalateChamado: (id: string, level: number) =>
    set((state) => ({
      chamados: {
        ...state.chamados,
        [id]: {
          ...state.chamados[id],
          status: "escalating",
          currentLevel: level,
          timerActive: true,
          timeRemaining: 300,
        },
      },
    })),

  completeChamado: (id: string, observations: string) =>
    set((state) => ({
      chamados: {
        ...state.chamados,
        [id]: {
          ...state.chamados[id],
          status: "completed",
          timerActive: false,
          observations,
        },
      },
    })),

  tick: () =>
    set((state) => {
      const novos: Record<string, ChamadoState> = {};
      for (const [id, chamado] of Object.entries(state.chamados)) {
        if (chamado.timerActive && chamado.timeRemaining > 0) {
          novos[id] = {
            ...chamado,
            timeRemaining: chamado.timeRemaining - 1,
          };
        } else if (chamado.timerActive && chamado.timeRemaining <= 0) {
          novos[id] = {
            ...chamado,
            timerActive: false,
            timeRemaining: 0,
          };
        } else {
          novos[id] = chamado;
        }
      }
      return { chamados: novos };
    }),

  setFromWS: (id: string, data: any) =>
    set((state) => {
      const prev = state.chamados[id] || {
        status: "pending",
        currentLevel: 0,
        timeRemaining: 0,
        timerActive: false,
        observations: "",
        isAttended: false,
      };

      return {
        chamados: {
          ...state.chamados,
          [id]: {
            ...prev,
            // mapeia campos conhecidos
            status: data.status ?? prev.status,
            observations: data.observacao ?? prev.observations,
            timeRemaining:
              data.timerEnd && data.serverTime
                ? Math.max(0, data.timerEnd - data.serverTime)
                : prev.timeRemaining,
            timerActive:
              data.action === "timerStarted"
                ? true
                : prev.timerActive,
            // guarda tudo também em rawWSData para debug/uso futuro
            rawWSData: { ...prev.rawWSData, ...data },
          },
        },
      };
    }),

  reset: () => set({ chamados: {} }),
}));

// -------------------
// WebSocket integração
// -------------------

const WS_URL = "wss://rsgjd6wsza.execute-api.us-east-1.amazonaws.com/dev";
let socket: WebSocket | null = null;

export const initWebSocket = () => {
  if (socket) return;

  socket = new WebSocket(WS_URL);

  socket.onopen = () => {
    console.log("[WS] ✅ Conectado ao servidor");
  };

  socket.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);

      if (!data.chamado) {
        console.warn("[WS] ⚠️ Mensagem recebida sem 'chamado':", data);
        return;
      }

      const chamadoId = String(data.chamado);
      useChamadoStore.getState().setFromWS(chamadoId, data);
    } catch (err) {
      console.error("[WS] ❌ Erro ao processar mensagem:", err);
    }
  };

  socket.onclose = () => {
    console.log("[WS] 🔌 Conexão fechada. Tentando reconectar em 3s...");
    socket = null;
    setTimeout(initWebSocket, 3000);
  };

  socket.onerror = (err) => {
    console.error("[WS] 🚨 Erro no WebSocket:", err);
    socket?.close();
  };
};

export const sendWS = (msg: any) => {
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify(msg));
  } else {
    console.warn("[WS] ⚠️ Tentativa de enviar com socket fechado:", msg);
  }
};

// -------------------
// Tick global
// -------------------
setInterval(() => {
  useChamadoStore.getState().tick();
}, 1000);

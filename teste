import React, { useEffect, useRef, useState } from "react";

interface TimerState {
  timerActive: boolean;
  startedAt?: string;
  durationMinutes: number;
  timeRemaining: number;
}

const Timer: React.FC = () => {
  // Defina suas URLs diretamente aqui
  const WEBSOCKET_URL = "wss://seu-websocket-endpoint.execute-api.us-east-1.amazonaws.com/dev";
  const CHAMADO_ID = "10418007"; // Defina o chamado que deseja monitorar

  const wsRef = useRef<WebSocket | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const [timerState, setTimerState] = useState<TimerState>({
    timerActive: false,
    durationMinutes: 15,
    timeRemaining: 15 * 60,
  });

  // Conexão WebSocket
  useEffect(() => {
    console.log("🔗 Conectando WebSocket...");
    wsRef.current = new WebSocket(WEBSOCKET_URL);

    wsRef.current.onopen = () => {
      console.log("✅ WebSocket conectado");
      sendWSMessage({ action: "getState", chamado: CHAMADO_ID });
    };

    wsRef.current.onmessage = (event) => {
      console.log("📩 Mensagem recebida:", event.data);
      try {
        const data = JSON.parse(event.data);
        if (data.type === "TIMER_UPDATED") {
          setTimerState({
            timerActive: data.timerActive,
            startedAt: data.startedAt,
            durationMinutes: data.durationMinutes,
            timeRemaining: data.timeRemaining,
          });
        }
      } catch (err) {
        console.error("❌ Erro ao parsear mensagem WS:", err);
      }
    };

    wsRef.current.onclose = () => console.log("❌ WebSocket fechado");
    wsRef.current.onerror = (err) => console.error("⚠ Erro no WebSocket:", err);

    return () => wsRef.current?.close();
  }, []);

  // Atualiza o cronômetro local
  useEffect(() => {
    if (intervalRef.current) clearInterval(intervalRef.current);

    if (timerState.timerActive) {
      intervalRef.current = setInterval(() => {
        setTimerState((prev) => ({
          ...prev,
          timeRemaining: Math.max(prev.timeRemaining - 1, 0),
        }));
      }, 1000);
    }

    return () => intervalRef.current && clearInterval(intervalRef.current);
  }, [timerState.timerActive]);

  // Envia mensagem para o WebSocket
  const sendWSMessage = (msg: any) => {
    if (!wsRef.current) return;
    if (wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(msg));
      console.log("📤 Mensagem enviada:", msg);
    } else {
      console.log("⏳ WS não pronto, tentando novamente em 200ms...");
      setTimeout(() => sendWSMessage(msg), 200);
    }
  };

  const handleStart = () => sendWSMessage({ action: "startTimer", chamado: CHAMADO_ID });
  const handlePause = () => sendWSMessage({ action: "pauseTimer", chamado: CHAMADO_ID });

  const formatTime = (seconds: number) => {
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
  };

  return (
    <div style={{ border: "1px solid #ccc", padding: "10px", width: "250px" }}>
      <h3>Chamado: {CHAMADO_ID}</h3>
      <p>Tempo restante: {formatTime(timerState.timeRemaining)}</p>
      <p>Status: {timerState.timerActive ? "Ativo" : "Pausado"}</p>
      <button onClick={handleStart} disabled={timerState.timerActive}>
        Iniciar
      </button>
      <button onClick={handlePause} disabled={!timerState.timerActive}>
        Pausar
      </button>
    </div>
  );
};

export default Timer;
